{"version":3,"file":"static/js/lib-router.7b48a0f0.js","sources":["../../../node_modules/.pnpm/@remix-run+router@1.8.0/node_modules/@remix-run/router/dist/router.js","../../../node_modules/.pnpm/react-router-dom@6.15.0_react-dom@18.2.0_react@18.2.0/node_modules/react-router-dom/dist/index.js","../../../node_modules/.pnpm/react-router@6.15.0_react@18.2.0/node_modules/react-router/dist/index.js"],"sourcesContent":["/**\n * @remix-run/router v1.8.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */function _extends(){_extends=Object.assign?Object.assign.bind():function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key];}}}return target;};return _extends.apply(this,arguments);}////////////////////////////////////////////////////////////////////////////////\n//#region Types and Constants\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Actions represent the type of change to a location value.\n */var Action;(function(Action){/**\n   * A POP indicates a change to an arbitrary index in the history stack, such\n   * as a back or forward navigation. It does not describe the direction of the\n   * navigation, only that the current index changed.\n   *\n   * Note: This is the default action for newly created history objects.\n   */Action[\"Pop\"]=\"POP\";/**\n   * A PUSH indicates a new entry being added to the history stack, such as when\n   * a link is clicked and a new page loads. When this happens, all subsequent\n   * entries in the stack are lost.\n   */Action[\"Push\"]=\"PUSH\";/**\n   * A REPLACE indicates the entry at the current index in the history stack\n   * being replaced by a new one.\n   */Action[\"Replace\"]=\"REPLACE\";})(Action||(Action={}));const PopStateEventType=\"popstate\";/**\n * Memory history stores the current location in memory. It is designed for use\n * in stateful non-browser environments like tests and React Native.\n */function createMemoryHistory(options){if(options===void 0){options={};}let{initialEntries=[\"/\"],initialIndex,v5Compat=false}=options;let entries;// Declare so we can access from createMemoryLocation\nentries=initialEntries.map((entry,index)=>createMemoryLocation(entry,typeof entry===\"string\"?null:entry.state,index===0?\"default\":undefined));let index=clampIndex(initialIndex==null?entries.length-1:initialIndex);let action=Action.Pop;let listener=null;function clampIndex(n){return Math.min(Math.max(n,0),entries.length-1);}function getCurrentLocation(){return entries[index];}function createMemoryLocation(to,state,key){if(state===void 0){state=null;}let location=createLocation(entries?getCurrentLocation().pathname:\"/\",to,state,key);warning(location.pathname.charAt(0)===\"/\",\"relative pathnames are not supported in memory history: \"+JSON.stringify(to));return location;}function createHref(to){return typeof to===\"string\"?to:createPath(to);}let history={get index(){return index;},get action(){return action;},get location(){return getCurrentLocation();},createHref,createURL(to){return new URL(createHref(to),\"http://localhost\");},encodeLocation(to){let path=typeof to===\"string\"?parsePath(to):to;return{pathname:path.pathname||\"\",search:path.search||\"\",hash:path.hash||\"\"};},push(to,state){action=Action.Push;let nextLocation=createMemoryLocation(to,state);index+=1;entries.splice(index,entries.length,nextLocation);if(v5Compat&&listener){listener({action,location:nextLocation,delta:1});}},replace(to,state){action=Action.Replace;let nextLocation=createMemoryLocation(to,state);entries[index]=nextLocation;if(v5Compat&&listener){listener({action,location:nextLocation,delta:0});}},go(delta){action=Action.Pop;let nextIndex=clampIndex(index+delta);let nextLocation=entries[nextIndex];index=nextIndex;if(listener){listener({action,location:nextLocation,delta});}},listen(fn){listener=fn;return()=>{listener=null;};}};return history;}/**\n * Browser history stores the location in regular URLs. This is the standard for\n * most web apps, but it requires some configuration on the server to ensure you\n * serve the same app at multiple URLs.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createbrowserhistory\n */function createBrowserHistory(options){if(options===void 0){options={};}function createBrowserLocation(window,globalHistory){let{pathname,search,hash}=window.location;return createLocation(\"\",{pathname,search,hash},// state defaults to `null` because `window.history.state` does\nglobalHistory.state&&globalHistory.state.usr||null,globalHistory.state&&globalHistory.state.key||\"default\");}function createBrowserHref(window,to){return typeof to===\"string\"?to:createPath(to);}return getUrlBasedHistory(createBrowserLocation,createBrowserHref,null,options);}/**\n * Hash history stores the location in window.location.hash. This makes it ideal\n * for situations where you don't want to send the location to the server for\n * some reason, either because you do cannot configure it or the URL space is\n * reserved for something else.\n *\n * @see https://github.com/remix-run/history/tree/main/docs/api-reference.md#createhashhistory\n */function createHashHistory(options){if(options===void 0){options={};}function createHashLocation(window,globalHistory){let{pathname=\"/\",search=\"\",hash=\"\"}=parsePath(window.location.hash.substr(1));// Hash URL should always have a leading / just like window.location.pathname\n// does, so if an app ends up at a route like /#something then we add a\n// leading slash so all of our path-matching behaves the same as if it would\n// in a browser router.  This is particularly important when there exists a\n// root splat route (<Route path=\"*\">) since that matches internally against\n// \"/*\" and we'd expect /#something to 404 in a hash router app.\nif(!pathname.startsWith(\"/\")&&!pathname.startsWith(\".\")){pathname=\"/\"+pathname;}return createLocation(\"\",{pathname,search,hash},// state defaults to `null` because `window.history.state` does\nglobalHistory.state&&globalHistory.state.usr||null,globalHistory.state&&globalHistory.state.key||\"default\");}function createHashHref(window,to){let base=window.document.querySelector(\"base\");let href=\"\";if(base&&base.getAttribute(\"href\")){let url=window.location.href;let hashIndex=url.indexOf(\"#\");href=hashIndex===-1?url:url.slice(0,hashIndex);}return href+\"#\"+(typeof to===\"string\"?to:createPath(to));}function validateHashLocation(location,to){warning(location.pathname.charAt(0)===\"/\",\"relative pathnames are not supported in hash history.push(\"+JSON.stringify(to)+\")\");}return getUrlBasedHistory(createHashLocation,createHashHref,validateHashLocation,options);}function invariant(value,message){if(value===false||value===null||typeof value===\"undefined\"){throw new Error(message);}}function warning(cond,message){if(!cond){// eslint-disable-next-line no-console\nif(typeof console!==\"undefined\")console.warn(message);try{// Welcome to debugging history!\n//\n// This error is thrown as a convenience so you can more easily\n// find the source for a warning that appears in the console by\n// enabling \"pause on exceptions\" in your JavaScript debugger.\nthrow new Error(message);// eslint-disable-next-line no-empty\n}catch(e){}}}function createKey(){return Math.random().toString(36).substr(2,8);}/**\n * For browser-based histories, we combine the state and key into an object\n */function getHistoryState(location,index){return{usr:location.state,key:location.key,idx:index};}/**\n * Creates a Location object with a unique key from the given Path\n */function createLocation(current,to,state,key){if(state===void 0){state=null;}let location=_extends({pathname:typeof current===\"string\"?current:current.pathname,search:\"\",hash:\"\"},typeof to===\"string\"?parsePath(to):to,{state,// TODO: This could be cleaned up.  push/replace should probably just take\n// full Locations now and avoid the need to run through this flow at all\n// But that's a pretty big refactor to the current test suite so going to\n// keep as is for the time being and just let any incoming keys take precedence\nkey:to&&to.key||key||createKey()});return location;}/**\n * Creates a string URL path from the given pathname, search, and hash components.\n */function createPath(_ref){let{pathname=\"/\",search=\"\",hash=\"\"}=_ref;if(search&&search!==\"?\")pathname+=search.charAt(0)===\"?\"?search:\"?\"+search;if(hash&&hash!==\"#\")pathname+=hash.charAt(0)===\"#\"?hash:\"#\"+hash;return pathname;}/**\n * Parses a string URL path into its separate pathname, search, and hash components.\n */function parsePath(path){let parsedPath={};if(path){let hashIndex=path.indexOf(\"#\");if(hashIndex>=0){parsedPath.hash=path.substr(hashIndex);path=path.substr(0,hashIndex);}let searchIndex=path.indexOf(\"?\");if(searchIndex>=0){parsedPath.search=path.substr(searchIndex);path=path.substr(0,searchIndex);}if(path){parsedPath.pathname=path;}}return parsedPath;}function getUrlBasedHistory(getLocation,createHref,validateLocation,options){if(options===void 0){options={};}let{window=document.defaultView,v5Compat=false}=options;let globalHistory=window.history;let action=Action.Pop;let listener=null;let index=getIndex();// Index should only be null when we initialize. If not, it's because the\n// user called history.pushState or history.replaceState directly, in which\n// case we should log a warning as it will result in bugs.\nif(index==null){index=0;globalHistory.replaceState(_extends({},globalHistory.state,{idx:index}),\"\");}function getIndex(){let state=globalHistory.state||{idx:null};return state.idx;}function handlePop(){action=Action.Pop;let nextIndex=getIndex();let delta=nextIndex==null?null:nextIndex-index;index=nextIndex;if(listener){listener({action,location:history.location,delta});}}function push(to,state){action=Action.Push;let location=createLocation(history.location,to,state);if(validateLocation)validateLocation(location,to);index=getIndex()+1;let historyState=getHistoryState(location,index);let url=history.createHref(location);// try...catch because iOS limits us to 100 pushState calls :/\ntry{globalHistory.pushState(historyState,\"\",url);}catch(error){// If the exception is because `state` can't be serialized, let that throw\n// outwards just like a replace call would so the dev knows the cause\n// https://html.spec.whatwg.org/multipage/nav-history-apis.html#shared-history-push/replace-state-steps\n// https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal\nif(error instanceof DOMException&&error.name===\"DataCloneError\"){throw error;}// They are going to lose state here, but there is no real\n// way to warn them about it since the page will refresh...\nwindow.location.assign(url);}if(v5Compat&&listener){listener({action,location:history.location,delta:1});}}function replace(to,state){action=Action.Replace;let location=createLocation(history.location,to,state);if(validateLocation)validateLocation(location,to);index=getIndex();let historyState=getHistoryState(location,index);let url=history.createHref(location);globalHistory.replaceState(historyState,\"\",url);if(v5Compat&&listener){listener({action,location:history.location,delta:0});}}function createURL(to){// window.location.origin is \"null\" (the literal string value) in Firefox\n// under certain conditions, notably when serving from a local HTML file\n// See https://bugzilla.mozilla.org/show_bug.cgi?id=878297\nlet base=window.location.origin!==\"null\"?window.location.origin:window.location.href;let href=typeof to===\"string\"?to:createPath(to);invariant(base,\"No window.location.(origin|href) available to create URL for href: \"+href);return new URL(href,base);}let history={get action(){return action;},get location(){return getLocation(window,globalHistory);},listen(fn){if(listener){throw new Error(\"A history only accepts one active listener\");}window.addEventListener(PopStateEventType,handlePop);listener=fn;return()=>{window.removeEventListener(PopStateEventType,handlePop);listener=null;};},createHref(to){return createHref(window,to);},createURL,encodeLocation(to){// Encode a Location the same way window.location would\nlet url=createURL(to);return{pathname:url.pathname,search:url.search,hash:url.hash};},push,replace,go(n){return globalHistory.go(n);}};return history;}//#endregion\nvar ResultType;(function(ResultType){ResultType[\"data\"]=\"data\";ResultType[\"deferred\"]=\"deferred\";ResultType[\"redirect\"]=\"redirect\";ResultType[\"error\"]=\"error\";})(ResultType||(ResultType={}));const immutableRouteKeys=new Set([\"lazy\",\"caseSensitive\",\"path\",\"id\",\"index\",\"children\"]);function isIndexRoute(route){return route.index===true;}// Walk the route tree generating unique IDs where necessary so we are working\n// solely with AgnosticDataRouteObject's within the Router\nfunction convertRoutesToDataRoutes(routes,mapRouteProperties,parentPath,manifest){if(parentPath===void 0){parentPath=[];}if(manifest===void 0){manifest={};}return routes.map((route,index)=>{let treePath=[...parentPath,index];let id=typeof route.id===\"string\"?route.id:treePath.join(\"-\");invariant(route.index!==true||!route.children,\"Cannot specify children on an index route\");invariant(!manifest[id],\"Found a route id collision on id \\\"\"+id+\"\\\".  Route \"+\"id's must be globally unique within Data Router usages\");if(isIndexRoute(route)){let indexRoute=_extends({},route,mapRouteProperties(route),{id});manifest[id]=indexRoute;return indexRoute;}else{let pathOrLayoutRoute=_extends({},route,mapRouteProperties(route),{id,children:undefined});manifest[id]=pathOrLayoutRoute;if(route.children){pathOrLayoutRoute.children=convertRoutesToDataRoutes(route.children,mapRouteProperties,treePath,manifest);}return pathOrLayoutRoute;}});}/**\n * Matches the given routes to a location and returns the match data.\n *\n * @see https://reactrouter.com/utils/match-routes\n */function matchRoutes(routes,locationArg,basename){if(basename===void 0){basename=\"/\";}let location=typeof locationArg===\"string\"?parsePath(locationArg):locationArg;let pathname=stripBasename(location.pathname||\"/\",basename);if(pathname==null){return null;}let branches=flattenRoutes(routes);rankRouteBranches(branches);let matches=null;for(let i=0;matches==null&&i<branches.length;++i){matches=matchRouteBranch(branches[i],// Incoming pathnames are generally encoded from either window.location\n// or from router.navigate, but we want to match against the unencoded\n// paths in the route definitions.  Memory router locations won't be\n// encoded here but there also shouldn't be anything to decode so this\n// should be a safe operation.  This avoids needing matchRoutes to be\n// history-aware.\nsafelyDecodeURI(pathname));}return matches;}function flattenRoutes(routes,branches,parentsMeta,parentPath){if(branches===void 0){branches=[];}if(parentsMeta===void 0){parentsMeta=[];}if(parentPath===void 0){parentPath=\"\";}let flattenRoute=(route,index,relativePath)=>{let meta={relativePath:relativePath===undefined?route.path||\"\":relativePath,caseSensitive:route.caseSensitive===true,childrenIndex:index,route};if(meta.relativePath.startsWith(\"/\")){invariant(meta.relativePath.startsWith(parentPath),\"Absolute route path \\\"\"+meta.relativePath+\"\\\" nested under path \"+(\"\\\"\"+parentPath+\"\\\" is not valid. An absolute child route path \")+\"must start with the combined path of all its parent routes.\");meta.relativePath=meta.relativePath.slice(parentPath.length);}let path=joinPaths([parentPath,meta.relativePath]);let routesMeta=parentsMeta.concat(meta);// Add the children before adding this route to the array so we traverse the\n// route tree depth-first and child routes appear before their parents in\n// the \"flattened\" version.\nif(route.children&&route.children.length>0){invariant(// Our types know better, but runtime JS may not!\n// @ts-expect-error\nroute.index!==true,\"Index routes must not have child routes. Please remove \"+(\"all child routes from route path \\\"\"+path+\"\\\".\"));flattenRoutes(route.children,branches,routesMeta,path);}// Routes without a path shouldn't ever match by themselves unless they are\n// index routes, so don't add them to the list of possible branches.\nif(route.path==null&&!route.index){return;}branches.push({path,score:computeScore(path,route.index),routesMeta});};routes.forEach((route,index)=>{var _route$path;// coarse-grain check for optional params\nif(route.path===\"\"||!((_route$path=route.path)!=null&&_route$path.includes(\"?\"))){flattenRoute(route,index);}else{for(let exploded of explodeOptionalSegments(route.path)){flattenRoute(route,index,exploded);}}});return branches;}/**\n * Computes all combinations of optional path segments for a given path,\n * excluding combinations that are ambiguous and of lower priority.\n *\n * For example, `/one/:two?/three/:four?/:five?` explodes to:\n * - `/one/three`\n * - `/one/:two/three`\n * - `/one/three/:four`\n * - `/one/three/:five`\n * - `/one/:two/three/:four`\n * - `/one/:two/three/:five`\n * - `/one/three/:four/:five`\n * - `/one/:two/three/:four/:five`\n */function explodeOptionalSegments(path){let segments=path.split(\"/\");if(segments.length===0)return[];let[first,...rest]=segments;// Optional path segments are denoted by a trailing `?`\nlet isOptional=first.endsWith(\"?\");// Compute the corresponding required segment: `foo?` -> `foo`\nlet required=first.replace(/\\?$/,\"\");if(rest.length===0){// Intepret empty string as omitting an optional segment\n// `[\"one\", \"\", \"three\"]` corresponds to omitting `:two` from `/one/:two?/three` -> `/one/three`\nreturn isOptional?[required,\"\"]:[required];}let restExploded=explodeOptionalSegments(rest.join(\"/\"));let result=[];// All child paths with the prefix.  Do this for all children before the\n// optional version for all children so we get consistent ordering where the\n// parent optional aspect is preferred as required.  Otherwise, we can get\n// child sections interspersed where deeper optional segments are higher than\n// parent optional segments, where for example, /:two would explodes _earlier_\n// then /:one.  By always including the parent as required _for all children_\n// first, we avoid this issue\nresult.push(...restExploded.map(subpath=>subpath===\"\"?required:[required,subpath].join(\"/\")));// Then if this is an optional value, add all child versions without\nif(isOptional){result.push(...restExploded);}// for absolute paths, ensure `/` instead of empty segment\nreturn result.map(exploded=>path.startsWith(\"/\")&&exploded===\"\"?\"/\":exploded);}function rankRouteBranches(branches){branches.sort((a,b)=>a.score!==b.score?b.score-a.score// Higher score first\n:compareIndexes(a.routesMeta.map(meta=>meta.childrenIndex),b.routesMeta.map(meta=>meta.childrenIndex)));}const paramRe=/^:\\w+$/;const dynamicSegmentValue=3;const indexRouteValue=2;const emptySegmentValue=1;const staticSegmentValue=10;const splatPenalty=-2;const isSplat=s=>s===\"*\";function computeScore(path,index){let segments=path.split(\"/\");let initialScore=segments.length;if(segments.some(isSplat)){initialScore+=splatPenalty;}if(index){initialScore+=indexRouteValue;}return segments.filter(s=>!isSplat(s)).reduce((score,segment)=>score+(paramRe.test(segment)?dynamicSegmentValue:segment===\"\"?emptySegmentValue:staticSegmentValue),initialScore);}function compareIndexes(a,b){let siblings=a.length===b.length&&a.slice(0,-1).every((n,i)=>n===b[i]);return siblings?// If two routes are siblings, we should try to match the earlier sibling\n// first. This allows people to have fine-grained control over the matching\n// behavior by simply putting routes with identical paths in the order they\n// want them tried.\na[a.length-1]-b[b.length-1]:// Otherwise, it doesn't really make sense to rank non-siblings by index,\n// so they sort equally.\n0;}function matchRouteBranch(branch,pathname){let{routesMeta}=branch;let matchedParams={};let matchedPathname=\"/\";let matches=[];for(let i=0;i<routesMeta.length;++i){let meta=routesMeta[i];let end=i===routesMeta.length-1;let remainingPathname=matchedPathname===\"/\"?pathname:pathname.slice(matchedPathname.length)||\"/\";let match=matchPath({path:meta.relativePath,caseSensitive:meta.caseSensitive,end},remainingPathname);if(!match)return null;Object.assign(matchedParams,match.params);let route=meta.route;matches.push({// TODO: Can this as be avoided?\nparams:matchedParams,pathname:joinPaths([matchedPathname,match.pathname]),pathnameBase:normalizePathname(joinPaths([matchedPathname,match.pathnameBase])),route});if(match.pathnameBase!==\"/\"){matchedPathname=joinPaths([matchedPathname,match.pathnameBase]);}}return matches;}/**\n * Returns a path with params interpolated.\n *\n * @see https://reactrouter.com/utils/generate-path\n */function generatePath(originalPath,params){if(params===void 0){params={};}let path=originalPath;if(path.endsWith(\"*\")&&path!==\"*\"&&!path.endsWith(\"/*\")){warning(false,\"Route path \\\"\"+path+\"\\\" will be treated as if it were \"+(\"\\\"\"+path.replace(/\\*$/,\"/*\")+\"\\\" because the `*` character must \")+\"always follow a `/` in the pattern. To get rid of this warning, \"+(\"please change the route path to \\\"\"+path.replace(/\\*$/,\"/*\")+\"\\\".\"));path=path.replace(/\\*$/,\"/*\");}// ensure `/` is added at the beginning if the path is absolute\nconst prefix=path.startsWith(\"/\")?\"/\":\"\";const stringify=p=>p==null?\"\":typeof p===\"string\"?p:String(p);const segments=path.split(/\\/+/).map((segment,index,array)=>{const isLastSegment=index===array.length-1;// only apply the splat if it's the last segment\nif(isLastSegment&&segment===\"*\"){const star=\"*\";// Apply the splat\nreturn stringify(params[star]);}const keyMatch=segment.match(/^:(\\w+)(\\??)$/);if(keyMatch){const[,key,optional]=keyMatch;let param=params[key];invariant(optional===\"?\"||param!=null,\"Missing \\\":\"+key+\"\\\" param\");return stringify(param);}// Remove any optional markers from optional static segments\nreturn segment.replace(/\\?$/g,\"\");})// Remove empty segments\n.filter(segment=>!!segment);return prefix+segments.join(\"/\");}/**\n * Performs pattern matching on a URL pathname and returns information about\n * the match.\n *\n * @see https://reactrouter.com/utils/match-path\n */function matchPath(pattern,pathname){if(typeof pattern===\"string\"){pattern={path:pattern,caseSensitive:false,end:true};}let[matcher,paramNames]=compilePath(pattern.path,pattern.caseSensitive,pattern.end);let match=pathname.match(matcher);if(!match)return null;let matchedPathname=match[0];let pathnameBase=matchedPathname.replace(/(.)\\/+$/,\"$1\");let captureGroups=match.slice(1);let params=paramNames.reduce((memo,paramName,index)=>{// We need to compute the pathnameBase here using the raw splat value\n// instead of using params[\"*\"] later because it will be decoded then\nif(paramName===\"*\"){let splatValue=captureGroups[index]||\"\";pathnameBase=matchedPathname.slice(0,matchedPathname.length-splatValue.length).replace(/(.)\\/+$/,\"$1\");}memo[paramName]=safelyDecodeURIComponent(captureGroups[index]||\"\",paramName);return memo;},{});return{params,pathname:matchedPathname,pathnameBase,pattern};}function compilePath(path,caseSensitive,end){if(caseSensitive===void 0){caseSensitive=false;}if(end===void 0){end=true;}warning(path===\"*\"||!path.endsWith(\"*\")||path.endsWith(\"/*\"),\"Route path \\\"\"+path+\"\\\" will be treated as if it were \"+(\"\\\"\"+path.replace(/\\*$/,\"/*\")+\"\\\" because the `*` character must \")+\"always follow a `/` in the pattern. To get rid of this warning, \"+(\"please change the route path to \\\"\"+path.replace(/\\*$/,\"/*\")+\"\\\".\"));let paramNames=[];let regexpSource=\"^\"+path.replace(/\\/*\\*?$/,\"\")// Ignore trailing / and /*, we'll handle it below\n.replace(/^\\/*/,\"/\")// Make sure it has a leading /\n.replace(/[\\\\.*+^$?{}|()[\\]]/g,\"\\\\$&\")// Escape special regex chars\n.replace(/\\/:(\\w+)/g,(_,paramName)=>{paramNames.push(paramName);return\"/([^\\\\/]+)\";});if(path.endsWith(\"*\")){paramNames.push(\"*\");regexpSource+=path===\"*\"||path===\"/*\"?\"(.*)$\"// Already matched the initial /, just match the rest\n:\"(?:\\\\/(.+)|\\\\/*)$\";// Don't include the / in params[\"*\"]\n}else if(end){// When matching to the end, ignore trailing slashes\nregexpSource+=\"\\\\/*$\";}else if(path!==\"\"&&path!==\"/\"){// If our path is non-empty and contains anything beyond an initial slash,\n// then we have _some_ form of path in our regex so we should expect to\n// match only if we find the end of this path segment.  Look for an optional\n// non-captured trailing slash (to match a portion of the URL) or the end\n// of the path (if we've matched to the end).  We used to do this with a\n// word boundary but that gives false positives on routes like\n// /user-preferences since `-` counts as a word boundary.\nregexpSource+=\"(?:(?=\\\\/|$))\";}else;let matcher=new RegExp(regexpSource,caseSensitive?undefined:\"i\");return[matcher,paramNames];}function safelyDecodeURI(value){try{return decodeURI(value);}catch(error){warning(false,\"The URL path \\\"\"+value+\"\\\" could not be decoded because it is is a \"+\"malformed URL segment. This is probably due to a bad percent \"+(\"encoding (\"+error+\").\"));return value;}}function safelyDecodeURIComponent(value,paramName){try{return decodeURIComponent(value);}catch(error){warning(false,\"The value for the URL param \\\"\"+paramName+\"\\\" will not be decoded because\"+(\" the string \\\"\"+value+\"\\\" is a malformed URL segment. This is probably\")+(\" due to a bad percent encoding (\"+error+\").\"));return value;}}/**\n * @private\n */function stripBasename(pathname,basename){if(basename===\"/\")return pathname;if(!pathname.toLowerCase().startsWith(basename.toLowerCase())){return null;}// We want to leave trailing slash behavior in the user's control, so if they\n// specify a basename with a trailing slash, we should support it\nlet startIndex=basename.endsWith(\"/\")?basename.length-1:basename.length;let nextChar=pathname.charAt(startIndex);if(nextChar&&nextChar!==\"/\"){// pathname does not start with basename/\nreturn null;}return pathname.slice(startIndex)||\"/\";}/**\n * Returns a resolved path object relative to the given pathname.\n *\n * @see https://reactrouter.com/utils/resolve-path\n */function resolvePath(to,fromPathname){if(fromPathname===void 0){fromPathname=\"/\";}let{pathname:toPathname,search=\"\",hash=\"\"}=typeof to===\"string\"?parsePath(to):to;let pathname=toPathname?toPathname.startsWith(\"/\")?toPathname:resolvePathname(toPathname,fromPathname):fromPathname;return{pathname,search:normalizeSearch(search),hash:normalizeHash(hash)};}function resolvePathname(relativePath,fromPathname){let segments=fromPathname.replace(/\\/+$/,\"\").split(\"/\");let relativeSegments=relativePath.split(\"/\");relativeSegments.forEach(segment=>{if(segment===\"..\"){// Keep the root \"\" segment so the pathname starts at /\nif(segments.length>1)segments.pop();}else if(segment!==\".\"){segments.push(segment);}});return segments.length>1?segments.join(\"/\"):\"/\";}function getInvalidPathError(char,field,dest,path){return\"Cannot include a '\"+char+\"' character in a manually specified \"+(\"`to.\"+field+\"` field [\"+JSON.stringify(path)+\"].  Please separate it out to the \")+(\"`to.\"+dest+\"` field. Alternatively you may provide the full path as \")+\"a string in <Link to=\\\"...\\\"> and the router will parse it for you.\";}/**\n * @private\n *\n * When processing relative navigation we want to ignore ancestor routes that\n * do not contribute to the path, such that index/pathless layout routes don't\n * interfere.\n *\n * For example, when moving a route element into an index route and/or a\n * pathless layout route, relative link behavior contained within should stay\n * the same.  Both of the following examples should link back to the root:\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\" element={<Link to=\"..\"}>\n *   </Route>\n *\n *   <Route path=\"/\">\n *     <Route path=\"accounts\">\n *       <Route element={<AccountsLayout />}>       // <-- Does not contribute\n *         <Route index element={<Link to=\"..\"} />  // <-- Does not contribute\n *       </Route\n *     </Route>\n *   </Route>\n */function getPathContributingMatches(matches){return matches.filter((match,index)=>index===0||match.route.path&&match.route.path.length>0);}/**\n * @private\n */function resolveTo(toArg,routePathnames,locationPathname,isPathRelative){if(isPathRelative===void 0){isPathRelative=false;}let to;if(typeof toArg===\"string\"){to=parsePath(toArg);}else{to=_extends({},toArg);invariant(!to.pathname||!to.pathname.includes(\"?\"),getInvalidPathError(\"?\",\"pathname\",\"search\",to));invariant(!to.pathname||!to.pathname.includes(\"#\"),getInvalidPathError(\"#\",\"pathname\",\"hash\",to));invariant(!to.search||!to.search.includes(\"#\"),getInvalidPathError(\"#\",\"search\",\"hash\",to));}let isEmptyPath=toArg===\"\"||to.pathname===\"\";let toPathname=isEmptyPath?\"/\":to.pathname;let from;// Routing is relative to the current pathname if explicitly requested.\n//\n// If a pathname is explicitly provided in `to`, it should be relative to the\n// route context. This is explained in `Note on `<Link to>` values` in our\n// migration guide from v5 as a means of disambiguation between `to` values\n// that begin with `/` and those that do not. However, this is problematic for\n// `to` values that do not provide a pathname. `to` can simply be a search or\n// hash string, in which case we should assume that the navigation is relative\n// to the current location's pathname and *not* the route pathname.\nif(isPathRelative||toPathname==null){from=locationPathname;}else{let routePathnameIndex=routePathnames.length-1;if(toPathname.startsWith(\"..\")){let toSegments=toPathname.split(\"/\");// Each leading .. segment means \"go up one route\" instead of \"go up one\n// URL segment\".  This is a key difference from how <a href> works and a\n// major reason we call this a \"to\" value instead of a \"href\".\nwhile(toSegments[0]===\"..\"){toSegments.shift();routePathnameIndex-=1;}to.pathname=toSegments.join(\"/\");}// If there are more \"..\" segments than parent routes, resolve relative to\n// the root / URL.\nfrom=routePathnameIndex>=0?routePathnames[routePathnameIndex]:\"/\";}let path=resolvePath(to,from);// Ensure the pathname has a trailing slash if the original \"to\" had one\nlet hasExplicitTrailingSlash=toPathname&&toPathname!==\"/\"&&toPathname.endsWith(\"/\");// Or if this was a link to the current path which has a trailing slash\nlet hasCurrentTrailingSlash=(isEmptyPath||toPathname===\".\")&&locationPathname.endsWith(\"/\");if(!path.pathname.endsWith(\"/\")&&(hasExplicitTrailingSlash||hasCurrentTrailingSlash)){path.pathname+=\"/\";}return path;}/**\n * @private\n */function getToPathname(to){// Empty strings should be treated the same as / paths\nreturn to===\"\"||to.pathname===\"\"?\"/\":typeof to===\"string\"?parsePath(to).pathname:to.pathname;}/**\n * @private\n */const joinPaths=paths=>paths.join(\"/\").replace(/\\/\\/+/g,\"/\");/**\n * @private\n */const normalizePathname=pathname=>pathname.replace(/\\/+$/,\"\").replace(/^\\/*/,\"/\");/**\n * @private\n */const normalizeSearch=search=>!search||search===\"?\"?\"\":search.startsWith(\"?\")?search:\"?\"+search;/**\n * @private\n */const normalizeHash=hash=>!hash||hash===\"#\"?\"\":hash.startsWith(\"#\")?hash:\"#\"+hash;/**\n * This is a shortcut for creating `application/json` responses. Converts `data`\n * to JSON and sets the `Content-Type` header.\n */const json=function json(data,init){if(init===void 0){init={};}let responseInit=typeof init===\"number\"?{status:init}:init;let headers=new Headers(responseInit.headers);if(!headers.has(\"Content-Type\")){headers.set(\"Content-Type\",\"application/json; charset=utf-8\");}return new Response(JSON.stringify(data),_extends({},responseInit,{headers}));};class AbortedDeferredError extends Error{}class DeferredData{constructor(data,responseInit){this.pendingKeysSet=new Set();this.subscribers=new Set();this.deferredKeys=[];invariant(data&&typeof data===\"object\"&&!Array.isArray(data),\"defer() only accepts plain objects\");// Set up an AbortController + Promise we can race against to exit early\n// cancellation\nlet reject;this.abortPromise=new Promise((_,r)=>reject=r);this.controller=new AbortController();let onAbort=()=>reject(new AbortedDeferredError(\"Deferred data aborted\"));this.unlistenAbortSignal=()=>this.controller.signal.removeEventListener(\"abort\",onAbort);this.controller.signal.addEventListener(\"abort\",onAbort);this.data=Object.entries(data).reduce((acc,_ref)=>{let[key,value]=_ref;return Object.assign(acc,{[key]:this.trackPromise(key,value)});},{});if(this.done){// All incoming values were resolved\nthis.unlistenAbortSignal();}this.init=responseInit;}trackPromise(key,value){if(!(value instanceof Promise)){return value;}this.deferredKeys.push(key);this.pendingKeysSet.add(key);// We store a little wrapper promise that will be extended with\n// _data/_error props upon resolve/reject\nlet promise=Promise.race([value,this.abortPromise]).then(data=>this.onSettle(promise,key,undefined,data),error=>this.onSettle(promise,key,error));// Register rejection listeners to avoid uncaught promise rejections on\n// errors or aborted deferred values\npromise.catch(()=>{});Object.defineProperty(promise,\"_tracked\",{get:()=>true});return promise;}onSettle(promise,key,error,data){if(this.controller.signal.aborted&&error instanceof AbortedDeferredError){this.unlistenAbortSignal();Object.defineProperty(promise,\"_error\",{get:()=>error});return Promise.reject(error);}this.pendingKeysSet.delete(key);if(this.done){// Nothing left to abort!\nthis.unlistenAbortSignal();}// If the promise was resolved/rejected with undefined, we'll throw an error as you\n// should always resolve with a value or null\nif(error===undefined&&data===undefined){let undefinedError=new Error(\"Deferred data for key \\\"\"+key+\"\\\" resolved/rejected with `undefined`, \"+\"you must resolve/reject with a value or `null`.\");Object.defineProperty(promise,\"_error\",{get:()=>undefinedError});this.emit(false,key);return Promise.reject(undefinedError);}if(data===undefined){Object.defineProperty(promise,\"_error\",{get:()=>error});this.emit(false,key);return Promise.reject(error);}Object.defineProperty(promise,\"_data\",{get:()=>data});this.emit(false,key);return data;}emit(aborted,settledKey){this.subscribers.forEach(subscriber=>subscriber(aborted,settledKey));}subscribe(fn){this.subscribers.add(fn);return()=>this.subscribers.delete(fn);}cancel(){this.controller.abort();this.pendingKeysSet.forEach((v,k)=>this.pendingKeysSet.delete(k));this.emit(true);}async resolveData(signal){let aborted=false;if(!this.done){let onAbort=()=>this.cancel();signal.addEventListener(\"abort\",onAbort);aborted=await new Promise(resolve=>{this.subscribe(aborted=>{signal.removeEventListener(\"abort\",onAbort);if(aborted||this.done){resolve(aborted);}});});}return aborted;}get done(){return this.pendingKeysSet.size===0;}get unwrappedData(){invariant(this.data!==null&&this.done,\"Can only unwrap data on initialized and settled deferreds\");return Object.entries(this.data).reduce((acc,_ref2)=>{let[key,value]=_ref2;return Object.assign(acc,{[key]:unwrapTrackedPromise(value)});},{});}get pendingKeys(){return Array.from(this.pendingKeysSet);}}function isTrackedPromise(value){return value instanceof Promise&&value._tracked===true;}function unwrapTrackedPromise(value){if(!isTrackedPromise(value)){return value;}if(value._error){throw value._error;}return value._data;}const defer=function defer(data,init){if(init===void 0){init={};}let responseInit=typeof init===\"number\"?{status:init}:init;return new DeferredData(data,responseInit);};/**\n * A redirect response. Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */const redirect=function redirect(url,init){if(init===void 0){init=302;}let responseInit=init;if(typeof responseInit===\"number\"){responseInit={status:responseInit};}else if(typeof responseInit.status===\"undefined\"){responseInit.status=302;}let headers=new Headers(responseInit.headers);headers.set(\"Location\",url);return new Response(null,_extends({},responseInit,{headers}));};/**\n * A redirect response that will force a document reload to the new location.\n * Sets the status code and the `Location` header.\n * Defaults to \"302 Found\".\n */const redirectDocument=(url,init)=>{let response=redirect(url,init);response.headers.set(\"X-Remix-Reload-Document\",\"true\");return response;};/**\n * @private\n * Utility class we use to hold auto-unwrapped 4xx/5xx Response bodies\n */class ErrorResponse{constructor(status,statusText,data,internal){if(internal===void 0){internal=false;}this.status=status;this.statusText=statusText||\"\";this.internal=internal;if(data instanceof Error){this.data=data.toString();this.error=data;}else{this.data=data;}}}/**\n * Check if the given error is an ErrorResponse generated from a 4xx/5xx\n * Response thrown from an action/loader\n */function isRouteErrorResponse(error){return error!=null&&typeof error.status===\"number\"&&typeof error.statusText===\"string\"&&typeof error.internal===\"boolean\"&&\"data\"in error;}const validMutationMethodsArr=[\"post\",\"put\",\"patch\",\"delete\"];const validMutationMethods=new Set(validMutationMethodsArr);const validRequestMethodsArr=[\"get\",...validMutationMethodsArr];const validRequestMethods=new Set(validRequestMethodsArr);const redirectStatusCodes=new Set([301,302,303,307,308]);const redirectPreserveMethodStatusCodes=new Set([307,308]);const IDLE_NAVIGATION={state:\"idle\",location:undefined,formMethod:undefined,formAction:undefined,formEncType:undefined,formData:undefined,json:undefined,text:undefined};const IDLE_FETCHER={state:\"idle\",data:undefined,formMethod:undefined,formAction:undefined,formEncType:undefined,formData:undefined,json:undefined,text:undefined};const IDLE_BLOCKER={state:\"unblocked\",proceed:undefined,reset:undefined,location:undefined};const ABSOLUTE_URL_REGEX=/^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;const defaultMapRouteProperties=route=>({hasErrorBoundary:Boolean(route.hasErrorBoundary)});//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createRouter\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Create a router and listen to history POP navigations\n */function createRouter(init){const routerWindow=init.window?init.window:typeof window!==\"undefined\"?window:undefined;const isBrowser=typeof routerWindow!==\"undefined\"&&typeof routerWindow.document!==\"undefined\"&&typeof routerWindow.document.createElement!==\"undefined\";const isServer=!isBrowser;invariant(init.routes.length>0,\"You must provide a non-empty routes array to createRouter\");let mapRouteProperties;if(init.mapRouteProperties){mapRouteProperties=init.mapRouteProperties;}else if(init.detectErrorBoundary){// If they are still using the deprecated version, wrap it with the new API\nlet detectErrorBoundary=init.detectErrorBoundary;mapRouteProperties=route=>({hasErrorBoundary:detectErrorBoundary(route)});}else{mapRouteProperties=defaultMapRouteProperties;}// Routes keyed by ID\nlet manifest={};// Routes in tree format for matching\nlet dataRoutes=convertRoutesToDataRoutes(init.routes,mapRouteProperties,undefined,manifest);let inFlightDataRoutes;let basename=init.basename||\"/\";// Config driven behavior flags\nlet future=_extends({v7_normalizeFormMethod:false,v7_prependBasename:false},init.future);// Cleanup function for history\nlet unlistenHistory=null;// Externally-provided functions to call on all state changes\nlet subscribers=new Set();// Externally-provided object to hold scroll restoration locations during routing\nlet savedScrollPositions=null;// Externally-provided function to get scroll restoration keys\nlet getScrollRestorationKey=null;// Externally-provided function to get current scroll position\nlet getScrollPosition=null;// One-time flag to control the initial hydration scroll restoration.  Because\n// we don't get the saved positions from <ScrollRestoration /> until _after_\n// the initial render, we need to manually trigger a separate updateState to\n// send along the restoreScrollPosition\n// Set to true if we have `hydrationData` since we assume we were SSR'd and that\n// SSR did the initial scroll restoration.\nlet initialScrollRestored=init.hydrationData!=null;let initialMatches=matchRoutes(dataRoutes,init.history.location,basename);let initialErrors=null;if(initialMatches==null){// If we do not match a user-provided-route, fall back to the root\n// to allow the error boundary to take over\nlet error=getInternalRouterError(404,{pathname:init.history.location.pathname});let{matches,route}=getShortCircuitMatches(dataRoutes);initialMatches=matches;initialErrors={[route.id]:error};}let initialized=// All initialMatches need to be loaded before we're ready.  If we have lazy\n// functions around still then we'll need to run them in initialize()\n!initialMatches.some(m=>m.route.lazy)&&(// And we have to either have no loaders or have been provided hydrationData\n!initialMatches.some(m=>m.route.loader)||init.hydrationData!=null);let router;let state={historyAction:init.history.action,location:init.history.location,matches:initialMatches,initialized,navigation:IDLE_NAVIGATION,// Don't restore on initial updateState() if we were SSR'd\nrestoreScrollPosition:init.hydrationData!=null?false:null,preventScrollReset:false,revalidation:\"idle\",loaderData:init.hydrationData&&init.hydrationData.loaderData||{},actionData:init.hydrationData&&init.hydrationData.actionData||null,errors:init.hydrationData&&init.hydrationData.errors||initialErrors,fetchers:new Map(),blockers:new Map()};// -- Stateful internal variables to manage navigations --\n// Current navigation in progress (to be committed in completeNavigation)\nlet pendingAction=Action.Pop;// Should the current navigation prevent the scroll reset if scroll cannot\n// be restored?\nlet pendingPreventScrollReset=false;// AbortController for the active navigation\nlet pendingNavigationController;// We use this to avoid touching history in completeNavigation if a\n// revalidation is entirely uninterrupted\nlet isUninterruptedRevalidation=false;// Use this internal flag to force revalidation of all loaders:\n//  - submissions (completed or interrupted)\n//  - useRevalidator()\n//  - X-Remix-Revalidate (from redirect)\nlet isRevalidationRequired=false;// Use this internal array to capture routes that require revalidation due\n// to a cancelled deferred on action submission\nlet cancelledDeferredRoutes=[];// Use this internal array to capture fetcher loads that were cancelled by an\n// action navigation and require revalidation\nlet cancelledFetcherLoads=[];// AbortControllers for any in-flight fetchers\nlet fetchControllers=new Map();// Track loads based on the order in which they started\nlet incrementingLoadId=0;// Track the outstanding pending navigation data load to be compared against\n// the globally incrementing load when a fetcher load lands after a completed\n// navigation\nlet pendingNavigationLoadId=-1;// Fetchers that triggered data reloads as a result of their actions\nlet fetchReloadIds=new Map();// Fetchers that triggered redirect navigations\nlet fetchRedirectIds=new Set();// Most recent href/match for fetcher.load calls for fetchers\nlet fetchLoadMatches=new Map();// Store DeferredData instances for active route matches.  When a\n// route loader returns defer() we stick one in here.  Then, when a nested\n// promise resolves we update loaderData.  If a new navigation starts we\n// cancel active deferreds for eliminated routes.\nlet activeDeferreds=new Map();// Store blocker functions in a separate Map outside of router state since\n// we don't need to update UI state if they change\nlet blockerFunctions=new Map();// Flag to ignore the next history update, so we can revert the URL change on\n// a POP navigation that was blocked by the user without touching router state\nlet ignoreNextHistoryUpdate=false;// Initialize the router, all side effects should be kicked off from here.\n// Implemented as a Fluent API for ease of:\n//   let router = createRouter(init).initialize();\nfunction initialize(){// If history informs us of a POP navigation, start the navigation but do not update\n// state.  We'll update our own state once the navigation completes\nunlistenHistory=init.history.listen(_ref=>{let{action:historyAction,location,delta}=_ref;// Ignore this event if it was just us resetting the URL from a\n// blocked POP navigation\nif(ignoreNextHistoryUpdate){ignoreNextHistoryUpdate=false;return;}warning(blockerFunctions.size===0||delta!=null,\"You are trying to use a blocker on a POP navigation to a location \"+\"that was not created by @remix-run/router. This will fail silently in \"+\"production. This can happen if you are navigating outside the router \"+\"via `window.history.pushState`/`window.location.hash` instead of using \"+\"router navigation APIs.  This can also happen if you are using \"+\"createHashRouter and the user manually changes the URL.\");let blockerKey=shouldBlockNavigation({currentLocation:state.location,nextLocation:location,historyAction});if(blockerKey&&delta!=null){// Restore the URL to match the current UI, but don't update router state\nignoreNextHistoryUpdate=true;init.history.go(delta*-1);// Put the blocker into a blocked state\nupdateBlocker(blockerKey,{state:\"blocked\",location,proceed(){updateBlocker(blockerKey,{state:\"proceeding\",proceed:undefined,reset:undefined,location});// Re-do the same POP navigation we just blocked\ninit.history.go(delta);},reset(){let blockers=new Map(state.blockers);blockers.set(blockerKey,IDLE_BLOCKER);updateState({blockers});}});return;}return startNavigation(historyAction,location);});// Kick off initial data load if needed.  Use Pop to avoid modifying history\n// Note we don't do any handling of lazy here.  For SPA's it'll get handled\n// in the normal navigation flow.  For SSR it's expected that lazy modules are\n// resolved prior to router creation since we can't go into a fallbackElement\n// UI for SSR'd apps\nif(!state.initialized){startNavigation(Action.Pop,state.location);}return router;}// Clean up a router and it's side effects\nfunction dispose(){if(unlistenHistory){unlistenHistory();}subscribers.clear();pendingNavigationController&&pendingNavigationController.abort();state.fetchers.forEach((_,key)=>deleteFetcher(key));state.blockers.forEach((_,key)=>deleteBlocker(key));}// Subscribe to state updates for the router\nfunction subscribe(fn){subscribers.add(fn);return()=>subscribers.delete(fn);}// Update our state and notify the calling context of the change\nfunction updateState(newState){state=_extends({},state,newState);subscribers.forEach(subscriber=>subscriber(state));}// Complete a navigation returning the state.navigation back to the IDLE_NAVIGATION\n// and setting state.[historyAction/location/matches] to the new route.\n// - Location is a required param\n// - Navigation will always be set to IDLE_NAVIGATION\n// - Can pass any other state in newState\nfunction completeNavigation(location,newState){var _location$state,_location$state2;// Deduce if we're in a loading/actionReload state:\n// - We have committed actionData in the store\n// - The current navigation was a mutation submission\n// - We're past the submitting state and into the loading state\n// - The location being loaded is not the result of a redirect\nlet isActionReload=state.actionData!=null&&state.navigation.formMethod!=null&&isMutationMethod(state.navigation.formMethod)&&state.navigation.state===\"loading\"&&((_location$state=location.state)==null?void 0:_location$state._isRedirect)!==true;let actionData;if(newState.actionData){if(Object.keys(newState.actionData).length>0){actionData=newState.actionData;}else{// Empty actionData -> clear prior actionData due to an action error\nactionData=null;}}else if(isActionReload){// Keep the current data if we're wrapping up the action reload\nactionData=state.actionData;}else{// Clear actionData on any other completed navigations\nactionData=null;}// Always preserve any existing loaderData from re-used routes\nlet loaderData=newState.loaderData?mergeLoaderData(state.loaderData,newState.loaderData,newState.matches||[],newState.errors):state.loaderData;// On a successful navigation we can assume we got through all blockers\n// so we can start fresh\nlet blockers=state.blockers;if(blockers.size>0){blockers=new Map(blockers);blockers.forEach((_,k)=>blockers.set(k,IDLE_BLOCKER));}// Always respect the user flag.  Otherwise don't reset on mutation\n// submission navigations unless they redirect\nlet preventScrollReset=pendingPreventScrollReset===true||state.navigation.formMethod!=null&&isMutationMethod(state.navigation.formMethod)&&((_location$state2=location.state)==null?void 0:_location$state2._isRedirect)!==true;if(inFlightDataRoutes){dataRoutes=inFlightDataRoutes;inFlightDataRoutes=undefined;}if(isUninterruptedRevalidation);else if(pendingAction===Action.Pop);else if(pendingAction===Action.Push){init.history.push(location,location.state);}else if(pendingAction===Action.Replace){init.history.replace(location,location.state);}updateState(_extends({},newState,{actionData,loaderData,historyAction:pendingAction,location,initialized:true,navigation:IDLE_NAVIGATION,revalidation:\"idle\",restoreScrollPosition:getSavedScrollPosition(location,newState.matches||state.matches),preventScrollReset,blockers}));// Reset stateful navigation vars\npendingAction=Action.Pop;pendingPreventScrollReset=false;isUninterruptedRevalidation=false;isRevalidationRequired=false;cancelledDeferredRoutes=[];cancelledFetcherLoads=[];}// Trigger a navigation event, which can either be a numerical POP or a PUSH\n// replace with an optional submission\nasync function navigate(to,opts){if(typeof to===\"number\"){init.history.go(to);return;}let normalizedPath=normalizeTo(state.location,state.matches,basename,future.v7_prependBasename,to,opts==null?void 0:opts.fromRouteId,opts==null?void 0:opts.relative);let{path,submission,error}=normalizeNavigateOptions(future.v7_normalizeFormMethod,false,normalizedPath,opts);let currentLocation=state.location;let nextLocation=createLocation(state.location,path,opts&&opts.state);// When using navigate as a PUSH/REPLACE we aren't reading an already-encoded\n// URL from window.location, so we need to encode it here so the behavior\n// remains the same as POP and non-data-router usages.  new URL() does all\n// the same encoding we'd get from a history.pushState/window.location read\n// without having to touch history\nnextLocation=_extends({},nextLocation,init.history.encodeLocation(nextLocation));let userReplace=opts&&opts.replace!=null?opts.replace:undefined;let historyAction=Action.Push;if(userReplace===true){historyAction=Action.Replace;}else if(userReplace===false);else if(submission!=null&&isMutationMethod(submission.formMethod)&&submission.formAction===state.location.pathname+state.location.search){// By default on submissions to the current location we REPLACE so that\n// users don't have to double-click the back button to get to the prior\n// location.  If the user redirects to a different location from the\n// action/loader this will be ignored and the redirect will be a PUSH\nhistoryAction=Action.Replace;}let preventScrollReset=opts&&\"preventScrollReset\"in opts?opts.preventScrollReset===true:undefined;let blockerKey=shouldBlockNavigation({currentLocation,nextLocation,historyAction});if(blockerKey){// Put the blocker into a blocked state\nupdateBlocker(blockerKey,{state:\"blocked\",location:nextLocation,proceed(){updateBlocker(blockerKey,{state:\"proceeding\",proceed:undefined,reset:undefined,location:nextLocation});// Send the same navigation through\nnavigate(to,opts);},reset(){let blockers=new Map(state.blockers);blockers.set(blockerKey,IDLE_BLOCKER);updateState({blockers});}});return;}return await startNavigation(historyAction,nextLocation,{submission,// Send through the formData serialization error if we have one so we can\n// render at the right error boundary after we match routes\npendingError:error,preventScrollReset,replace:opts&&opts.replace});}// Revalidate all current loaders.  If a navigation is in progress or if this\n// is interrupted by a navigation, allow this to \"succeed\" by calling all\n// loaders during the next loader round\nfunction revalidate(){interruptActiveLoads();updateState({revalidation:\"loading\"});// If we're currently submitting an action, we don't need to start a new\n// navigation, we'll just let the follow up loader execution call all loaders\nif(state.navigation.state===\"submitting\"){return;}// If we're currently in an idle state, start a new navigation for the current\n// action/location and mark it as uninterrupted, which will skip the history\n// update in completeNavigation\nif(state.navigation.state===\"idle\"){startNavigation(state.historyAction,state.location,{startUninterruptedRevalidation:true});return;}// Otherwise, if we're currently in a loading state, just start a new\n// navigation to the navigation.location but do not trigger an uninterrupted\n// revalidation so that history correctly updates once the navigation completes\nstartNavigation(pendingAction||state.historyAction,state.navigation.location,{overrideNavigation:state.navigation});}// Start a navigation to the given action/location.  Can optionally provide a\n// overrideNavigation which will override the normalLoad in the case of a redirect\n// navigation\nasync function startNavigation(historyAction,location,opts){// Abort any in-progress navigations and start a new one. Unset any ongoing\n// uninterrupted revalidations unless told otherwise, since we want this\n// new navigation to update history normally\npendingNavigationController&&pendingNavigationController.abort();pendingNavigationController=null;pendingAction=historyAction;isUninterruptedRevalidation=(opts&&opts.startUninterruptedRevalidation)===true;// Save the current scroll position every time we start a new navigation,\n// and track whether we should reset scroll on completion\nsaveScrollPosition(state.location,state.matches);pendingPreventScrollReset=(opts&&opts.preventScrollReset)===true;let routesToUse=inFlightDataRoutes||dataRoutes;let loadingNavigation=opts&&opts.overrideNavigation;let matches=matchRoutes(routesToUse,location,basename);// Short circuit with a 404 on the root error boundary if we match nothing\nif(!matches){let error=getInternalRouterError(404,{pathname:location.pathname});let{matches:notFoundMatches,route}=getShortCircuitMatches(routesToUse);// Cancel all pending deferred on 404s since we don't keep any routes\ncancelActiveDeferreds();completeNavigation(location,{matches:notFoundMatches,loaderData:{},errors:{[route.id]:error}});return;}// Short circuit if it's only a hash change and not a revalidation or\n// mutation submission.\n//\n// Ignore on initial page loads because since the initial load will always\n// be \"same hash\".  For example, on /page#hash and submit a <Form method=\"post\">\n// which will default to a navigation to /page\nif(state.initialized&&!isRevalidationRequired&&isHashChangeOnly(state.location,location)&&!(opts&&opts.submission&&isMutationMethod(opts.submission.formMethod))){completeNavigation(location,{matches});return;}// Create a controller/Request for this navigation\npendingNavigationController=new AbortController();let request=createClientSideRequest(init.history,location,pendingNavigationController.signal,opts&&opts.submission);let pendingActionData;let pendingError;if(opts&&opts.pendingError){// If we have a pendingError, it means the user attempted a GET submission\n// with binary FormData so assign here and skip to handleLoaders.  That\n// way we handle calling loaders above the boundary etc.  It's not really\n// different from an actionError in that sense.\npendingError={[findNearestBoundary(matches).route.id]:opts.pendingError};}else if(opts&&opts.submission&&isMutationMethod(opts.submission.formMethod)){// Call action if we received an action submission\nlet actionOutput=await handleAction(request,location,opts.submission,matches,{replace:opts.replace});if(actionOutput.shortCircuited){return;}pendingActionData=actionOutput.pendingActionData;pendingError=actionOutput.pendingActionError;loadingNavigation=getLoadingNavigation(location,opts.submission);// Create a GET request for the loaders\nrequest=new Request(request.url,{signal:request.signal});}// Call loaders\nlet{shortCircuited,loaderData,errors}=await handleLoaders(request,location,matches,loadingNavigation,opts&&opts.submission,opts&&opts.fetcherSubmission,opts&&opts.replace,pendingActionData,pendingError);if(shortCircuited){return;}// Clean up now that the action/loaders have completed.  Don't clean up if\n// we short circuited because pendingNavigationController will have already\n// been assigned to a new controller for the next navigation\npendingNavigationController=null;completeNavigation(location,_extends({matches},pendingActionData?{actionData:pendingActionData}:{},{loaderData,errors}));}// Call the action matched by the leaf route for this navigation and handle\n// redirects/errors\nasync function handleAction(request,location,submission,matches,opts){if(opts===void 0){opts={};}interruptActiveLoads();// Put us in a submitting state\nlet navigation=getSubmittingNavigation(location,submission);updateState({navigation});// Call our action and get the result\nlet result;let actionMatch=getTargetMatch(matches,location);if(!actionMatch.route.action&&!actionMatch.route.lazy){result={type:ResultType.error,error:getInternalRouterError(405,{method:request.method,pathname:location.pathname,routeId:actionMatch.route.id})};}else{result=await callLoaderOrAction(\"action\",request,actionMatch,matches,manifest,mapRouteProperties,basename);if(request.signal.aborted){return{shortCircuited:true};}}if(isRedirectResult(result)){let replace;if(opts&&opts.replace!=null){replace=opts.replace;}else{// If the user didn't explicity indicate replace behavior, replace if\n// we redirected to the exact same location we're currently at to avoid\n// double back-buttons\nreplace=result.location===state.location.pathname+state.location.search;}await startRedirectNavigation(state,result,{submission,replace});return{shortCircuited:true};}if(isErrorResult(result)){// Store off the pending error - we use it to determine which loaders\n// to call and will commit it when we complete the navigation\nlet boundaryMatch=findNearestBoundary(matches,actionMatch.route.id);// By default, all submissions are REPLACE navigations, but if the\n// action threw an error that'll be rendered in an errorElement, we fall\n// back to PUSH so that the user can use the back button to get back to\n// the pre-submission form location to try again\nif((opts&&opts.replace)!==true){pendingAction=Action.Push;}return{// Send back an empty object we can use to clear out any prior actionData\npendingActionData:{},pendingActionError:{[boundaryMatch.route.id]:result.error}};}if(isDeferredResult(result)){throw getInternalRouterError(400,{type:\"defer-action\"});}return{pendingActionData:{[actionMatch.route.id]:result.data}};}// Call all applicable loaders for the given matches, handling redirects,\n// errors, etc.\nasync function handleLoaders(request,location,matches,overrideNavigation,submission,fetcherSubmission,replace,pendingActionData,pendingError){// Figure out the right navigation we want to use for data loading\nlet loadingNavigation=overrideNavigation||getLoadingNavigation(location,submission);// If this was a redirect from an action we don't have a \"submission\" but\n// we have it on the loading navigation so use that if available\nlet activeSubmission=submission||fetcherSubmission||getSubmissionFromNavigation(loadingNavigation);let routesToUse=inFlightDataRoutes||dataRoutes;let[matchesToLoad,revalidatingFetchers]=getMatchesToLoad(init.history,state,matches,activeSubmission,location,isRevalidationRequired,cancelledDeferredRoutes,cancelledFetcherLoads,fetchLoadMatches,fetchRedirectIds,routesToUse,basename,pendingActionData,pendingError);// Cancel pending deferreds for no-longer-matched routes or routes we're\n// about to reload.  Note that if this is an action reload we would have\n// already cancelled all pending deferreds so this would be a no-op\ncancelActiveDeferreds(routeId=>!(matches&&matches.some(m=>m.route.id===routeId))||matchesToLoad&&matchesToLoad.some(m=>m.route.id===routeId));pendingNavigationLoadId=++incrementingLoadId;// Short circuit if we have no loaders to run\nif(matchesToLoad.length===0&&revalidatingFetchers.length===0){let updatedFetchers=markFetchRedirectsDone();completeNavigation(location,_extends({matches,loaderData:{},// Commit pending error if we're short circuiting\nerrors:pendingError||null},pendingActionData?{actionData:pendingActionData}:{},updatedFetchers?{fetchers:new Map(state.fetchers)}:{}));return{shortCircuited:true};}// If this is an uninterrupted revalidation, we remain in our current idle\n// state.  If not, we need to switch to our loading state and load data,\n// preserving any new action data or existing action data (in the case of\n// a revalidation interrupting an actionReload)\nif(!isUninterruptedRevalidation){revalidatingFetchers.forEach(rf=>{let fetcher=state.fetchers.get(rf.key);let revalidatingFetcher=getLoadingFetcher(undefined,fetcher?fetcher.data:undefined);state.fetchers.set(rf.key,revalidatingFetcher);});let actionData=pendingActionData||state.actionData;updateState(_extends({navigation:loadingNavigation},actionData?Object.keys(actionData).length===0?{actionData:null}:{actionData}:{},revalidatingFetchers.length>0?{fetchers:new Map(state.fetchers)}:{}));}revalidatingFetchers.forEach(rf=>{if(fetchControllers.has(rf.key)){abortFetcher(rf.key);}if(rf.controller){// Fetchers use an independent AbortController so that aborting a fetcher\n// (via deleteFetcher) does not abort the triggering navigation that\n// triggered the revalidation\nfetchControllers.set(rf.key,rf.controller);}});// Proxy navigation abort through to revalidation fetchers\nlet abortPendingFetchRevalidations=()=>revalidatingFetchers.forEach(f=>abortFetcher(f.key));if(pendingNavigationController){pendingNavigationController.signal.addEventListener(\"abort\",abortPendingFetchRevalidations);}let{results,loaderResults,fetcherResults}=await callLoadersAndMaybeResolveData(state.matches,matches,matchesToLoad,revalidatingFetchers,request);if(request.signal.aborted){return{shortCircuited:true};}// Clean up _after_ loaders have completed.  Don't clean up if we short\n// circuited because fetchControllers would have been aborted and\n// reassigned to new controllers for the next navigation\nif(pendingNavigationController){pendingNavigationController.signal.removeEventListener(\"abort\",abortPendingFetchRevalidations);}revalidatingFetchers.forEach(rf=>fetchControllers.delete(rf.key));// If any loaders returned a redirect Response, start a new REPLACE navigation\nlet redirect=findRedirect(results);if(redirect){if(redirect.idx>=matchesToLoad.length){// If this redirect came from a fetcher make sure we mark it in\n// fetchRedirectIds so it doesn't get revalidated on the next set of\n// loader executions\nlet fetcherKey=revalidatingFetchers[redirect.idx-matchesToLoad.length].key;fetchRedirectIds.add(fetcherKey);}await startRedirectNavigation(state,redirect.result,{replace});return{shortCircuited:true};}// Process and commit output from loaders\nlet{loaderData,errors}=processLoaderData(state,matches,matchesToLoad,loaderResults,pendingError,revalidatingFetchers,fetcherResults,activeDeferreds);// Wire up subscribers to update loaderData as promises settle\nactiveDeferreds.forEach((deferredData,routeId)=>{deferredData.subscribe(aborted=>{// Note: No need to updateState here since the TrackedPromise on\n// loaderData is stable across resolve/reject\n// Remove this instance if we were aborted or if promises have settled\nif(aborted||deferredData.done){activeDeferreds.delete(routeId);}});});let updatedFetchers=markFetchRedirectsDone();let didAbortFetchLoads=abortStaleFetchLoads(pendingNavigationLoadId);let shouldUpdateFetchers=updatedFetchers||didAbortFetchLoads||revalidatingFetchers.length>0;return _extends({loaderData,errors},shouldUpdateFetchers?{fetchers:new Map(state.fetchers)}:{});}function getFetcher(key){return state.fetchers.get(key)||IDLE_FETCHER;}// Trigger a fetcher load/submit for the given fetcher key\nfunction fetch(key,routeId,href,opts){if(isServer){throw new Error(\"router.fetch() was called during the server render, but it shouldn't be. \"+\"You are likely calling a useFetcher() method in the body of your component. \"+\"Try moving it to a useEffect or a callback.\");}if(fetchControllers.has(key))abortFetcher(key);let routesToUse=inFlightDataRoutes||dataRoutes;let normalizedPath=normalizeTo(state.location,state.matches,basename,future.v7_prependBasename,href,routeId,opts==null?void 0:opts.relative);let matches=matchRoutes(routesToUse,normalizedPath,basename);if(!matches){setFetcherError(key,routeId,getInternalRouterError(404,{pathname:normalizedPath}));return;}let{path,submission,error}=normalizeNavigateOptions(future.v7_normalizeFormMethod,true,normalizedPath,opts);if(error){setFetcherError(key,routeId,error);return;}let match=getTargetMatch(matches,path);pendingPreventScrollReset=(opts&&opts.preventScrollReset)===true;if(submission&&isMutationMethod(submission.formMethod)){handleFetcherAction(key,routeId,path,match,matches,submission);return;}// Store off the match so we can call it's shouldRevalidate on subsequent\n// revalidations\nfetchLoadMatches.set(key,{routeId,path});handleFetcherLoader(key,routeId,path,match,matches,submission);}// Call the action for the matched fetcher.submit(), and then handle redirects,\n// errors, and revalidation\nasync function handleFetcherAction(key,routeId,path,match,requestMatches,submission){interruptActiveLoads();fetchLoadMatches.delete(key);if(!match.route.action&&!match.route.lazy){let error=getInternalRouterError(405,{method:submission.formMethod,pathname:path,routeId:routeId});setFetcherError(key,routeId,error);return;}// Put this fetcher into it's submitting state\nlet existingFetcher=state.fetchers.get(key);let fetcher=getSubmittingFetcher(submission,existingFetcher);state.fetchers.set(key,fetcher);updateState({fetchers:new Map(state.fetchers)});// Call the action for the fetcher\nlet abortController=new AbortController();let fetchRequest=createClientSideRequest(init.history,path,abortController.signal,submission);fetchControllers.set(key,abortController);let originatingLoadId=incrementingLoadId;let actionResult=await callLoaderOrAction(\"action\",fetchRequest,match,requestMatches,manifest,mapRouteProperties,basename);if(fetchRequest.signal.aborted){// We can delete this so long as we weren't aborted by ou our own fetcher\n// re-submit which would have put _new_ controller is in fetchControllers\nif(fetchControllers.get(key)===abortController){fetchControllers.delete(key);}return;}if(isRedirectResult(actionResult)){fetchControllers.delete(key);if(pendingNavigationLoadId>originatingLoadId){// A new navigation was kicked off after our action started, so that\n// should take precedence over this redirect navigation.  We already\n// set isRevalidationRequired so all loaders for the new route should\n// fire unless opted out via shouldRevalidate\nlet doneFetcher=getDoneFetcher(undefined);state.fetchers.set(key,doneFetcher);updateState({fetchers:new Map(state.fetchers)});return;}else{fetchRedirectIds.add(key);let loadingFetcher=getLoadingFetcher(submission);state.fetchers.set(key,loadingFetcher);updateState({fetchers:new Map(state.fetchers)});return startRedirectNavigation(state,actionResult,{submission,isFetchActionRedirect:true});}}// Process any non-redirect errors thrown\nif(isErrorResult(actionResult)){setFetcherError(key,routeId,actionResult.error);return;}if(isDeferredResult(actionResult)){throw getInternalRouterError(400,{type:\"defer-action\"});}// Start the data load for current matches, or the next location if we're\n// in the middle of a navigation\nlet nextLocation=state.navigation.location||state.location;let revalidationRequest=createClientSideRequest(init.history,nextLocation,abortController.signal);let routesToUse=inFlightDataRoutes||dataRoutes;let matches=state.navigation.state!==\"idle\"?matchRoutes(routesToUse,state.navigation.location,basename):state.matches;invariant(matches,\"Didn't find any matches after fetcher action\");let loadId=++incrementingLoadId;fetchReloadIds.set(key,loadId);let loadFetcher=getLoadingFetcher(submission,actionResult.data);state.fetchers.set(key,loadFetcher);let[matchesToLoad,revalidatingFetchers]=getMatchesToLoad(init.history,state,matches,submission,nextLocation,isRevalidationRequired,cancelledDeferredRoutes,cancelledFetcherLoads,fetchLoadMatches,fetchRedirectIds,routesToUse,basename,{[match.route.id]:actionResult.data},undefined// No need to send through errors since we short circuit above\n);// Put all revalidating fetchers into the loading state, except for the\n// current fetcher which we want to keep in it's current loading state which\n// contains it's action submission info + action data\nrevalidatingFetchers.filter(rf=>rf.key!==key).forEach(rf=>{let staleKey=rf.key;let existingFetcher=state.fetchers.get(staleKey);let revalidatingFetcher=getLoadingFetcher(undefined,existingFetcher?existingFetcher.data:undefined);state.fetchers.set(staleKey,revalidatingFetcher);if(fetchControllers.has(staleKey)){abortFetcher(staleKey);}if(rf.controller){fetchControllers.set(staleKey,rf.controller);}});updateState({fetchers:new Map(state.fetchers)});let abortPendingFetchRevalidations=()=>revalidatingFetchers.forEach(rf=>abortFetcher(rf.key));abortController.signal.addEventListener(\"abort\",abortPendingFetchRevalidations);let{results,loaderResults,fetcherResults}=await callLoadersAndMaybeResolveData(state.matches,matches,matchesToLoad,revalidatingFetchers,revalidationRequest);if(abortController.signal.aborted){return;}abortController.signal.removeEventListener(\"abort\",abortPendingFetchRevalidations);fetchReloadIds.delete(key);fetchControllers.delete(key);revalidatingFetchers.forEach(r=>fetchControllers.delete(r.key));let redirect=findRedirect(results);if(redirect){if(redirect.idx>=matchesToLoad.length){// If this redirect came from a fetcher make sure we mark it in\n// fetchRedirectIds so it doesn't get revalidated on the next set of\n// loader executions\nlet fetcherKey=revalidatingFetchers[redirect.idx-matchesToLoad.length].key;fetchRedirectIds.add(fetcherKey);}return startRedirectNavigation(state,redirect.result);}// Process and commit output from loaders\nlet{loaderData,errors}=processLoaderData(state,state.matches,matchesToLoad,loaderResults,undefined,revalidatingFetchers,fetcherResults,activeDeferreds);// Since we let revalidations complete even if the submitting fetcher was\n// deleted, only put it back to idle if it hasn't been deleted\nif(state.fetchers.has(key)){let doneFetcher=getDoneFetcher(actionResult.data);state.fetchers.set(key,doneFetcher);}let didAbortFetchLoads=abortStaleFetchLoads(loadId);// If we are currently in a navigation loading state and this fetcher is\n// more recent than the navigation, we want the newer data so abort the\n// navigation and complete it with the fetcher data\nif(state.navigation.state===\"loading\"&&loadId>pendingNavigationLoadId){invariant(pendingAction,\"Expected pending action\");pendingNavigationController&&pendingNavigationController.abort();completeNavigation(state.navigation.location,{matches,loaderData,errors,fetchers:new Map(state.fetchers)});}else{// otherwise just update with the fetcher data, preserving any existing\n// loaderData for loaders that did not need to reload.  We have to\n// manually merge here since we aren't going through completeNavigation\nupdateState(_extends({errors,loaderData:mergeLoaderData(state.loaderData,loaderData,matches,errors)},didAbortFetchLoads||revalidatingFetchers.length>0?{fetchers:new Map(state.fetchers)}:{}));isRevalidationRequired=false;}}// Call the matched loader for fetcher.load(), handling redirects, errors, etc.\nasync function handleFetcherLoader(key,routeId,path,match,matches,submission){let existingFetcher=state.fetchers.get(key);// Put this fetcher into it's loading state\nlet loadingFetcher=getLoadingFetcher(submission,existingFetcher?existingFetcher.data:undefined);state.fetchers.set(key,loadingFetcher);updateState({fetchers:new Map(state.fetchers)});// Call the loader for this fetcher route match\nlet abortController=new AbortController();let fetchRequest=createClientSideRequest(init.history,path,abortController.signal);fetchControllers.set(key,abortController);let originatingLoadId=incrementingLoadId;let result=await callLoaderOrAction(\"loader\",fetchRequest,match,matches,manifest,mapRouteProperties,basename);// Deferred isn't supported for fetcher loads, await everything and treat it\n// as a normal load.  resolveDeferredData will return undefined if this\n// fetcher gets aborted, so we just leave result untouched and short circuit\n// below if that happens\nif(isDeferredResult(result)){result=(await resolveDeferredData(result,fetchRequest.signal,true))||result;}// We can delete this so long as we weren't aborted by our our own fetcher\n// re-load which would have put _new_ controller is in fetchControllers\nif(fetchControllers.get(key)===abortController){fetchControllers.delete(key);}if(fetchRequest.signal.aborted){return;}// If the loader threw a redirect Response, start a new REPLACE navigation\nif(isRedirectResult(result)){if(pendingNavigationLoadId>originatingLoadId){// A new navigation was kicked off after our loader started, so that\n// should take precedence over this redirect navigation\nlet doneFetcher=getDoneFetcher(undefined);state.fetchers.set(key,doneFetcher);updateState({fetchers:new Map(state.fetchers)});return;}else{fetchRedirectIds.add(key);await startRedirectNavigation(state,result);return;}}// Process any non-redirect errors thrown\nif(isErrorResult(result)){let boundaryMatch=findNearestBoundary(state.matches,routeId);state.fetchers.delete(key);// TODO: In remix, this would reset to IDLE_NAVIGATION if it was a catch -\n// do we need to behave any differently with our non-redirect errors?\n// What if it was a non-redirect Response?\nupdateState({fetchers:new Map(state.fetchers),errors:{[boundaryMatch.route.id]:result.error}});return;}invariant(!isDeferredResult(result),\"Unhandled fetcher deferred data\");// Put the fetcher back into an idle state\nlet doneFetcher=getDoneFetcher(result.data);state.fetchers.set(key,doneFetcher);updateState({fetchers:new Map(state.fetchers)});}/**\n   * Utility function to handle redirects returned from an action or loader.\n   * Normally, a redirect \"replaces\" the navigation that triggered it.  So, for\n   * example:\n   *\n   *  - user is on /a\n   *  - user clicks a link to /b\n   *  - loader for /b redirects to /c\n   *\n   * In a non-JS app the browser would track the in-flight navigation to /b and\n   * then replace it with /c when it encountered the redirect response.  In\n   * the end it would only ever update the URL bar with /c.\n   *\n   * In client-side routing using pushState/replaceState, we aim to emulate\n   * this behavior and we also do not update history until the end of the\n   * navigation (including processed redirects).  This means that we never\n   * actually touch history until we've processed redirects, so we just use\n   * the history action from the original navigation (PUSH or REPLACE).\n   */async function startRedirectNavigation(state,redirect,_temp){let{submission,replace,isFetchActionRedirect}=_temp===void 0?{}:_temp;if(redirect.revalidate){isRevalidationRequired=true;}let redirectLocation=createLocation(state.location,redirect.location,// TODO: This can be removed once we get rid of useTransition in Remix v2\n_extends({_isRedirect:true},isFetchActionRedirect?{_isFetchActionRedirect:true}:{}));invariant(redirectLocation,\"Expected a location on the redirect navigation\");if(isBrowser){let isDocumentReload=false;if(redirect.reloadDocument){// Hard reload if the response contained X-Remix-Reload-Document\nisDocumentReload=true;}else if(ABSOLUTE_URL_REGEX.test(redirect.location)){const url=init.history.createURL(redirect.location);isDocumentReload=// Hard reload if it's an absolute URL to a new origin\nurl.origin!==routerWindow.location.origin||// Hard reload if it's an absolute URL that does not match our basename\nstripBasename(url.pathname,basename)==null;}if(isDocumentReload){if(replace){routerWindow.location.replace(redirect.location);}else{routerWindow.location.assign(redirect.location);}return;}}// There's no need to abort on redirects, since we don't detect the\n// redirect until the action/loaders have settled\npendingNavigationController=null;let redirectHistoryAction=replace===true?Action.Replace:Action.Push;// Use the incoming submission if provided, fallback on the active one in\n// state.navigation\nlet activeSubmission=submission||getSubmissionFromNavigation(state.navigation);// If this was a 307/308 submission we want to preserve the HTTP method and\n// re-submit the GET/POST/PUT/PATCH/DELETE as a submission navigation to the\n// redirected location\nif(redirectPreserveMethodStatusCodes.has(redirect.status)&&activeSubmission&&isMutationMethod(activeSubmission.formMethod)){await startNavigation(redirectHistoryAction,redirectLocation,{submission:_extends({},activeSubmission,{formAction:redirect.location}),// Preserve this flag across redirects\npreventScrollReset:pendingPreventScrollReset});}else if(isFetchActionRedirect){// For a fetch action redirect, we kick off a new loading navigation\n// without the fetcher submission, but we send it along for shouldRevalidate\nawait startNavigation(redirectHistoryAction,redirectLocation,{overrideNavigation:getLoadingNavigation(redirectLocation),fetcherSubmission:activeSubmission,// Preserve this flag across redirects\npreventScrollReset:pendingPreventScrollReset});}else{// If we have a submission, we will preserve it through the redirect navigation\nlet overrideNavigation=getLoadingNavigation(redirectLocation,activeSubmission);await startNavigation(redirectHistoryAction,redirectLocation,{overrideNavigation,// Preserve this flag across redirects\npreventScrollReset:pendingPreventScrollReset});}}async function callLoadersAndMaybeResolveData(currentMatches,matches,matchesToLoad,fetchersToLoad,request){// Call all navigation loaders and revalidating fetcher loaders in parallel,\n// then slice off the results into separate arrays so we can handle them\n// accordingly\nlet results=await Promise.all([...matchesToLoad.map(match=>callLoaderOrAction(\"loader\",request,match,matches,manifest,mapRouteProperties,basename)),...fetchersToLoad.map(f=>{if(f.matches&&f.match&&f.controller){return callLoaderOrAction(\"loader\",createClientSideRequest(init.history,f.path,f.controller.signal),f.match,f.matches,manifest,mapRouteProperties,basename);}else{let error={type:ResultType.error,error:getInternalRouterError(404,{pathname:f.path})};return error;}})]);let loaderResults=results.slice(0,matchesToLoad.length);let fetcherResults=results.slice(matchesToLoad.length);await Promise.all([resolveDeferredResults(currentMatches,matchesToLoad,loaderResults,loaderResults.map(()=>request.signal),false,state.loaderData),resolveDeferredResults(currentMatches,fetchersToLoad.map(f=>f.match),fetcherResults,fetchersToLoad.map(f=>f.controller?f.controller.signal:null),true)]);return{results,loaderResults,fetcherResults};}function interruptActiveLoads(){// Every interruption triggers a revalidation\nisRevalidationRequired=true;// Cancel pending route-level deferreds and mark cancelled routes for\n// revalidation\ncancelledDeferredRoutes.push(...cancelActiveDeferreds());// Abort in-flight fetcher loads\nfetchLoadMatches.forEach((_,key)=>{if(fetchControllers.has(key)){cancelledFetcherLoads.push(key);abortFetcher(key);}});}function setFetcherError(key,routeId,error){let boundaryMatch=findNearestBoundary(state.matches,routeId);deleteFetcher(key);updateState({errors:{[boundaryMatch.route.id]:error},fetchers:new Map(state.fetchers)});}function deleteFetcher(key){let fetcher=state.fetchers.get(key);// Don't abort the controller if this is a deletion of a fetcher.submit()\n// in it's loading phase since - we don't want to abort the corresponding\n// revalidation and want them to complete and land\nif(fetchControllers.has(key)&&!(fetcher&&fetcher.state===\"loading\"&&fetchReloadIds.has(key))){abortFetcher(key);}fetchLoadMatches.delete(key);fetchReloadIds.delete(key);fetchRedirectIds.delete(key);state.fetchers.delete(key);}function abortFetcher(key){let controller=fetchControllers.get(key);invariant(controller,\"Expected fetch controller: \"+key);controller.abort();fetchControllers.delete(key);}function markFetchersDone(keys){for(let key of keys){let fetcher=getFetcher(key);let doneFetcher=getDoneFetcher(fetcher.data);state.fetchers.set(key,doneFetcher);}}function markFetchRedirectsDone(){let doneKeys=[];let updatedFetchers=false;for(let key of fetchRedirectIds){let fetcher=state.fetchers.get(key);invariant(fetcher,\"Expected fetcher: \"+key);if(fetcher.state===\"loading\"){fetchRedirectIds.delete(key);doneKeys.push(key);updatedFetchers=true;}}markFetchersDone(doneKeys);return updatedFetchers;}function abortStaleFetchLoads(landedId){let yeetedKeys=[];for(let[key,id]of fetchReloadIds){if(id<landedId){let fetcher=state.fetchers.get(key);invariant(fetcher,\"Expected fetcher: \"+key);if(fetcher.state===\"loading\"){abortFetcher(key);fetchReloadIds.delete(key);yeetedKeys.push(key);}}}markFetchersDone(yeetedKeys);return yeetedKeys.length>0;}function getBlocker(key,fn){let blocker=state.blockers.get(key)||IDLE_BLOCKER;if(blockerFunctions.get(key)!==fn){blockerFunctions.set(key,fn);}return blocker;}function deleteBlocker(key){state.blockers.delete(key);blockerFunctions.delete(key);}// Utility function to update blockers, ensuring valid state transitions\nfunction updateBlocker(key,newBlocker){let blocker=state.blockers.get(key)||IDLE_BLOCKER;// Poor mans state machine :)\n// https://mermaid.live/edit#pako:eNqVkc9OwzAMxl8l8nnjAYrEtDIOHEBIgwvKJTReGy3_lDpIqO27k6awMG0XcrLlnz87nwdonESogKXXBuE79rq75XZO3-yHds0RJVuv70YrPlUrCEe2HfrORS3rubqZfuhtpg5C9wk5tZ4VKcRUq88q9Z8RS0-48cE1iHJkL0ugbHuFLus9L6spZy8nX9MP2CNdomVaposqu3fGayT8T8-jJQwhepo_UtpgBQaDEUom04dZhAN1aJBDlUKJBxE1ceB2Smj0Mln-IBW5AFU2dwUiktt_2Qaq2dBfaKdEup85UV7Yd-dKjlnkabl2Pvr0DTkTreM\ninvariant(blocker.state===\"unblocked\"&&newBlocker.state===\"blocked\"||blocker.state===\"blocked\"&&newBlocker.state===\"blocked\"||blocker.state===\"blocked\"&&newBlocker.state===\"proceeding\"||blocker.state===\"blocked\"&&newBlocker.state===\"unblocked\"||blocker.state===\"proceeding\"&&newBlocker.state===\"unblocked\",\"Invalid blocker state transition: \"+blocker.state+\" -> \"+newBlocker.state);let blockers=new Map(state.blockers);blockers.set(key,newBlocker);updateState({blockers});}function shouldBlockNavigation(_ref2){let{currentLocation,nextLocation,historyAction}=_ref2;if(blockerFunctions.size===0){return;}// We ony support a single active blocker at the moment since we don't have\n// any compelling use cases for multi-blocker yet\nif(blockerFunctions.size>1){warning(false,\"A router only supports one blocker at a time\");}let entries=Array.from(blockerFunctions.entries());let[blockerKey,blockerFunction]=entries[entries.length-1];let blocker=state.blockers.get(blockerKey);if(blocker&&blocker.state===\"proceeding\"){// If the blocker is currently proceeding, we don't need to re-check\n// it and can let this navigation continue\nreturn;}// At this point, we know we're unblocked/blocked so we need to check the\n// user-provided blocker function\nif(blockerFunction({currentLocation,nextLocation,historyAction})){return blockerKey;}}function cancelActiveDeferreds(predicate){let cancelledRouteIds=[];activeDeferreds.forEach((dfd,routeId)=>{if(!predicate||predicate(routeId)){// Cancel the deferred - but do not remove from activeDeferreds here -\n// we rely on the subscribers to do that so our tests can assert proper\n// cleanup via _internalActiveDeferreds\ndfd.cancel();cancelledRouteIds.push(routeId);activeDeferreds.delete(routeId);}});return cancelledRouteIds;}// Opt in to capturing and reporting scroll positions during navigations,\n// used by the <ScrollRestoration> component\nfunction enableScrollRestoration(positions,getPosition,getKey){savedScrollPositions=positions;getScrollPosition=getPosition;getScrollRestorationKey=getKey||null;// Perform initial hydration scroll restoration, since we miss the boat on\n// the initial updateState() because we've not yet rendered <ScrollRestoration/>\n// and therefore have no savedScrollPositions available\nif(!initialScrollRestored&&state.navigation===IDLE_NAVIGATION){initialScrollRestored=true;let y=getSavedScrollPosition(state.location,state.matches);if(y!=null){updateState({restoreScrollPosition:y});}}return()=>{savedScrollPositions=null;getScrollPosition=null;getScrollRestorationKey=null;};}function getScrollKey(location,matches){if(getScrollRestorationKey){let key=getScrollRestorationKey(location,matches.map(m=>createUseMatchesMatch(m,state.loaderData)));return key||location.key;}return location.key;}function saveScrollPosition(location,matches){if(savedScrollPositions&&getScrollPosition){let key=getScrollKey(location,matches);savedScrollPositions[key]=getScrollPosition();}}function getSavedScrollPosition(location,matches){if(savedScrollPositions){let key=getScrollKey(location,matches);let y=savedScrollPositions[key];if(typeof y===\"number\"){return y;}}return null;}function _internalSetRoutes(newRoutes){manifest={};inFlightDataRoutes=convertRoutesToDataRoutes(newRoutes,mapRouteProperties,undefined,manifest);}router={get basename(){return basename;},get state(){return state;},get routes(){return dataRoutes;},initialize,subscribe,enableScrollRestoration,navigate,fetch,revalidate,// Passthrough to history-aware createHref used by useHref so we get proper\n// hash-aware URLs in DOM paths\ncreateHref:to=>init.history.createHref(to),encodeLocation:to=>init.history.encodeLocation(to),getFetcher,deleteFetcher,dispose,getBlocker,deleteBlocker,_internalFetchControllers:fetchControllers,_internalActiveDeferreds:activeDeferreds,// TODO: Remove setRoutes, it's temporary to avoid dealing with\n// updating the tree while validating the update algorithm.\n_internalSetRoutes};return router;}//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region createStaticHandler\n////////////////////////////////////////////////////////////////////////////////\nconst UNSAFE_DEFERRED_SYMBOL=Symbol(\"deferred\");function createStaticHandler(routes,opts){invariant(routes.length>0,\"You must provide a non-empty routes array to createStaticHandler\");let manifest={};let basename=(opts?opts.basename:null)||\"/\";let mapRouteProperties;if(opts!=null&&opts.mapRouteProperties){mapRouteProperties=opts.mapRouteProperties;}else if(opts!=null&&opts.detectErrorBoundary){// If they are still using the deprecated version, wrap it with the new API\nlet detectErrorBoundary=opts.detectErrorBoundary;mapRouteProperties=route=>({hasErrorBoundary:detectErrorBoundary(route)});}else{mapRouteProperties=defaultMapRouteProperties;}let dataRoutes=convertRoutesToDataRoutes(routes,mapRouteProperties,undefined,manifest);/**\n   * The query() method is intended for document requests, in which we want to\n   * call an optional action and potentially multiple loaders for all nested\n   * routes.  It returns a StaticHandlerContext object, which is very similar\n   * to the router state (location, loaderData, actionData, errors, etc.) and\n   * also adds SSR-specific information such as the statusCode and headers\n   * from action/loaders Responses.\n   *\n   * It _should_ never throw and should report all errors through the\n   * returned context.errors object, properly associating errors to their error\n   * boundary.  Additionally, it tracks _deepestRenderedBoundaryId which can be\n   * used to emulate React error boundaries during SSr by performing a second\n   * pass only down to the boundaryId.\n   *\n   * The one exception where we do not return a StaticHandlerContext is when a\n   * redirect response is returned or thrown from any action/loader.  We\n   * propagate that out and return the raw Response so the HTTP server can\n   * return it directly.\n   */async function query(request,_temp2){let{requestContext}=_temp2===void 0?{}:_temp2;let url=new URL(request.url);let method=request.method;let location=createLocation(\"\",createPath(url),null,\"default\");let matches=matchRoutes(dataRoutes,location,basename);// SSR supports HEAD requests while SPA doesn't\nif(!isValidMethod(method)&&method!==\"HEAD\"){let error=getInternalRouterError(405,{method});let{matches:methodNotAllowedMatches,route}=getShortCircuitMatches(dataRoutes);return{basename,location,matches:methodNotAllowedMatches,loaderData:{},actionData:null,errors:{[route.id]:error},statusCode:error.status,loaderHeaders:{},actionHeaders:{},activeDeferreds:null};}else if(!matches){let error=getInternalRouterError(404,{pathname:location.pathname});let{matches:notFoundMatches,route}=getShortCircuitMatches(dataRoutes);return{basename,location,matches:notFoundMatches,loaderData:{},actionData:null,errors:{[route.id]:error},statusCode:error.status,loaderHeaders:{},actionHeaders:{},activeDeferreds:null};}let result=await queryImpl(request,location,matches,requestContext);if(isResponse(result)){return result;}// When returning StaticHandlerContext, we patch back in the location here\n// since we need it for React Context.  But this helps keep our submit and\n// loadRouteData operating on a Request instead of a Location\nreturn _extends({location,basename},result);}/**\n   * The queryRoute() method is intended for targeted route requests, either\n   * for fetch ?_data requests or resource route requests.  In this case, we\n   * are only ever calling a single action or loader, and we are returning the\n   * returned value directly.  In most cases, this will be a Response returned\n   * from the action/loader, but it may be a primitive or other value as well -\n   * and in such cases the calling context should handle that accordingly.\n   *\n   * We do respect the throw/return differentiation, so if an action/loader\n   * throws, then this method will throw the value.  This is important so we\n   * can do proper boundary identification in Remix where a thrown Response\n   * must go to the Catch Boundary but a returned Response is happy-path.\n   *\n   * One thing to note is that any Router-initiated Errors that make sense\n   * to associate with a status code will be thrown as an ErrorResponse\n   * instance which include the raw Error, such that the calling context can\n   * serialize the error as they see fit while including the proper response\n   * code.  Examples here are 404 and 405 errors that occur prior to reaching\n   * any user-defined loaders.\n   */async function queryRoute(request,_temp3){let{routeId,requestContext}=_temp3===void 0?{}:_temp3;let url=new URL(request.url);let method=request.method;let location=createLocation(\"\",createPath(url),null,\"default\");let matches=matchRoutes(dataRoutes,location,basename);// SSR supports HEAD requests while SPA doesn't\nif(!isValidMethod(method)&&method!==\"HEAD\"&&method!==\"OPTIONS\"){throw getInternalRouterError(405,{method});}else if(!matches){throw getInternalRouterError(404,{pathname:location.pathname});}let match=routeId?matches.find(m=>m.route.id===routeId):getTargetMatch(matches,location);if(routeId&&!match){throw getInternalRouterError(403,{pathname:location.pathname,routeId});}else if(!match){// This should never hit I don't think?\nthrow getInternalRouterError(404,{pathname:location.pathname});}let result=await queryImpl(request,location,matches,requestContext,match);if(isResponse(result)){return result;}let error=result.errors?Object.values(result.errors)[0]:undefined;if(error!==undefined){// If we got back result.errors, that means the loader/action threw\n// _something_ that wasn't a Response, but it's not guaranteed/required\n// to be an `instanceof Error` either, so we have to use throw here to\n// preserve the \"error\" state outside of queryImpl.\nthrow error;}// Pick off the right state value to return\nif(result.actionData){return Object.values(result.actionData)[0];}if(result.loaderData){var _result$activeDeferre;let data=Object.values(result.loaderData)[0];if((_result$activeDeferre=result.activeDeferreds)!=null&&_result$activeDeferre[match.route.id]){data[UNSAFE_DEFERRED_SYMBOL]=result.activeDeferreds[match.route.id];}return data;}return undefined;}async function queryImpl(request,location,matches,requestContext,routeMatch){invariant(request.signal,\"query()/queryRoute() requests must contain an AbortController signal\");try{if(isMutationMethod(request.method.toLowerCase())){let result=await submit(request,matches,routeMatch||getTargetMatch(matches,location),requestContext,routeMatch!=null);return result;}let result=await loadRouteData(request,matches,requestContext,routeMatch);return isResponse(result)?result:_extends({},result,{actionData:null,actionHeaders:{}});}catch(e){// If the user threw/returned a Response in callLoaderOrAction, we throw\n// it to bail out and then return or throw here based on whether the user\n// returned or threw\nif(isQueryRouteResponse(e)){if(e.type===ResultType.error){throw e.response;}return e.response;}// Redirects are always returned since they don't propagate to catch\n// boundaries\nif(isRedirectResponse(e)){return e;}throw e;}}async function submit(request,matches,actionMatch,requestContext,isRouteRequest){let result;if(!actionMatch.route.action&&!actionMatch.route.lazy){let error=getInternalRouterError(405,{method:request.method,pathname:new URL(request.url).pathname,routeId:actionMatch.route.id});if(isRouteRequest){throw error;}result={type:ResultType.error,error};}else{result=await callLoaderOrAction(\"action\",request,actionMatch,matches,manifest,mapRouteProperties,basename,{isStaticRequest:true,isRouteRequest,requestContext});if(request.signal.aborted){let method=isRouteRequest?\"queryRoute\":\"query\";throw new Error(method+\"() call aborted\");}}if(isRedirectResult(result)){// Uhhhh - this should never happen, we should always throw these from\n// callLoaderOrAction, but the type narrowing here keeps TS happy and we\n// can get back on the \"throw all redirect responses\" train here should\n// this ever happen :/\nthrow new Response(null,{status:result.status,headers:{Location:result.location}});}if(isDeferredResult(result)){let error=getInternalRouterError(400,{type:\"defer-action\"});if(isRouteRequest){throw error;}result={type:ResultType.error,error};}if(isRouteRequest){// Note: This should only be non-Response values if we get here, since\n// isRouteRequest should throw any Response received in callLoaderOrAction\nif(isErrorResult(result)){throw result.error;}return{matches:[actionMatch],loaderData:{},actionData:{[actionMatch.route.id]:result.data},errors:null,// Note: statusCode + headers are unused here since queryRoute will\n// return the raw Response or value\nstatusCode:200,loaderHeaders:{},actionHeaders:{},activeDeferreds:null};}if(isErrorResult(result)){// Store off the pending error - we use it to determine which loaders\n// to call and will commit it when we complete the navigation\nlet boundaryMatch=findNearestBoundary(matches,actionMatch.route.id);let context=await loadRouteData(request,matches,requestContext,undefined,{[boundaryMatch.route.id]:result.error});// action status codes take precedence over loader status codes\nreturn _extends({},context,{statusCode:isRouteErrorResponse(result.error)?result.error.status:500,actionData:null,actionHeaders:_extends({},result.headers?{[actionMatch.route.id]:result.headers}:{})});}// Create a GET request for the loaders\nlet loaderRequest=new Request(request.url,{headers:request.headers,redirect:request.redirect,signal:request.signal});let context=await loadRouteData(loaderRequest,matches,requestContext);return _extends({},context,result.statusCode?{statusCode:result.statusCode}:{},{actionData:{[actionMatch.route.id]:result.data},actionHeaders:_extends({},result.headers?{[actionMatch.route.id]:result.headers}:{})});}async function loadRouteData(request,matches,requestContext,routeMatch,pendingActionError){let isRouteRequest=routeMatch!=null;// Short circuit if we have no loaders to run (queryRoute())\nif(isRouteRequest&&!(routeMatch!=null&&routeMatch.route.loader)&&!(routeMatch!=null&&routeMatch.route.lazy)){throw getInternalRouterError(400,{method:request.method,pathname:new URL(request.url).pathname,routeId:routeMatch==null?void 0:routeMatch.route.id});}let requestMatches=routeMatch?[routeMatch]:getLoaderMatchesUntilBoundary(matches,Object.keys(pendingActionError||{})[0]);let matchesToLoad=requestMatches.filter(m=>m.route.loader||m.route.lazy);// Short circuit if we have no loaders to run (query())\nif(matchesToLoad.length===0){return{matches,// Add a null for all matched routes for proper revalidation on the client\nloaderData:matches.reduce((acc,m)=>Object.assign(acc,{[m.route.id]:null}),{}),errors:pendingActionError||null,statusCode:200,loaderHeaders:{},activeDeferreds:null};}let results=await Promise.all([...matchesToLoad.map(match=>callLoaderOrAction(\"loader\",request,match,matches,manifest,mapRouteProperties,basename,{isStaticRequest:true,isRouteRequest,requestContext}))]);if(request.signal.aborted){let method=isRouteRequest?\"queryRoute\":\"query\";throw new Error(method+\"() call aborted\");}// Process and commit output from loaders\nlet activeDeferreds=new Map();let context=processRouteLoaderData(matches,matchesToLoad,results,pendingActionError,activeDeferreds);// Add a null for any non-loader matches for proper revalidation on the client\nlet executedLoaders=new Set(matchesToLoad.map(match=>match.route.id));matches.forEach(match=>{if(!executedLoaders.has(match.route.id)){context.loaderData[match.route.id]=null;}});return _extends({},context,{matches,activeDeferreds:activeDeferreds.size>0?Object.fromEntries(activeDeferreds.entries()):null});}return{dataRoutes,query,queryRoute};}//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Helpers\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Given an existing StaticHandlerContext and an error thrown at render time,\n * provide an updated StaticHandlerContext suitable for a second SSR render\n */function getStaticContextFromError(routes,context,error){let newContext=_extends({},context,{statusCode:500,errors:{[context._deepestRenderedBoundaryId||routes[0].id]:error}});return newContext;}function isSubmissionNavigation(opts){return opts!=null&&(\"formData\"in opts&&opts.formData!=null||\"body\"in opts&&opts.body!==undefined);}function normalizeTo(location,matches,basename,prependBasename,to,fromRouteId,relative){let contextualMatches;let activeRouteMatch;if(fromRouteId!=null&&relative!==\"path\"){// Grab matches up to the calling route so our route-relative logic is\n// relative to the correct source route.  When using relative:path,\n// fromRouteId is ignored since that is always relative to the current\n// location path\ncontextualMatches=[];for(let match of matches){contextualMatches.push(match);if(match.route.id===fromRouteId){activeRouteMatch=match;break;}}}else{contextualMatches=matches;activeRouteMatch=matches[matches.length-1];}// Resolve the relative path\nlet path=resolveTo(to?to:\".\",getPathContributingMatches(contextualMatches).map(m=>m.pathnameBase),stripBasename(location.pathname,basename)||location.pathname,relative===\"path\");// When `to` is not specified we inherit search/hash from the current\n// location, unlike when to=\".\" and we just inherit the path.\n// See https://github.com/remix-run/remix/issues/927\nif(to==null){path.search=location.search;path.hash=location.hash;}// Add an ?index param for matched index routes if we don't already have one\nif((to==null||to===\"\"||to===\".\")&&activeRouteMatch&&activeRouteMatch.route.index&&!hasNakedIndexQuery(path.search)){path.search=path.search?path.search.replace(/^\\?/,\"?index&\"):\"?index\";}// If we're operating within a basename, prepend it to the pathname.  If\n// this is a root navigation, then just use the raw basename which allows\n// the basename to have full control over the presence of a trailing slash\n// on root actions\nif(prependBasename&&basename!==\"/\"){path.pathname=path.pathname===\"/\"?basename:joinPaths([basename,path.pathname]);}return createPath(path);}// Normalize navigation options by converting formMethod=GET formData objects to\n// URLSearchParams so they behave identically to links with query params\nfunction normalizeNavigateOptions(normalizeFormMethod,isFetcher,path,opts){// Return location verbatim on non-submission navigations\nif(!opts||!isSubmissionNavigation(opts)){return{path};}if(opts.formMethod&&!isValidMethod(opts.formMethod)){return{path,error:getInternalRouterError(405,{method:opts.formMethod})};}let getInvalidBodyError=()=>({path,error:getInternalRouterError(400,{type:\"invalid-body\"})});// Create a Submission on non-GET navigations\nlet rawFormMethod=opts.formMethod||\"get\";let formMethod=normalizeFormMethod?rawFormMethod.toUpperCase():rawFormMethod.toLowerCase();let formAction=stripHashFromPath(path);if(opts.body!==undefined){if(opts.formEncType===\"text/plain\"){// text only support POST/PUT/PATCH/DELETE submissions\nif(!isMutationMethod(formMethod)){return getInvalidBodyError();}let text=typeof opts.body===\"string\"?opts.body:opts.body instanceof FormData||opts.body instanceof URLSearchParams?// https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#plain-text-form-data\nArray.from(opts.body.entries()).reduce((acc,_ref3)=>{let[name,value]=_ref3;return\"\"+acc+name+\"=\"+value+\"\\n\";},\"\"):String(opts.body);return{path,submission:{formMethod,formAction,formEncType:opts.formEncType,formData:undefined,json:undefined,text}};}else if(opts.formEncType===\"application/json\"){// json only supports POST/PUT/PATCH/DELETE submissions\nif(!isMutationMethod(formMethod)){return getInvalidBodyError();}try{let json=typeof opts.body===\"string\"?JSON.parse(opts.body):opts.body;return{path,submission:{formMethod,formAction,formEncType:opts.formEncType,formData:undefined,json,text:undefined}};}catch(e){return getInvalidBodyError();}}}invariant(typeof FormData===\"function\",\"FormData is not available in this environment\");let searchParams;let formData;if(opts.formData){searchParams=convertFormDataToSearchParams(opts.formData);formData=opts.formData;}else if(opts.body instanceof FormData){searchParams=convertFormDataToSearchParams(opts.body);formData=opts.body;}else if(opts.body instanceof URLSearchParams){searchParams=opts.body;formData=convertSearchParamsToFormData(searchParams);}else if(opts.body==null){searchParams=new URLSearchParams();formData=new FormData();}else{try{searchParams=new URLSearchParams(opts.body);formData=convertSearchParamsToFormData(searchParams);}catch(e){return getInvalidBodyError();}}let submission={formMethod,formAction,formEncType:opts&&opts.formEncType||\"application/x-www-form-urlencoded\",formData,json:undefined,text:undefined};if(isMutationMethod(submission.formMethod)){return{path,submission};}// Flatten submission onto URLSearchParams for GET submissions\nlet parsedPath=parsePath(path);// On GET navigation submissions we can drop the ?index param from the\n// resulting location since all loaders will run.  But fetcher GET submissions\n// only run a single loader so we need to preserve any incoming ?index params\nif(isFetcher&&parsedPath.search&&hasNakedIndexQuery(parsedPath.search)){searchParams.append(\"index\",\"\");}parsedPath.search=\"?\"+searchParams;return{path:createPath(parsedPath),submission};}// Filter out all routes below any caught error as they aren't going to\n// render so we don't need to load them\nfunction getLoaderMatchesUntilBoundary(matches,boundaryId){let boundaryMatches=matches;if(boundaryId){let index=matches.findIndex(m=>m.route.id===boundaryId);if(index>=0){boundaryMatches=matches.slice(0,index);}}return boundaryMatches;}function getMatchesToLoad(history,state,matches,submission,location,isRevalidationRequired,cancelledDeferredRoutes,cancelledFetcherLoads,fetchLoadMatches,fetchRedirectIds,routesToUse,basename,pendingActionData,pendingError){let actionResult=pendingError?Object.values(pendingError)[0]:pendingActionData?Object.values(pendingActionData)[0]:undefined;let currentUrl=history.createURL(state.location);let nextUrl=history.createURL(location);// Pick navigation matches that are net-new or qualify for revalidation\nlet boundaryId=pendingError?Object.keys(pendingError)[0]:undefined;let boundaryMatches=getLoaderMatchesUntilBoundary(matches,boundaryId);let navigationMatches=boundaryMatches.filter((match,index)=>{if(match.route.lazy){// We haven't loaded this route yet so we don't know if it's got a loader!\nreturn true;}if(match.route.loader==null){return false;}// Always call the loader on new route instances and pending defer cancellations\nif(isNewLoader(state.loaderData,state.matches[index],match)||cancelledDeferredRoutes.some(id=>id===match.route.id)){return true;}// This is the default implementation for when we revalidate.  If the route\n// provides it's own implementation, then we give them full control but\n// provide this value so they can leverage it if needed after they check\n// their own specific use cases\nlet currentRouteMatch=state.matches[index];let nextRouteMatch=match;return shouldRevalidateLoader(match,_extends({currentUrl,currentParams:currentRouteMatch.params,nextUrl,nextParams:nextRouteMatch.params},submission,{actionResult,defaultShouldRevalidate:// Forced revalidation due to submission, useRevalidator, or X-Remix-Revalidate\nisRevalidationRequired||// Clicked the same link, resubmitted a GET form\ncurrentUrl.pathname+currentUrl.search===nextUrl.pathname+nextUrl.search||// Search params affect all loaders\ncurrentUrl.search!==nextUrl.search||isNewRouteInstance(currentRouteMatch,nextRouteMatch)}));});// Pick fetcher.loads that need to be revalidated\nlet revalidatingFetchers=[];fetchLoadMatches.forEach((f,key)=>{// Don't revalidate if fetcher won't be present in the subsequent render\nif(!matches.some(m=>m.route.id===f.routeId)){return;}let fetcherMatches=matchRoutes(routesToUse,f.path,basename);// If the fetcher path no longer matches, push it in with null matches so\n// we can trigger a 404 in callLoadersAndMaybeResolveData.  Note this is\n// currently only a use-case for Remix HMR where the route tree can change\n// at runtime and remove a route previously loaded via a fetcher\nif(!fetcherMatches){revalidatingFetchers.push({key,routeId:f.routeId,path:f.path,matches:null,match:null,controller:null});return;}// Revalidating fetchers are decoupled from the route matches since they\n// load from a static href.  They revalidate based on explicit revalidation\n// (submission, useRevalidator, or X-Remix-Revalidate)\nlet fetcher=state.fetchers.get(key);let fetcherMatch=getTargetMatch(fetcherMatches,f.path);let shouldRevalidate=false;if(fetchRedirectIds.has(key)){// Never trigger a revalidation of an actively redirecting fetcher\nshouldRevalidate=false;}else if(cancelledFetcherLoads.includes(key)){// Always revalidate if the fetcher was cancelled\nshouldRevalidate=true;}else if(fetcher&&fetcher.state!==\"idle\"&&fetcher.data===undefined){// If the fetcher hasn't ever completed loading yet, then this isn't a\n// revalidation, it would just be a brand new load if an explicit\n// revalidation is required\nshouldRevalidate=isRevalidationRequired;}else{// Otherwise fall back on any user-defined shouldRevalidate, defaulting\n// to explicit revalidations only\nshouldRevalidate=shouldRevalidateLoader(fetcherMatch,_extends({currentUrl,currentParams:state.matches[state.matches.length-1].params,nextUrl,nextParams:matches[matches.length-1].params},submission,{actionResult,defaultShouldRevalidate:isRevalidationRequired}));}if(shouldRevalidate){revalidatingFetchers.push({key,routeId:f.routeId,path:f.path,matches:fetcherMatches,match:fetcherMatch,controller:new AbortController()});}});return[navigationMatches,revalidatingFetchers];}function isNewLoader(currentLoaderData,currentMatch,match){let isNew=// [a] -> [a, b]\n!currentMatch||// [a, b] -> [a, c]\nmatch.route.id!==currentMatch.route.id;// Handle the case that we don't have data for a re-used route, potentially\n// from a prior error or from a cancelled pending deferred\nlet isMissingData=currentLoaderData[match.route.id]===undefined;// Always load if this is a net-new route or we don't yet have data\nreturn isNew||isMissingData;}function isNewRouteInstance(currentMatch,match){let currentPath=currentMatch.route.path;return(// param change for this match, /users/123 -> /users/456\ncurrentMatch.pathname!==match.pathname||// splat param changed, which is not present in match.path\n// e.g. /files/images/avatar.jpg -> files/finances.xls\ncurrentPath!=null&&currentPath.endsWith(\"*\")&&currentMatch.params[\"*\"]!==match.params[\"*\"]);}function shouldRevalidateLoader(loaderMatch,arg){if(loaderMatch.route.shouldRevalidate){let routeChoice=loaderMatch.route.shouldRevalidate(arg);if(typeof routeChoice===\"boolean\"){return routeChoice;}}return arg.defaultShouldRevalidate;}/**\n * Execute route.lazy() methods to lazily load route modules (loader, action,\n * shouldRevalidate) and update the routeManifest in place which shares objects\n * with dataRoutes so those get updated as well.\n */async function loadLazyRouteModule(route,mapRouteProperties,manifest){if(!route.lazy){return;}let lazyRoute=await route.lazy();// If the lazy route function was executed and removed by another parallel\n// call then we can return - first lazy() to finish wins because the return\n// value of lazy is expected to be static\nif(!route.lazy){return;}let routeToUpdate=manifest[route.id];invariant(routeToUpdate,\"No route found in manifest\");// Update the route in place.  This should be safe because there's no way\n// we could yet be sitting on this route as we can't get there without\n// resolving lazy() first.\n//\n// This is different than the HMR \"update\" use-case where we may actively be\n// on the route being updated.  The main concern boils down to \"does this\n// mutation affect any ongoing navigations or any current state.matches\n// values?\".  If not, it should be safe to update in place.\nlet routeUpdates={};for(let lazyRouteProperty in lazyRoute){let staticRouteValue=routeToUpdate[lazyRouteProperty];let isPropertyStaticallyDefined=staticRouteValue!==undefined&&// This property isn't static since it should always be updated based\n// on the route updates\nlazyRouteProperty!==\"hasErrorBoundary\";warning(!isPropertyStaticallyDefined,\"Route \\\"\"+routeToUpdate.id+\"\\\" has a static property \\\"\"+lazyRouteProperty+\"\\\" \"+\"defined but its lazy function is also returning a value for this property. \"+(\"The lazy route property \\\"\"+lazyRouteProperty+\"\\\" will be ignored.\"));if(!isPropertyStaticallyDefined&&!immutableRouteKeys.has(lazyRouteProperty)){routeUpdates[lazyRouteProperty]=lazyRoute[lazyRouteProperty];}}// Mutate the route with the provided updates.  Do this first so we pass\n// the updated version to mapRouteProperties\nObject.assign(routeToUpdate,routeUpdates);// Mutate the `hasErrorBoundary` property on the route based on the route\n// updates and remove the `lazy` function so we don't resolve the lazy\n// route again.\nObject.assign(routeToUpdate,_extends({},mapRouteProperties(routeToUpdate),{lazy:undefined}));}async function callLoaderOrAction(type,request,match,matches,manifest,mapRouteProperties,basename,opts){if(opts===void 0){opts={};}let resultType;let result;let onReject;let runHandler=handler=>{// Setup a promise we can race against so that abort signals short circuit\nlet reject;let abortPromise=new Promise((_,r)=>reject=r);onReject=()=>reject();request.signal.addEventListener(\"abort\",onReject);return Promise.race([handler({request,params:match.params,context:opts.requestContext}),abortPromise]);};try{let handler=match.route[type];if(match.route.lazy){if(handler){// Run statically defined handler in parallel with lazy()\nlet values=await Promise.all([runHandler(handler),loadLazyRouteModule(match.route,mapRouteProperties,manifest)]);result=values[0];}else{// Load lazy route module, then run any returned handler\nawait loadLazyRouteModule(match.route,mapRouteProperties,manifest);handler=match.route[type];if(handler){// Handler still run even if we got interrupted to maintain consistency\n// with un-abortable behavior of handler execution on non-lazy or\n// previously-lazy-loaded routes\nresult=await runHandler(handler);}else if(type===\"action\"){let url=new URL(request.url);let pathname=url.pathname+url.search;throw getInternalRouterError(405,{method:request.method,pathname,routeId:match.route.id});}else{// lazy() route has no loader to run.  Short circuit here so we don't\n// hit the invariant below that errors on returning undefined.\nreturn{type:ResultType.data,data:undefined};}}}else if(!handler){let url=new URL(request.url);let pathname=url.pathname+url.search;throw getInternalRouterError(404,{pathname});}else{result=await runHandler(handler);}invariant(result!==undefined,\"You defined \"+(type===\"action\"?\"an action\":\"a loader\")+\" for route \"+(\"\\\"\"+match.route.id+\"\\\" but didn't return anything from your `\"+type+\"` \")+\"function. Please return a value or `null`.\");}catch(e){resultType=ResultType.error;result=e;}finally{if(onReject){request.signal.removeEventListener(\"abort\",onReject);}}if(isResponse(result)){let status=result.status;// Process redirects\nif(redirectStatusCodes.has(status)){let location=result.headers.get(\"Location\");invariant(location,\"Redirects returned/thrown from loaders/actions must have a Location header\");// Support relative routing in internal redirects\nif(!ABSOLUTE_URL_REGEX.test(location)){location=normalizeTo(new URL(request.url),matches.slice(0,matches.indexOf(match)+1),basename,true,location);}else if(!opts.isStaticRequest){// Strip off the protocol+origin for same-origin + same-basename absolute\n// redirects. If this is a static request, we can let it go back to the\n// browser as-is\nlet currentUrl=new URL(request.url);let url=location.startsWith(\"//\")?new URL(currentUrl.protocol+location):new URL(location);let isSameBasename=stripBasename(url.pathname,basename)!=null;if(url.origin===currentUrl.origin&&isSameBasename){location=url.pathname+url.search+url.hash;}}// Don't process redirects in the router during static requests requests.\n// Instead, throw the Response and let the server handle it with an HTTP\n// redirect.  We also update the Location header in place in this flow so\n// basename and relative routing is taken into account\nif(opts.isStaticRequest){result.headers.set(\"Location\",location);throw result;}return{type:ResultType.redirect,status,location,revalidate:result.headers.get(\"X-Remix-Revalidate\")!==null,reloadDocument:result.headers.get(\"X-Remix-Reload-Document\")!==null};}// For SSR single-route requests, we want to hand Responses back directly\n// without unwrapping.  We do this with the QueryRouteResponse wrapper\n// interface so we can know whether it was returned or thrown\nif(opts.isRouteRequest){let queryRouteResponse={type:resultType===ResultType.error?ResultType.error:ResultType.data,response:result};throw queryRouteResponse;}let data;let contentType=result.headers.get(\"Content-Type\");// Check between word boundaries instead of startsWith() due to the last\n// paragraph of https://httpwg.org/specs/rfc9110.html#field.content-type\nif(contentType&&/\\bapplication\\/json\\b/.test(contentType)){data=await result.json();}else{data=await result.text();}if(resultType===ResultType.error){return{type:resultType,error:new ErrorResponse(status,result.statusText,data),headers:result.headers};}return{type:ResultType.data,data,statusCode:result.status,headers:result.headers};}if(resultType===ResultType.error){return{type:resultType,error:result};}if(isDeferredData(result)){var _result$init,_result$init2;return{type:ResultType.deferred,deferredData:result,statusCode:(_result$init=result.init)==null?void 0:_result$init.status,headers:((_result$init2=result.init)==null?void 0:_result$init2.headers)&&new Headers(result.init.headers)};}return{type:ResultType.data,data:result};}// Utility method for creating the Request instances for loaders/actions during\n// client-side navigations and fetches.  During SSR we will always have a\n// Request instance from the static handler (query/queryRoute)\nfunction createClientSideRequest(history,location,signal,submission){let url=history.createURL(stripHashFromPath(location)).toString();let init={signal};if(submission&&isMutationMethod(submission.formMethod)){let{formMethod,formEncType}=submission;// Didn't think we needed this but it turns out unlike other methods, patch\n// won't be properly normalized to uppercase and results in a 405 error.\n// See: https://fetch.spec.whatwg.org/#concept-method\ninit.method=formMethod.toUpperCase();if(formEncType===\"application/json\"){init.headers=new Headers({\"Content-Type\":formEncType});init.body=JSON.stringify(submission.json);}else if(formEncType===\"text/plain\"){// Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\ninit.body=submission.text;}else if(formEncType===\"application/x-www-form-urlencoded\"&&submission.formData){// Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\ninit.body=convertFormDataToSearchParams(submission.formData);}else{// Content-Type is inferred (https://fetch.spec.whatwg.org/#dom-request)\ninit.body=submission.formData;}}return new Request(url,init);}function convertFormDataToSearchParams(formData){let searchParams=new URLSearchParams();for(let[key,value]of formData.entries()){// https://html.spec.whatwg.org/multipage/form-control-infrastructure.html#converting-an-entry-list-to-a-list-of-name-value-pairs\nsearchParams.append(key,typeof value===\"string\"?value:value.name);}return searchParams;}function convertSearchParamsToFormData(searchParams){let formData=new FormData();for(let[key,value]of searchParams.entries()){formData.append(key,value);}return formData;}function processRouteLoaderData(matches,matchesToLoad,results,pendingError,activeDeferreds){// Fill in loaderData/errors from our loaders\nlet loaderData={};let errors=null;let statusCode;let foundError=false;let loaderHeaders={};// Process loader results into state.loaderData/state.errors\nresults.forEach((result,index)=>{let id=matchesToLoad[index].route.id;invariant(!isRedirectResult(result),\"Cannot handle redirect results in processLoaderData\");if(isErrorResult(result)){// Look upwards from the matched route for the closest ancestor\n// error boundary, defaulting to the root match\nlet boundaryMatch=findNearestBoundary(matches,id);let error=result.error;// If we have a pending action error, we report it at the highest-route\n// that throws a loader error, and then clear it out to indicate that\n// it was consumed\nif(pendingError){error=Object.values(pendingError)[0];pendingError=undefined;}errors=errors||{};// Prefer higher error values if lower errors bubble to the same boundary\nif(errors[boundaryMatch.route.id]==null){errors[boundaryMatch.route.id]=error;}// Clear our any prior loaderData for the throwing route\nloaderData[id]=undefined;// Once we find our first (highest) error, we set the status code and\n// prevent deeper status codes from overriding\nif(!foundError){foundError=true;statusCode=isRouteErrorResponse(result.error)?result.error.status:500;}if(result.headers){loaderHeaders[id]=result.headers;}}else{if(isDeferredResult(result)){activeDeferreds.set(id,result.deferredData);loaderData[id]=result.deferredData.data;}else{loaderData[id]=result.data;}// Error status codes always override success status codes, but if all\n// loaders are successful we take the deepest status code.\nif(result.statusCode!=null&&result.statusCode!==200&&!foundError){statusCode=result.statusCode;}if(result.headers){loaderHeaders[id]=result.headers;}}});// If we didn't consume the pending action error (i.e., all loaders\n// resolved), then consume it here.  Also clear out any loaderData for the\n// throwing route\nif(pendingError){errors=pendingError;loaderData[Object.keys(pendingError)[0]]=undefined;}return{loaderData,errors,statusCode:statusCode||200,loaderHeaders};}function processLoaderData(state,matches,matchesToLoad,results,pendingError,revalidatingFetchers,fetcherResults,activeDeferreds){let{loaderData,errors}=processRouteLoaderData(matches,matchesToLoad,results,pendingError,activeDeferreds);// Process results from our revalidating fetchers\nfor(let index=0;index<revalidatingFetchers.length;index++){let{key,match,controller}=revalidatingFetchers[index];invariant(fetcherResults!==undefined&&fetcherResults[index]!==undefined,\"Did not find corresponding fetcher result\");let result=fetcherResults[index];// Process fetcher non-redirect errors\nif(controller&&controller.signal.aborted){// Nothing to do for aborted fetchers\ncontinue;}else if(isErrorResult(result)){let boundaryMatch=findNearestBoundary(state.matches,match==null?void 0:match.route.id);if(!(errors&&errors[boundaryMatch.route.id])){errors=_extends({},errors,{[boundaryMatch.route.id]:result.error});}state.fetchers.delete(key);}else if(isRedirectResult(result)){// Should never get here, redirects should get processed above, but we\n// keep this to type narrow to a success result in the else\ninvariant(false,\"Unhandled fetcher revalidation redirect\");}else if(isDeferredResult(result)){// Should never get here, deferred data should be awaited for fetchers\n// in resolveDeferredResults\ninvariant(false,\"Unhandled fetcher deferred data\");}else{let doneFetcher=getDoneFetcher(result.data);state.fetchers.set(key,doneFetcher);}}return{loaderData,errors};}function mergeLoaderData(loaderData,newLoaderData,matches,errors){let mergedLoaderData=_extends({},newLoaderData);for(let match of matches){let id=match.route.id;if(newLoaderData.hasOwnProperty(id)){if(newLoaderData[id]!==undefined){mergedLoaderData[id]=newLoaderData[id];}}else if(loaderData[id]!==undefined&&match.route.loader){// Preserve existing keys not included in newLoaderData and where a loader\n// wasn't removed by HMR\nmergedLoaderData[id]=loaderData[id];}if(errors&&errors.hasOwnProperty(id)){// Don't keep any loader data below the boundary\nbreak;}}return mergedLoaderData;}// Find the nearest error boundary, looking upwards from the leaf route (or the\n// route specified by routeId) for the closest ancestor error boundary,\n// defaulting to the root match\nfunction findNearestBoundary(matches,routeId){let eligibleMatches=routeId?matches.slice(0,matches.findIndex(m=>m.route.id===routeId)+1):[...matches];return eligibleMatches.reverse().find(m=>m.route.hasErrorBoundary===true)||matches[0];}function getShortCircuitMatches(routes){// Prefer a root layout route if present, otherwise shim in a route object\nlet route=routes.find(r=>r.index||!r.path||r.path===\"/\")||{id:\"__shim-error-route__\"};return{matches:[{params:{},pathname:\"\",pathnameBase:\"\",route}],route};}function getInternalRouterError(status,_temp4){let{pathname,routeId,method,type}=_temp4===void 0?{}:_temp4;let statusText=\"Unknown Server Error\";let errorMessage=\"Unknown @remix-run/router error\";if(status===400){statusText=\"Bad Request\";if(method&&pathname&&routeId){errorMessage=\"You made a \"+method+\" request to \\\"\"+pathname+\"\\\" but \"+(\"did not provide a `loader` for route \\\"\"+routeId+\"\\\", \")+\"so there is no way to handle the request.\";}else if(type===\"defer-action\"){errorMessage=\"defer() is not supported in actions\";}else if(type===\"invalid-body\"){errorMessage=\"Unable to encode submission body\";}}else if(status===403){statusText=\"Forbidden\";errorMessage=\"Route \\\"\"+routeId+\"\\\" does not match URL \\\"\"+pathname+\"\\\"\";}else if(status===404){statusText=\"Not Found\";errorMessage=\"No route matches URL \\\"\"+pathname+\"\\\"\";}else if(status===405){statusText=\"Method Not Allowed\";if(method&&pathname&&routeId){errorMessage=\"You made a \"+method.toUpperCase()+\" request to \\\"\"+pathname+\"\\\" but \"+(\"did not provide an `action` for route \\\"\"+routeId+\"\\\", \")+\"so there is no way to handle the request.\";}else if(method){errorMessage=\"Invalid request method \\\"\"+method.toUpperCase()+\"\\\"\";}}return new ErrorResponse(status||500,statusText,new Error(errorMessage),true);}// Find any returned redirect errors, starting from the lowest match\nfunction findRedirect(results){for(let i=results.length-1;i>=0;i--){let result=results[i];if(isRedirectResult(result)){return{result,idx:i};}}}function stripHashFromPath(path){let parsedPath=typeof path===\"string\"?parsePath(path):path;return createPath(_extends({},parsedPath,{hash:\"\"}));}function isHashChangeOnly(a,b){if(a.pathname!==b.pathname||a.search!==b.search){return false;}if(a.hash===\"\"){// /page -> /page#hash\nreturn b.hash!==\"\";}else if(a.hash===b.hash){// /page#hash -> /page#hash\nreturn true;}else if(b.hash!==\"\"){// /page#hash -> /page#other\nreturn true;}// If the hash is removed the browser will re-perform a request to the server\n// /page#hash -> /page\nreturn false;}function isDeferredResult(result){return result.type===ResultType.deferred;}function isErrorResult(result){return result.type===ResultType.error;}function isRedirectResult(result){return(result&&result.type)===ResultType.redirect;}function isDeferredData(value){let deferred=value;return deferred&&typeof deferred===\"object\"&&typeof deferred.data===\"object\"&&typeof deferred.subscribe===\"function\"&&typeof deferred.cancel===\"function\"&&typeof deferred.resolveData===\"function\";}function isResponse(value){return value!=null&&typeof value.status===\"number\"&&typeof value.statusText===\"string\"&&typeof value.headers===\"object\"&&typeof value.body!==\"undefined\";}function isRedirectResponse(result){if(!isResponse(result)){return false;}let status=result.status;let location=result.headers.get(\"Location\");return status>=300&&status<=399&&location!=null;}function isQueryRouteResponse(obj){return obj&&isResponse(obj.response)&&(obj.type===ResultType.data||obj.type===ResultType.error);}function isValidMethod(method){return validRequestMethods.has(method.toLowerCase());}function isMutationMethod(method){return validMutationMethods.has(method.toLowerCase());}async function resolveDeferredResults(currentMatches,matchesToLoad,results,signals,isFetcher,currentLoaderData){for(let index=0;index<results.length;index++){let result=results[index];let match=matchesToLoad[index];// If we don't have a match, then we can have a deferred result to do\n// anything with.  This is for revalidating fetchers where the route was\n// removed during HMR\nif(!match){continue;}let currentMatch=currentMatches.find(m=>m.route.id===match.route.id);let isRevalidatingLoader=currentMatch!=null&&!isNewRouteInstance(currentMatch,match)&&(currentLoaderData&&currentLoaderData[match.route.id])!==undefined;if(isDeferredResult(result)&&(isFetcher||isRevalidatingLoader)){// Note: we do not have to touch activeDeferreds here since we race them\n// against the signal in resolveDeferredData and they'll get aborted\n// there if needed\nlet signal=signals[index];invariant(signal,\"Expected an AbortSignal for revalidating fetcher deferred result\");await resolveDeferredData(result,signal,isFetcher).then(result=>{if(result){results[index]=result||results[index];}});}}}async function resolveDeferredData(result,signal,unwrap){if(unwrap===void 0){unwrap=false;}let aborted=await result.deferredData.resolveData(signal);if(aborted){return;}if(unwrap){try{return{type:ResultType.data,data:result.deferredData.unwrappedData};}catch(e){// Handle any TrackedPromise._error values encountered while unwrapping\nreturn{type:ResultType.error,error:e};}}return{type:ResultType.data,data:result.deferredData.data};}function hasNakedIndexQuery(search){return new URLSearchParams(search).getAll(\"index\").some(v=>v===\"\");}// Note: This should match the format exported by useMatches, so if you change\n// this please also change that :)  Eventually we'll DRY this up\nfunction createUseMatchesMatch(match,loaderData){let{route,pathname,params}=match;return{id:route.id,pathname,params,data:loaderData[route.id],handle:route.handle};}function getTargetMatch(matches,location){let search=typeof location===\"string\"?parsePath(location).search:location.search;if(matches[matches.length-1].route.index&&hasNakedIndexQuery(search||\"\")){// Return the leaf index route when index is present\nreturn matches[matches.length-1];}// Otherwise grab the deepest \"path contributing\" match (ignoring index and\n// pathless layout routes)\nlet pathMatches=getPathContributingMatches(matches);return pathMatches[pathMatches.length-1];}function getSubmissionFromNavigation(navigation){let{formMethod,formAction,formEncType,text,formData,json}=navigation;if(!formMethod||!formAction||!formEncType){return;}if(text!=null){return{formMethod,formAction,formEncType,formData:undefined,json:undefined,text};}else if(formData!=null){return{formMethod,formAction,formEncType,formData,json:undefined,text:undefined};}else if(json!==undefined){return{formMethod,formAction,formEncType,formData:undefined,json,text:undefined};}}function getLoadingNavigation(location,submission){if(submission){let navigation={state:\"loading\",location,formMethod:submission.formMethod,formAction:submission.formAction,formEncType:submission.formEncType,formData:submission.formData,json:submission.json,text:submission.text};return navigation;}else{let navigation={state:\"loading\",location,formMethod:undefined,formAction:undefined,formEncType:undefined,formData:undefined,json:undefined,text:undefined};return navigation;}}function getSubmittingNavigation(location,submission){let navigation={state:\"submitting\",location,formMethod:submission.formMethod,formAction:submission.formAction,formEncType:submission.formEncType,formData:submission.formData,json:submission.json,text:submission.text};return navigation;}function getLoadingFetcher(submission,data){if(submission){let fetcher={state:\"loading\",formMethod:submission.formMethod,formAction:submission.formAction,formEncType:submission.formEncType,formData:submission.formData,json:submission.json,text:submission.text,data,\" _hasFetcherDoneAnything \":true};return fetcher;}else{let fetcher={state:\"loading\",formMethod:undefined,formAction:undefined,formEncType:undefined,formData:undefined,json:undefined,text:undefined,data,\" _hasFetcherDoneAnything \":true};return fetcher;}}function getSubmittingFetcher(submission,existingFetcher){let fetcher={state:\"submitting\",formMethod:submission.formMethod,formAction:submission.formAction,formEncType:submission.formEncType,formData:submission.formData,json:submission.json,text:submission.text,data:existingFetcher?existingFetcher.data:undefined,\" _hasFetcherDoneAnything \":true};return fetcher;}function getDoneFetcher(data){let fetcher={state:\"idle\",formMethod:undefined,formAction:undefined,formEncType:undefined,formData:undefined,json:undefined,text:undefined,data,\" _hasFetcherDoneAnything \":true};return fetcher;}//#endregion\nexport{AbortedDeferredError,Action,ErrorResponse,IDLE_BLOCKER,IDLE_FETCHER,IDLE_NAVIGATION,UNSAFE_DEFERRED_SYMBOL,DeferredData as UNSAFE_DeferredData,convertRoutesToDataRoutes as UNSAFE_convertRoutesToDataRoutes,getPathContributingMatches as UNSAFE_getPathContributingMatches,invariant as UNSAFE_invariant,warning as UNSAFE_warning,createBrowserHistory,createHashHistory,createMemoryHistory,createPath,createRouter,createStaticHandler,defer,generatePath,getStaticContextFromError,getToPathname,isDeferredData,isRouteErrorResponse,joinPaths,json,matchPath,matchRoutes,normalizePathname,parsePath,redirect,redirectDocument,resolvePath,resolveTo,stripBasename};","/**\n * React Router DOM v6.15.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */import*as React from'react';import{UNSAFE_mapRouteProperties,Router,UNSAFE_NavigationContext,useHref,useResolvedPath,useLocation,UNSAFE_DataRouterStateContext,useNavigate,createPath,UNSAFE_useRouteId,UNSAFE_RouteContext,useMatches,useNavigation,unstable_useBlocker,UNSAFE_DataRouterContext}from'react-router';export{AbortedDeferredError,Await,MemoryRouter,Navigate,NavigationType,Outlet,Route,Router,RouterProvider,Routes,UNSAFE_DataRouterContext,UNSAFE_DataRouterStateContext,UNSAFE_LocationContext,UNSAFE_NavigationContext,UNSAFE_RouteContext,UNSAFE_useRouteId,createMemoryRouter,createPath,createRoutesFromChildren,createRoutesFromElements,defer,generatePath,isRouteErrorResponse,json,matchPath,matchRoutes,parsePath,redirect,redirectDocument,renderMatches,resolvePath,unstable_useBlocker,useActionData,useAsyncError,useAsyncValue,useHref,useInRouterContext,useLoaderData,useLocation,useMatch,useMatches,useNavigate,useNavigation,useNavigationType,useOutlet,useOutletContext,useParams,useResolvedPath,useRevalidator,useRouteError,useRouteLoaderData,useRoutes}from'react-router';import{stripBasename,UNSAFE_warning,createRouter,createBrowserHistory,createHashHistory,ErrorResponse,UNSAFE_invariant,joinPaths}from'@remix-run/router';function _extends(){_extends=Object.assign?Object.assign.bind():function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key];}}}return target;};return _extends.apply(this,arguments);}function _objectWithoutPropertiesLoose(source,excluded){if(source==null)return{};var target={};var sourceKeys=Object.keys(source);var key,i;for(i=0;i<sourceKeys.length;i++){key=sourceKeys[i];if(excluded.indexOf(key)>=0)continue;target[key]=source[key];}return target;}const defaultMethod=\"get\";const defaultEncType=\"application/x-www-form-urlencoded\";function isHtmlElement(object){return object!=null&&typeof object.tagName===\"string\";}function isButtonElement(object){return isHtmlElement(object)&&object.tagName.toLowerCase()===\"button\";}function isFormElement(object){return isHtmlElement(object)&&object.tagName.toLowerCase()===\"form\";}function isInputElement(object){return isHtmlElement(object)&&object.tagName.toLowerCase()===\"input\";}function isModifiedEvent(event){return!!(event.metaKey||event.altKey||event.ctrlKey||event.shiftKey);}function shouldProcessLinkClick(event,target){return event.button===0&&(// Ignore everything but left clicks\n!target||target===\"_self\")&&// Let browser handle \"target=_blank\" etc.\n!isModifiedEvent(event)// Ignore clicks with modifier keys\n;}/**\n * Creates a URLSearchParams object using the given initializer.\n *\n * This is identical to `new URLSearchParams(init)` except it also\n * supports arrays as values in the object form of the initializer\n * instead of just strings. This is convenient when you need multiple\n * values for a given key, but don't want to use an array initializer.\n *\n * For example, instead of:\n *\n *   let searchParams = new URLSearchParams([\n *     ['sort', 'name'],\n *     ['sort', 'price']\n *   ]);\n *\n * you can do:\n *\n *   let searchParams = createSearchParams({\n *     sort: ['name', 'price']\n *   });\n */function createSearchParams(init){if(init===void 0){init=\"\";}return new URLSearchParams(typeof init===\"string\"||Array.isArray(init)||init instanceof URLSearchParams?init:Object.keys(init).reduce((memo,key)=>{let value=init[key];return memo.concat(Array.isArray(value)?value.map(v=>[key,v]):[[key,value]]);},[]));}function getSearchParamsForLocation(locationSearch,defaultSearchParams){let searchParams=createSearchParams(locationSearch);if(defaultSearchParams){// Use `defaultSearchParams.forEach(...)` here instead of iterating of\n// `defaultSearchParams.keys()` to work-around a bug in Firefox related to\n// web extensions. Relevant Bugzilla tickets:\n// https://bugzilla.mozilla.org/show_bug.cgi?id=1414602\n// https://bugzilla.mozilla.org/show_bug.cgi?id=1023984\ndefaultSearchParams.forEach((_,key)=>{if(!searchParams.has(key)){defaultSearchParams.getAll(key).forEach(value=>{searchParams.append(key,value);});}});}return searchParams;}// One-time check for submitter support\nlet _formDataSupportsSubmitter=null;function isFormDataSubmitterSupported(){if(_formDataSupportsSubmitter===null){try{new FormData(document.createElement(\"form\"),// @ts-expect-error if FormData supports the submitter parameter, this will throw\n0);_formDataSupportsSubmitter=false;}catch(e){_formDataSupportsSubmitter=true;}}return _formDataSupportsSubmitter;}const supportedFormEncTypes=new Set([\"application/x-www-form-urlencoded\",\"multipart/form-data\",\"text/plain\"]);function getFormEncType(encType){if(encType!=null&&!supportedFormEncTypes.has(encType)){process.env.NODE_ENV!==\"production\"?UNSAFE_warning(false,\"\\\"\"+encType+\"\\\" is not a valid `encType` for `<Form>`/`<fetcher.Form>` \"+(\"and will default to \\\"\"+defaultEncType+\"\\\"\")):void 0;return null;}return encType;}function getFormSubmissionInfo(target,basename){let method;let action;let encType;let formData;let body;if(isFormElement(target)){// When grabbing the action from the element, it will have had the basename\n// prefixed to ensure non-JS scenarios work, so strip it since we'll\n// re-prefix in the router\nlet attr=target.getAttribute(\"action\");action=attr?stripBasename(attr,basename):null;method=target.getAttribute(\"method\")||defaultMethod;encType=getFormEncType(target.getAttribute(\"enctype\"))||defaultEncType;formData=new FormData(target);}else if(isButtonElement(target)||isInputElement(target)&&(target.type===\"submit\"||target.type===\"image\")){let form=target.form;if(form==null){throw new Error(\"Cannot submit a <button> or <input type=\\\"submit\\\"> without a <form>\");}// <button>/<input type=\"submit\"> may override attributes of <form>\n// When grabbing the action from the element, it will have had the basename\n// prefixed to ensure non-JS scenarios work, so strip it since we'll\n// re-prefix in the router\nlet attr=target.getAttribute(\"formaction\")||form.getAttribute(\"action\");action=attr?stripBasename(attr,basename):null;method=target.getAttribute(\"formmethod\")||form.getAttribute(\"method\")||defaultMethod;encType=getFormEncType(target.getAttribute(\"formenctype\"))||getFormEncType(form.getAttribute(\"enctype\"))||defaultEncType;// Build a FormData object populated from a form and submitter\nformData=new FormData(form,target);// If this browser doesn't support the `FormData(el, submitter)` format,\n// then tack on the submitter value at the end.  This is a lightweight\n// solution that is not 100% spec compliant.  For complete support in older\n// browsers, consider using the `formdata-submitter-polyfill` package\nif(!isFormDataSubmitterSupported()){let{name,type,value}=target;if(type===\"image\"){let prefix=name?name+\".\":\"\";formData.append(prefix+\"x\",\"0\");formData.append(prefix+\"y\",\"0\");}else if(name){formData.append(name,value);}}}else if(isHtmlElement(target)){throw new Error(\"Cannot submit element that is not <form>, <button>, or \"+\"<input type=\\\"submit|image\\\">\");}else{method=defaultMethod;action=null;encType=defaultEncType;body=target;}// Send body for <Form encType=\"text/plain\" so we encode it into text\nif(formData&&encType===\"text/plain\"){body=formData;formData=undefined;}return{action,method:method.toLowerCase(),encType,formData,body};}const _excluded=[\"onClick\",\"relative\",\"reloadDocument\",\"replace\",\"state\",\"target\",\"to\",\"preventScrollReset\"],_excluded2=[\"aria-current\",\"caseSensitive\",\"className\",\"end\",\"style\",\"to\",\"children\"],_excluded3=[\"reloadDocument\",\"replace\",\"state\",\"method\",\"action\",\"onSubmit\",\"submit\",\"relative\",\"preventScrollReset\"];function createBrowserRouter(routes,opts){return createRouter({basename:opts==null?void 0:opts.basename,future:_extends({},opts==null?void 0:opts.future,{v7_prependBasename:true}),history:createBrowserHistory({window:opts==null?void 0:opts.window}),hydrationData:(opts==null?void 0:opts.hydrationData)||parseHydrationData(),routes,mapRouteProperties:UNSAFE_mapRouteProperties}).initialize();}function createHashRouter(routes,opts){return createRouter({basename:opts==null?void 0:opts.basename,future:_extends({},opts==null?void 0:opts.future,{v7_prependBasename:true}),history:createHashHistory({window:opts==null?void 0:opts.window}),hydrationData:(opts==null?void 0:opts.hydrationData)||parseHydrationData(),routes,mapRouteProperties:UNSAFE_mapRouteProperties}).initialize();}function parseHydrationData(){var _window;let state=(_window=window)==null?void 0:_window.__staticRouterHydrationData;if(state&&state.errors){state=_extends({},state,{errors:deserializeErrors(state.errors)});}return state;}function deserializeErrors(errors){if(!errors)return null;let entries=Object.entries(errors);let serialized={};for(let[key,val]of entries){// Hey you!  If you change this, please change the corresponding logic in\n// serializeErrors in react-router-dom/server.tsx :)\nif(val&&val.__type===\"RouteErrorResponse\"){serialized[key]=new ErrorResponse(val.status,val.statusText,val.data,val.internal===true);}else if(val&&val.__type===\"Error\"){// Attempt to reconstruct the right type of Error (i.e., ReferenceError)\nif(val.__subType){let ErrorConstructor=window[val.__subType];if(typeof ErrorConstructor===\"function\"){try{// @ts-expect-error\nlet error=new ErrorConstructor(val.message);// Wipe away the client-side stack trace.  Nothing to fill it in with\n// because we don't serialize SSR stack traces for security reasons\nerror.stack=\"\";serialized[key]=error;}catch(e){// no-op - fall through and create a normal Error\n}}}if(serialized[key]==null){let error=new Error(val.message);// Wipe away the client-side stack trace.  Nothing to fill it in with\n// because we don't serialize SSR stack traces for security reasons\nerror.stack=\"\";serialized[key]=error;}}else{serialized[key]=val;}}return serialized;}//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Components\n////////////////////////////////////////////////////////////////////////////////\n/**\n  Webpack + React 17 fails to compile on any of the following because webpack\n  complains that `startTransition` doesn't exist in `React`:\n  * import { startTransition } from \"react\"\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\n\n  Moving it to a constant such as the following solves the Webpack/React 17 issue:\n  * import * as React from from \"react\";\n    const START_TRANSITION = \"startTransition\";\n    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n  However, that introduces webpack/terser minification issues in production builds\n  in React 18 where minification/obfuscation ends up removing the call of\n  React.startTransition entirely from the first half of the ternary.  Grabbing\n  this exported reference once up front resolves that issue.\n\n  See https://github.com/remix-run/react-router/issues/10579\n*/const START_TRANSITION=\"startTransition\";const startTransitionImpl=React[START_TRANSITION];/**\n * A `<Router>` for use in web browsers. Provides the cleanest URLs.\n */function BrowserRouter(_ref){let{basename,children,future,window}=_ref;let historyRef=React.useRef();if(historyRef.current==null){historyRef.current=createBrowserHistory({window,v5Compat:true});}let history=historyRef.current;let[state,setStateImpl]=React.useState({action:history.action,location:history.location});let{v7_startTransition}=future||{};let setState=React.useCallback(newState=>{v7_startTransition&&startTransitionImpl?startTransitionImpl(()=>setStateImpl(newState)):setStateImpl(newState);},[setStateImpl,v7_startTransition]);React.useLayoutEffect(()=>history.listen(setState),[history,setState]);return/*#__PURE__*/React.createElement(Router,{basename:basename,children:children,location:state.location,navigationType:state.action,navigator:history});}/**\n * A `<Router>` for use in web browsers. Stores the location in the hash\n * portion of the URL so it is not sent to the server.\n */function HashRouter(_ref2){let{basename,children,future,window}=_ref2;let historyRef=React.useRef();if(historyRef.current==null){historyRef.current=createHashHistory({window,v5Compat:true});}let history=historyRef.current;let[state,setStateImpl]=React.useState({action:history.action,location:history.location});let{v7_startTransition}=future||{};let setState=React.useCallback(newState=>{v7_startTransition&&startTransitionImpl?startTransitionImpl(()=>setStateImpl(newState)):setStateImpl(newState);},[setStateImpl,v7_startTransition]);React.useLayoutEffect(()=>history.listen(setState),[history,setState]);return/*#__PURE__*/React.createElement(Router,{basename:basename,children:children,location:state.location,navigationType:state.action,navigator:history});}/**\n * A `<Router>` that accepts a pre-instantiated history object. It's important\n * to note that using your own history object is highly discouraged and may add\n * two versions of the history library to your bundles unless you use the same\n * version of the history library that React Router uses internally.\n */function HistoryRouter(_ref3){let{basename,children,future,history}=_ref3;let[state,setStateImpl]=React.useState({action:history.action,location:history.location});let{v7_startTransition}=future||{};let setState=React.useCallback(newState=>{v7_startTransition&&startTransitionImpl?startTransitionImpl(()=>setStateImpl(newState)):setStateImpl(newState);},[setStateImpl,v7_startTransition]);React.useLayoutEffect(()=>history.listen(setState),[history,setState]);return/*#__PURE__*/React.createElement(Router,{basename:basename,children:children,location:state.location,navigationType:state.action,navigator:history});}if(process.env.NODE_ENV!==\"production\"){HistoryRouter.displayName=\"unstable_HistoryRouter\";}const isBrowser=typeof window!==\"undefined\"&&typeof window.document!==\"undefined\"&&typeof window.document.createElement!==\"undefined\";const ABSOLUTE_URL_REGEX=/^(?:[a-z][a-z0-9+.-]*:|\\/\\/)/i;/**\n * The public API for rendering a history-aware <a>.\n */const Link=/*#__PURE__*/React.forwardRef(function LinkWithRef(_ref4,ref){let{onClick,relative,reloadDocument,replace,state,target,to,preventScrollReset}=_ref4,rest=_objectWithoutPropertiesLoose(_ref4,_excluded);let{basename}=React.useContext(UNSAFE_NavigationContext);// Rendered into <a href> for absolute URLs\nlet absoluteHref;let isExternal=false;if(typeof to===\"string\"&&ABSOLUTE_URL_REGEX.test(to)){// Render the absolute href server- and client-side\nabsoluteHref=to;// Only check for external origins client-side\nif(isBrowser){try{let currentUrl=new URL(window.location.href);let targetUrl=to.startsWith(\"//\")?new URL(currentUrl.protocol+to):new URL(to);let path=stripBasename(targetUrl.pathname,basename);if(targetUrl.origin===currentUrl.origin&&path!=null){// Strip the protocol/origin/basename for same-origin absolute URLs\nto=path+targetUrl.search+targetUrl.hash;}else{isExternal=true;}}catch(e){// We can't do external URL detection without a valid URL\nprocess.env.NODE_ENV!==\"production\"?UNSAFE_warning(false,\"<Link to=\\\"\"+to+\"\\\"> contains an invalid URL which will probably break \"+\"when clicked - please update to a valid URL path.\"):void 0;}}}// Rendered into <a href> for relative URLs\nlet href=useHref(to,{relative});let internalOnClick=useLinkClickHandler(to,{replace,state,target,preventScrollReset,relative});function handleClick(event){if(onClick)onClick(event);if(!event.defaultPrevented){internalOnClick(event);}}return/*#__PURE__*/ (// eslint-disable-next-line jsx-a11y/anchor-has-content\nReact.createElement(\"a\",_extends({},rest,{href:absoluteHref||href,onClick:isExternal||reloadDocument?onClick:handleClick,ref:ref,target:target})));});if(process.env.NODE_ENV!==\"production\"){Link.displayName=\"Link\";}/**\n * A <Link> wrapper that knows if it's \"active\" or not.\n */const NavLink=/*#__PURE__*/React.forwardRef(function NavLinkWithRef(_ref5,ref){let{\"aria-current\":ariaCurrentProp=\"page\",caseSensitive=false,className:classNameProp=\"\",end=false,style:styleProp,to,children}=_ref5,rest=_objectWithoutPropertiesLoose(_ref5,_excluded2);let path=useResolvedPath(to,{relative:rest.relative});let location=useLocation();let routerState=React.useContext(UNSAFE_DataRouterStateContext);let{navigator}=React.useContext(UNSAFE_NavigationContext);let toPathname=navigator.encodeLocation?navigator.encodeLocation(path).pathname:path.pathname;let locationPathname=location.pathname;let nextLocationPathname=routerState&&routerState.navigation&&routerState.navigation.location?routerState.navigation.location.pathname:null;if(!caseSensitive){locationPathname=locationPathname.toLowerCase();nextLocationPathname=nextLocationPathname?nextLocationPathname.toLowerCase():null;toPathname=toPathname.toLowerCase();}let isActive=locationPathname===toPathname||!end&&locationPathname.startsWith(toPathname)&&locationPathname.charAt(toPathname.length)===\"/\";let isPending=nextLocationPathname!=null&&(nextLocationPathname===toPathname||!end&&nextLocationPathname.startsWith(toPathname)&&nextLocationPathname.charAt(toPathname.length)===\"/\");let ariaCurrent=isActive?ariaCurrentProp:undefined;let className;if(typeof classNameProp===\"function\"){className=classNameProp({isActive,isPending});}else{// If the className prop is not a function, we use a default `active`\n// class for <NavLink />s that are active. In v5 `active` was the default\n// value for `activeClassName`, but we are removing that API and can still\n// use the old default behavior for a cleaner upgrade path and keep the\n// simple styling rules working as they currently do.\nclassName=[classNameProp,isActive?\"active\":null,isPending?\"pending\":null].filter(Boolean).join(\" \");}let style=typeof styleProp===\"function\"?styleProp({isActive,isPending}):styleProp;return/*#__PURE__*/React.createElement(Link,_extends({},rest,{\"aria-current\":ariaCurrent,className:className,ref:ref,style:style,to:to}),typeof children===\"function\"?children({isActive,isPending}):children);});if(process.env.NODE_ENV!==\"production\"){NavLink.displayName=\"NavLink\";}/**\n * A `@remix-run/router`-aware `<form>`. It behaves like a normal form except\n * that the interaction with the server is with `fetch` instead of new document\n * requests, allowing components to add nicer UX to the page as the form is\n * submitted and returns with data.\n */const Form=/*#__PURE__*/React.forwardRef((props,ref)=>{let submit=useSubmit();return/*#__PURE__*/React.createElement(FormImpl,_extends({},props,{submit:submit,ref:ref}));});if(process.env.NODE_ENV!==\"production\"){Form.displayName=\"Form\";}const FormImpl=/*#__PURE__*/React.forwardRef((_ref6,forwardedRef)=>{let{reloadDocument,replace,state,method=defaultMethod,action,onSubmit,submit,relative,preventScrollReset}=_ref6,props=_objectWithoutPropertiesLoose(_ref6,_excluded3);let formMethod=method.toLowerCase()===\"get\"?\"get\":\"post\";let formAction=useFormAction(action,{relative});let submitHandler=event=>{onSubmit&&onSubmit(event);if(event.defaultPrevented)return;event.preventDefault();let submitter=event.nativeEvent.submitter;let submitMethod=(submitter==null?void 0:submitter.getAttribute(\"formmethod\"))||method;submit(submitter||event.currentTarget,{method:submitMethod,replace,state,relative,preventScrollReset});};return/*#__PURE__*/React.createElement(\"form\",_extends({ref:forwardedRef,method:formMethod,action:formAction,onSubmit:reloadDocument?onSubmit:submitHandler},props));});if(process.env.NODE_ENV!==\"production\"){FormImpl.displayName=\"FormImpl\";}/**\n * This component will emulate the browser's scroll restoration on location\n * changes.\n */function ScrollRestoration(_ref7){let{getKey,storageKey}=_ref7;useScrollRestoration({getKey,storageKey});return null;}if(process.env.NODE_ENV!==\"production\"){ScrollRestoration.displayName=\"ScrollRestoration\";}//#endregion\n////////////////////////////////////////////////////////////////////////////////\n//#region Hooks\n////////////////////////////////////////////////////////////////////////////////\nvar DataRouterHook;(function(DataRouterHook){DataRouterHook[\"UseScrollRestoration\"]=\"useScrollRestoration\";DataRouterHook[\"UseSubmit\"]=\"useSubmit\";DataRouterHook[\"UseSubmitFetcher\"]=\"useSubmitFetcher\";DataRouterHook[\"UseFetcher\"]=\"useFetcher\";})(DataRouterHook||(DataRouterHook={}));var DataRouterStateHook;(function(DataRouterStateHook){DataRouterStateHook[\"UseFetchers\"]=\"useFetchers\";DataRouterStateHook[\"UseScrollRestoration\"]=\"useScrollRestoration\";})(DataRouterStateHook||(DataRouterStateHook={}));function getDataRouterConsoleError(hookName){return hookName+\" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";}function useDataRouterContext(hookName){let ctx=React.useContext(UNSAFE_DataRouterContext);!ctx?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,getDataRouterConsoleError(hookName)):UNSAFE_invariant(false):void 0;return ctx;}function useDataRouterState(hookName){let state=React.useContext(UNSAFE_DataRouterStateContext);!state?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,getDataRouterConsoleError(hookName)):UNSAFE_invariant(false):void 0;return state;}/**\n * Handles the click behavior for router `<Link>` components. This is useful if\n * you need to create custom `<Link>` components with the same click behavior we\n * use in our exported `<Link>`.\n */function useLinkClickHandler(to,_temp){let{target,replace:replaceProp,state,preventScrollReset,relative}=_temp===void 0?{}:_temp;let navigate=useNavigate();let location=useLocation();let path=useResolvedPath(to,{relative});return React.useCallback(event=>{if(shouldProcessLinkClick(event,target)){event.preventDefault();// If the URL hasn't changed, a regular <a> will do a replace instead of\n// a push, so do the same here unless the replace prop is explicitly set\nlet replace=replaceProp!==undefined?replaceProp:createPath(location)===createPath(path);navigate(to,{replace,state,preventScrollReset,relative});}},[location,navigate,path,replaceProp,state,target,to,preventScrollReset,relative]);}/**\n * A convenient wrapper for reading and writing search parameters via the\n * URLSearchParams interface.\n */function useSearchParams(defaultInit){process.env.NODE_ENV!==\"production\"?UNSAFE_warning(typeof URLSearchParams!==\"undefined\",\"You cannot use the `useSearchParams` hook in a browser that does not \"+\"support the URLSearchParams API. If you need to support Internet \"+\"Explorer 11, we recommend you load a polyfill such as \"+\"https://github.com/ungap/url-search-params\\n\\n\"+\"If you're unsure how to load polyfills, we recommend you check out \"+\"https://polyfill.io/v3/ which provides some recommendations about how \"+\"to load polyfills only for users that need them, instead of for every \"+\"user.\"):void 0;let defaultSearchParamsRef=React.useRef(createSearchParams(defaultInit));let hasSetSearchParamsRef=React.useRef(false);let location=useLocation();let searchParams=React.useMemo(()=>// Only merge in the defaults if we haven't yet called setSearchParams.\n// Once we call that we want those to take precedence, otherwise you can't\n// remove a param with setSearchParams({}) if it has an initial value\ngetSearchParamsForLocation(location.search,hasSetSearchParamsRef.current?null:defaultSearchParamsRef.current),[location.search]);let navigate=useNavigate();let setSearchParams=React.useCallback((nextInit,navigateOptions)=>{const newSearchParams=createSearchParams(typeof nextInit===\"function\"?nextInit(searchParams):nextInit);hasSetSearchParamsRef.current=true;navigate(\"?\"+newSearchParams,navigateOptions);},[navigate,searchParams]);return[searchParams,setSearchParams];}function validateClientSideSubmission(){if(typeof document===\"undefined\"){throw new Error(\"You are calling submit during the server render. \"+\"Try calling submit within a `useEffect` or callback instead.\");}}/**\n * Returns a function that may be used to programmatically submit a form (or\n * some arbitrary data) to the server.\n */function useSubmit(){let{router}=useDataRouterContext(DataRouterHook.UseSubmit);let{basename}=React.useContext(UNSAFE_NavigationContext);let currentRouteId=UNSAFE_useRouteId();return React.useCallback(function(target,options){if(options===void 0){options={};}validateClientSideSubmission();let{action,method,encType,formData,body}=getFormSubmissionInfo(target,basename);router.navigate(options.action||action,{preventScrollReset:options.preventScrollReset,formData,body,formMethod:options.method||method,formEncType:options.encType||encType,replace:options.replace,state:options.state,fromRouteId:currentRouteId});},[router,basename,currentRouteId]);}/**\n * Returns the implementation for fetcher.submit\n */function useSubmitFetcher(fetcherKey,fetcherRouteId){let{router}=useDataRouterContext(DataRouterHook.UseSubmitFetcher);let{basename}=React.useContext(UNSAFE_NavigationContext);return React.useCallback(function(target,options){if(options===void 0){options={};}validateClientSideSubmission();let{action,method,encType,formData,body}=getFormSubmissionInfo(target,basename);!(fetcherRouteId!=null)?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,\"No routeId available for useFetcher()\"):UNSAFE_invariant(false):void 0;router.fetch(fetcherKey,fetcherRouteId,options.action||action,{preventScrollReset:options.preventScrollReset,formData,body,formMethod:options.method||method,formEncType:options.encType||encType});},[router,basename,fetcherKey,fetcherRouteId]);}// v7: Eventually we should deprecate this entirely in favor of using the\n// router method directly?\nfunction useFormAction(action,_temp2){let{relative}=_temp2===void 0?{}:_temp2;let{basename}=React.useContext(UNSAFE_NavigationContext);let routeContext=React.useContext(UNSAFE_RouteContext);!routeContext?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,\"useFormAction must be used inside a RouteContext\"):UNSAFE_invariant(false):void 0;let[match]=routeContext.matches.slice(-1);// Shallow clone path so we can modify it below, otherwise we modify the\n// object referenced by useMemo inside useResolvedPath\nlet path=_extends({},useResolvedPath(action?action:\".\",{relative}));// Previously we set the default action to \".\". The problem with this is that\n// `useResolvedPath(\".\")` excludes search params of the resolved URL. This is\n// the intended behavior of when \".\" is specifically provided as\n// the form action, but inconsistent w/ browsers when the action is omitted.\n// https://github.com/remix-run/remix/issues/927\nlet location=useLocation();if(action==null){// Safe to write to this directly here since if action was undefined, we\n// would have called useResolvedPath(\".\") which will never include a search\npath.search=location.search;// When grabbing search params from the URL, remove the automatically\n// inserted ?index param so we match the useResolvedPath search behavior\n// which would not include ?index\nif(match.route.index){let params=new URLSearchParams(path.search);params.delete(\"index\");path.search=params.toString()?\"?\"+params.toString():\"\";}}if((!action||action===\".\")&&match.route.index){path.search=path.search?path.search.replace(/^\\?/,\"?index&\"):\"?index\";}// If we're operating within a basename, prepend it to the pathname prior\n// to creating the form action.  If this is a root navigation, then just use\n// the raw basename which allows the basename to have full control over the\n// presence of a trailing slash on root actions\nif(basename!==\"/\"){path.pathname=path.pathname===\"/\"?basename:joinPaths([basename,path.pathname]);}return createPath(path);}function createFetcherForm(fetcherKey,routeId){let FetcherForm=/*#__PURE__*/React.forwardRef((props,ref)=>{let submit=useSubmitFetcher(fetcherKey,routeId);return/*#__PURE__*/React.createElement(FormImpl,_extends({},props,{ref:ref,submit:submit}));});if(process.env.NODE_ENV!==\"production\"){FetcherForm.displayName=\"fetcher.Form\";}return FetcherForm;}let fetcherId=0;/**\n * Interacts with route loaders and actions without causing a navigation. Great\n * for any interaction that stays on the same page.\n */function useFetcher(){var _route$matches;let{router}=useDataRouterContext(DataRouterHook.UseFetcher);let route=React.useContext(UNSAFE_RouteContext);!route?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,\"useFetcher must be used inside a RouteContext\"):UNSAFE_invariant(false):void 0;let routeId=(_route$matches=route.matches[route.matches.length-1])==null?void 0:_route$matches.route.id;!(routeId!=null)?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,\"useFetcher can only be used on routes that contain a unique \\\"id\\\"\"):UNSAFE_invariant(false):void 0;let[fetcherKey]=React.useState(()=>String(++fetcherId));let[Form]=React.useState(()=>{!routeId?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,\"No routeId available for fetcher.Form()\"):UNSAFE_invariant(false):void 0;return createFetcherForm(fetcherKey,routeId);});let[load]=React.useState(()=>href=>{!router?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,\"No router available for fetcher.load()\"):UNSAFE_invariant(false):void 0;!routeId?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,\"No routeId available for fetcher.load()\"):UNSAFE_invariant(false):void 0;router.fetch(fetcherKey,routeId,href);});let submit=useSubmitFetcher(fetcherKey,routeId);let fetcher=router.getFetcher(fetcherKey);let fetcherWithComponents=React.useMemo(()=>_extends({Form,submit,load},fetcher),[fetcher,Form,submit,load]);React.useEffect(()=>{// Is this busted when the React team gets real weird and calls effects\n// twice on mount?  We really just need to garbage collect here when this\n// fetcher is no longer around.\nreturn()=>{if(!router){console.warn(\"No router available to clean up from useFetcher()\");return;}router.deleteFetcher(fetcherKey);};},[router,fetcherKey]);return fetcherWithComponents;}/**\n * Provides all fetchers currently on the page. Useful for layouts and parent\n * routes that need to provide pending/optimistic UI regarding the fetch.\n */function useFetchers(){let state=useDataRouterState(DataRouterStateHook.UseFetchers);return[...state.fetchers.values()];}const SCROLL_RESTORATION_STORAGE_KEY=\"react-router-scroll-positions\";let savedScrollPositions={};/**\n * When rendered inside a RouterProvider, will restore scroll positions on navigations\n */function useScrollRestoration(_temp3){let{getKey,storageKey}=_temp3===void 0?{}:_temp3;let{router}=useDataRouterContext(DataRouterHook.UseScrollRestoration);let{restoreScrollPosition,preventScrollReset}=useDataRouterState(DataRouterStateHook.UseScrollRestoration);let{basename}=React.useContext(UNSAFE_NavigationContext);let location=useLocation();let matches=useMatches();let navigation=useNavigation();// Trigger manual scroll restoration while we're active\nReact.useEffect(()=>{window.history.scrollRestoration=\"manual\";return()=>{window.history.scrollRestoration=\"auto\";};},[]);// Save positions on pagehide\nusePageHide(React.useCallback(()=>{if(navigation.state===\"idle\"){let key=(getKey?getKey(location,matches):null)||location.key;savedScrollPositions[key]=window.scrollY;}sessionStorage.setItem(storageKey||SCROLL_RESTORATION_STORAGE_KEY,JSON.stringify(savedScrollPositions));window.history.scrollRestoration=\"auto\";},[storageKey,getKey,navigation.state,location,matches]));// Read in any saved scroll locations\nif(typeof document!==\"undefined\"){// eslint-disable-next-line react-hooks/rules-of-hooks\nReact.useLayoutEffect(()=>{try{let sessionPositions=sessionStorage.getItem(storageKey||SCROLL_RESTORATION_STORAGE_KEY);if(sessionPositions){savedScrollPositions=JSON.parse(sessionPositions);}}catch(e){// no-op, use default empty object\n}},[storageKey]);// Enable scroll restoration in the router\n// eslint-disable-next-line react-hooks/rules-of-hooks\nReact.useLayoutEffect(()=>{let getKeyWithoutBasename=getKey&&basename!==\"/\"?(location,matches)=>getKey(// Strip the basename to match useLocation()\n_extends({},location,{pathname:stripBasename(location.pathname,basename)||location.pathname}),matches):getKey;let disableScrollRestoration=router==null?void 0:router.enableScrollRestoration(savedScrollPositions,()=>window.scrollY,getKeyWithoutBasename);return()=>disableScrollRestoration&&disableScrollRestoration();},[router,basename,getKey]);// Restore scrolling when state.restoreScrollPosition changes\n// eslint-disable-next-line react-hooks/rules-of-hooks\nReact.useLayoutEffect(()=>{// Explicit false means don't do anything (used for submissions)\nif(restoreScrollPosition===false){return;}// been here before, scroll to it\nif(typeof restoreScrollPosition===\"number\"){window.scrollTo(0,restoreScrollPosition);return;}// try to scroll to the hash\nif(location.hash){let el=document.getElementById(decodeURIComponent(location.hash.slice(1)));if(el){el.scrollIntoView();return;}}// Don't reset if this navigation opted out\nif(preventScrollReset===true){return;}// otherwise go to the top on new locations\nwindow.scrollTo(0,0);},[location,restoreScrollPosition,preventScrollReset]);}}/**\n * Setup a callback to be fired on the window's `beforeunload` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */function useBeforeUnload(callback,options){let{capture}=options||{};React.useEffect(()=>{let opts=capture!=null?{capture}:undefined;window.addEventListener(\"beforeunload\",callback,opts);return()=>{window.removeEventListener(\"beforeunload\",callback,opts);};},[callback,capture]);}/**\n * Setup a callback to be fired on the window's `pagehide` event. This is\n * useful for saving some data to `window.localStorage` just before the page\n * refreshes.  This event is better supported than beforeunload across browsers.\n *\n * Note: The `callback` argument should be a function created with\n * `React.useCallback()`.\n */function usePageHide(callback,options){let{capture}=options||{};React.useEffect(()=>{let opts=capture!=null?{capture}:undefined;window.addEventListener(\"pagehide\",callback,opts);return()=>{window.removeEventListener(\"pagehide\",callback,opts);};},[callback,capture]);}/**\n * Wrapper around useBlocker to show a window.confirm prompt to users instead\n * of building a custom UI with useBlocker.\n *\n * Warning: This has *a lot of rough edges* and behaves very differently (and\n * very incorrectly in some cases) across browsers if user click addition\n * back/forward navigations while the confirm is open.  Use at your own risk.\n */function usePrompt(_ref8){let{when,message}=_ref8;let blocker=unstable_useBlocker(when);React.useEffect(()=>{if(blocker.state===\"blocked\"){let proceed=window.confirm(message);if(proceed){// This timeout is needed to avoid a weird \"race\" on POP navigations\n// between the `window.history` revert navigation and the result of\n// `window.confirm`\nsetTimeout(blocker.proceed,0);}else{blocker.reset();}}},[blocker,message]);React.useEffect(()=>{if(blocker.state===\"blocked\"&&!when){blocker.reset();}},[blocker,when]);}//#endregion\nexport{BrowserRouter,Form,HashRouter,Link,NavLink,ScrollRestoration,useScrollRestoration as UNSAFE_useScrollRestoration,createBrowserRouter,createHashRouter,createSearchParams,HistoryRouter as unstable_HistoryRouter,usePrompt as unstable_usePrompt,useBeforeUnload,useFetcher,useFetchers,useFormAction,useLinkClickHandler,useSearchParams,useSubmit};","/**\n * React Router v6.15.0\n *\n * Copyright (c) Remix Software Inc.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE.md file in the root directory of this source tree.\n *\n * @license MIT\n */import*as React from'react';import{UNSAFE_invariant,joinPaths,matchPath,UNSAFE_getPathContributingMatches,UNSAFE_warning,resolveTo,parsePath,matchRoutes,Action,stripBasename,IDLE_BLOCKER,isRouteErrorResponse,createMemoryHistory,AbortedDeferredError,createRouter}from'@remix-run/router';export{AbortedDeferredError,Action as NavigationType,createPath,defer,generatePath,isRouteErrorResponse,json,matchPath,matchRoutes,parsePath,redirect,redirectDocument,resolvePath}from'@remix-run/router';function _extends(){_extends=Object.assign?Object.assign.bind():function(target){for(var i=1;i<arguments.length;i++){var source=arguments[i];for(var key in source){if(Object.prototype.hasOwnProperty.call(source,key)){target[key]=source[key];}}}return target;};return _extends.apply(this,arguments);}// Create react-specific types from the agnostic types in @remix-run/router to\n// export from react-router\nconst DataRouterContext=/*#__PURE__*/React.createContext(null);if(process.env.NODE_ENV!==\"production\"){DataRouterContext.displayName=\"DataRouter\";}const DataRouterStateContext=/*#__PURE__*/React.createContext(null);if(process.env.NODE_ENV!==\"production\"){DataRouterStateContext.displayName=\"DataRouterState\";}const AwaitContext=/*#__PURE__*/React.createContext(null);if(process.env.NODE_ENV!==\"production\"){AwaitContext.displayName=\"Await\";}/**\n * A Navigator is a \"location changer\"; it's how you get to different locations.\n *\n * Every history instance conforms to the Navigator interface, but the\n * distinction is useful primarily when it comes to the low-level <Router> API\n * where both the location and a navigator must be provided separately in order\n * to avoid \"tearing\" that may occur in a suspense-enabled app if the action\n * and/or location were to be read directly from the history instance.\n */const NavigationContext=/*#__PURE__*/React.createContext(null);if(process.env.NODE_ENV!==\"production\"){NavigationContext.displayName=\"Navigation\";}const LocationContext=/*#__PURE__*/React.createContext(null);if(process.env.NODE_ENV!==\"production\"){LocationContext.displayName=\"Location\";}const RouteContext=/*#__PURE__*/React.createContext({outlet:null,matches:[],isDataRoute:false});if(process.env.NODE_ENV!==\"production\"){RouteContext.displayName=\"Route\";}const RouteErrorContext=/*#__PURE__*/React.createContext(null);if(process.env.NODE_ENV!==\"production\"){RouteErrorContext.displayName=\"RouteError\";}/**\n * Returns the full href for the given \"to\" value. This is useful for building\n * custom links that are also accessible and preserve right-click behavior.\n *\n * @see https://reactrouter.com/hooks/use-href\n */function useHref(to,_temp){let{relative}=_temp===void 0?{}:_temp;!useInRouterContext()?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,// TODO: This error is probably because they somehow have 2 versions of the\n// router loaded. We can help them understand how to avoid that.\n\"useHref() may be used only in the context of a <Router> component.\"):UNSAFE_invariant(false):void 0;let{basename,navigator}=React.useContext(NavigationContext);let{hash,pathname,search}=useResolvedPath(to,{relative});let joinedPathname=pathname;// If we're operating within a basename, prepend it to the pathname prior\n// to creating the href.  If this is a root navigation, then just use the raw\n// basename which allows the basename to have full control over the presence\n// of a trailing slash on root links\nif(basename!==\"/\"){joinedPathname=pathname===\"/\"?basename:joinPaths([basename,pathname]);}return navigator.createHref({pathname:joinedPathname,search,hash});}/**\n * Returns true if this component is a descendant of a <Router>.\n *\n * @see https://reactrouter.com/hooks/use-in-router-context\n */function useInRouterContext(){return React.useContext(LocationContext)!=null;}/**\n * Returns the current location object, which represents the current URL in web\n * browsers.\n *\n * Note: If you're using this it may mean you're doing some of your own\n * \"routing\" in your app, and we'd like to know what your use case is. We may\n * be able to provide something higher-level to better suit your needs.\n *\n * @see https://reactrouter.com/hooks/use-location\n */function useLocation(){!useInRouterContext()?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,// TODO: This error is probably because they somehow have 2 versions of the\n// router loaded. We can help them understand how to avoid that.\n\"useLocation() may be used only in the context of a <Router> component.\"):UNSAFE_invariant(false):void 0;return React.useContext(LocationContext).location;}/**\n * Returns the current navigation action which describes how the router came to\n * the current location, either by a pop, push, or replace on the history stack.\n *\n * @see https://reactrouter.com/hooks/use-navigation-type\n */function useNavigationType(){return React.useContext(LocationContext).navigationType;}/**\n * Returns a PathMatch object if the given pattern matches the current URL.\n * This is useful for components that need to know \"active\" state, e.g.\n * <NavLink>.\n *\n * @see https://reactrouter.com/hooks/use-match\n */function useMatch(pattern){!useInRouterContext()?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,// TODO: This error is probably because they somehow have 2 versions of the\n// router loaded. We can help them understand how to avoid that.\n\"useMatch() may be used only in the context of a <Router> component.\"):UNSAFE_invariant(false):void 0;let{pathname}=useLocation();return React.useMemo(()=>matchPath(pattern,pathname),[pathname,pattern]);}/**\n * The interface for the navigate() function returned from useNavigate().\n */const navigateEffectWarning=\"You should call navigate() in a React.useEffect(), not when \"+\"your component is first rendered.\";// Mute warnings for calls to useNavigate in SSR environments\nfunction useIsomorphicLayoutEffect(cb){let isStatic=React.useContext(NavigationContext).static;if(!isStatic){// We should be able to get rid of this once react 18.3 is released\n// See: https://github.com/facebook/react/pull/26395\n// eslint-disable-next-line react-hooks/rules-of-hooks\nReact.useLayoutEffect(cb);}}/**\n * Returns an imperative method for changing the location. Used by <Link>s, but\n * may also be used by other elements to change the location.\n *\n * @see https://reactrouter.com/hooks/use-navigate\n */function useNavigate(){let{isDataRoute}=React.useContext(RouteContext);// Conditional usage is OK here because the usage of a data router is static\n// eslint-disable-next-line react-hooks/rules-of-hooks\nreturn isDataRoute?useNavigateStable():useNavigateUnstable();}function useNavigateUnstable(){!useInRouterContext()?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,// TODO: This error is probably because they somehow have 2 versions of the\n// router loaded. We can help them understand how to avoid that.\n\"useNavigate() may be used only in the context of a <Router> component.\"):UNSAFE_invariant(false):void 0;let dataRouterContext=React.useContext(DataRouterContext);let{basename,navigator}=React.useContext(NavigationContext);let{matches}=React.useContext(RouteContext);let{pathname:locationPathname}=useLocation();let routePathnamesJson=JSON.stringify(UNSAFE_getPathContributingMatches(matches).map(match=>match.pathnameBase));let activeRef=React.useRef(false);useIsomorphicLayoutEffect(()=>{activeRef.current=true;});let navigate=React.useCallback(function(to,options){if(options===void 0){options={};}process.env.NODE_ENV!==\"production\"?UNSAFE_warning(activeRef.current,navigateEffectWarning):void 0;// Short circuit here since if this happens on first render the navigate\n// is useless because we haven't wired up our history listener yet\nif(!activeRef.current)return;if(typeof to===\"number\"){navigator.go(to);return;}let path=resolveTo(to,JSON.parse(routePathnamesJson),locationPathname,options.relative===\"path\");// If we're operating within a basename, prepend it to the pathname prior\n// to handing off to history (but only if we're not in a data router,\n// otherwise it'll prepend the basename inside of the router).\n// If this is a root navigation, then we navigate to the raw basename\n// which allows the basename to have full control over the presence of a\n// trailing slash on root links\nif(dataRouterContext==null&&basename!==\"/\"){path.pathname=path.pathname===\"/\"?basename:joinPaths([basename,path.pathname]);}(!!options.replace?navigator.replace:navigator.push)(path,options.state,options);},[basename,navigator,routePathnamesJson,locationPathname,dataRouterContext]);return navigate;}const OutletContext=/*#__PURE__*/React.createContext(null);/**\n * Returns the context (if provided) for the child route at this level of the route\n * hierarchy.\n * @see https://reactrouter.com/hooks/use-outlet-context\n */function useOutletContext(){return React.useContext(OutletContext);}/**\n * Returns the element for the child route at this level of the route\n * hierarchy. Used internally by <Outlet> to render child routes.\n *\n * @see https://reactrouter.com/hooks/use-outlet\n */function useOutlet(context){let outlet=React.useContext(RouteContext).outlet;if(outlet){return/*#__PURE__*/React.createElement(OutletContext.Provider,{value:context},outlet);}return outlet;}/**\n * Returns an object of key/value pairs of the dynamic params from the current\n * URL that were matched by the route path.\n *\n * @see https://reactrouter.com/hooks/use-params\n */function useParams(){let{matches}=React.useContext(RouteContext);let routeMatch=matches[matches.length-1];return routeMatch?routeMatch.params:{};}/**\n * Resolves the pathname of the given `to` value against the current location.\n *\n * @see https://reactrouter.com/hooks/use-resolved-path\n */function useResolvedPath(to,_temp2){let{relative}=_temp2===void 0?{}:_temp2;let{matches}=React.useContext(RouteContext);let{pathname:locationPathname}=useLocation();let routePathnamesJson=JSON.stringify(UNSAFE_getPathContributingMatches(matches).map(match=>match.pathnameBase));return React.useMemo(()=>resolveTo(to,JSON.parse(routePathnamesJson),locationPathname,relative===\"path\"),[to,routePathnamesJson,locationPathname,relative]);}/**\n * Returns the element of the route that matched the current location, prepared\n * with the correct context to render the remainder of the route tree. Route\n * elements in the tree must render an <Outlet> to render their child route's\n * element.\n *\n * @see https://reactrouter.com/hooks/use-routes\n */function useRoutes(routes,locationArg){return useRoutesImpl(routes,locationArg);}// Internal implementation with accept optional param for RouterProvider usage\nfunction useRoutesImpl(routes,locationArg,dataRouterState){!useInRouterContext()?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,// TODO: This error is probably because they somehow have 2 versions of the\n// router loaded. We can help them understand how to avoid that.\n\"useRoutes() may be used only in the context of a <Router> component.\"):UNSAFE_invariant(false):void 0;let{navigator}=React.useContext(NavigationContext);let{matches:parentMatches}=React.useContext(RouteContext);let routeMatch=parentMatches[parentMatches.length-1];let parentParams=routeMatch?routeMatch.params:{};let parentPathname=routeMatch?routeMatch.pathname:\"/\";let parentPathnameBase=routeMatch?routeMatch.pathnameBase:\"/\";let parentRoute=routeMatch&&routeMatch.route;if(process.env.NODE_ENV!==\"production\"){// You won't get a warning about 2 different <Routes> under a <Route>\n// without a trailing *, but this is a best-effort warning anyway since we\n// cannot even give the warning unless they land at the parent route.\n//\n// Example:\n//\n// <Routes>\n//   {/* This route path MUST end with /* because otherwise\n//       it will never match /blog/post/123 */}\n//   <Route path=\"blog\" element={<Blog />} />\n//   <Route path=\"blog/feed\" element={<BlogFeed />} />\n// </Routes>\n//\n// function Blog() {\n//   return (\n//     <Routes>\n//       <Route path=\"post/:id\" element={<Post />} />\n//     </Routes>\n//   );\n// }\nlet parentPath=parentRoute&&parentRoute.path||\"\";warningOnce(parentPathname,!parentRoute||parentPath.endsWith(\"*\"),\"You rendered descendant <Routes> (or called `useRoutes()`) at \"+(\"\\\"\"+parentPathname+\"\\\" (under <Route path=\\\"\"+parentPath+\"\\\">) but the \")+\"parent route path has no trailing \\\"*\\\". This means if you navigate \"+\"deeper, the parent won't match anymore and therefore the child \"+\"routes will never render.\\n\\n\"+(\"Please change the parent <Route path=\\\"\"+parentPath+\"\\\"> to <Route \")+(\"path=\\\"\"+(parentPath===\"/\"?\"*\":parentPath+\"/*\")+\"\\\">.\"));}let locationFromContext=useLocation();let location;if(locationArg){var _parsedLocationArg$pa;let parsedLocationArg=typeof locationArg===\"string\"?parsePath(locationArg):locationArg;!(parentPathnameBase===\"/\"||((_parsedLocationArg$pa=parsedLocationArg.pathname)==null?void 0:_parsedLocationArg$pa.startsWith(parentPathnameBase)))?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,\"When overriding the location using `<Routes location>` or `useRoutes(routes, location)`, \"+\"the location pathname must begin with the portion of the URL pathname that was \"+(\"matched by all parent routes. The current pathname base is \\\"\"+parentPathnameBase+\"\\\" \")+(\"but pathname \\\"\"+parsedLocationArg.pathname+\"\\\" was given in the `location` prop.\")):UNSAFE_invariant(false):void 0;location=parsedLocationArg;}else{location=locationFromContext;}let pathname=location.pathname||\"/\";let remainingPathname=parentPathnameBase===\"/\"?pathname:pathname.slice(parentPathnameBase.length)||\"/\";let matches=matchRoutes(routes,{pathname:remainingPathname});if(process.env.NODE_ENV!==\"production\"){process.env.NODE_ENV!==\"production\"?UNSAFE_warning(parentRoute||matches!=null,\"No routes matched location \\\"\"+location.pathname+location.search+location.hash+\"\\\" \"):void 0;process.env.NODE_ENV!==\"production\"?UNSAFE_warning(matches==null||matches[matches.length-1].route.element!==undefined||matches[matches.length-1].route.Component!==undefined,\"Matched leaf route at location \\\"\"+location.pathname+location.search+location.hash+\"\\\" \"+\"does not have an element or Component. This means it will render an <Outlet /> with a \"+\"null value by default resulting in an \\\"empty\\\" page.\"):void 0;}let renderedMatches=_renderMatches(matches&&matches.map(match=>Object.assign({},match,{params:Object.assign({},parentParams,match.params),pathname:joinPaths([parentPathnameBase,// Re-encode pathnames that were decoded inside matchRoutes\nnavigator.encodeLocation?navigator.encodeLocation(match.pathname).pathname:match.pathname]),pathnameBase:match.pathnameBase===\"/\"?parentPathnameBase:joinPaths([parentPathnameBase,// Re-encode pathnames that were decoded inside matchRoutes\nnavigator.encodeLocation?navigator.encodeLocation(match.pathnameBase).pathname:match.pathnameBase])})),parentMatches,dataRouterState);// When a user passes in a `locationArg`, the associated routes need to\n// be wrapped in a new `LocationContext.Provider` in order for `useLocation`\n// to use the scoped location instead of the global location.\nif(locationArg&&renderedMatches){return/*#__PURE__*/React.createElement(LocationContext.Provider,{value:{location:_extends({pathname:\"/\",search:\"\",hash:\"\",state:null,key:\"default\"},location),navigationType:Action.Pop}},renderedMatches);}return renderedMatches;}function DefaultErrorComponent(){let error=useRouteError();let message=isRouteErrorResponse(error)?error.status+\" \"+error.statusText:error instanceof Error?error.message:JSON.stringify(error);let stack=error instanceof Error?error.stack:null;let lightgrey=\"rgba(200,200,200, 0.5)\";let preStyles={padding:\"0.5rem\",backgroundColor:lightgrey};let codeStyles={padding:\"2px 4px\",backgroundColor:lightgrey};let devInfo=null;if(process.env.NODE_ENV!==\"production\"){console.error(\"Error handled by React Router default ErrorBoundary:\",error);devInfo=/*#__PURE__*/React.createElement(React.Fragment,null,/*#__PURE__*/React.createElement(\"p\",null,\"\\uD83D\\uDCBF Hey developer \\uD83D\\uDC4B\"),/*#__PURE__*/React.createElement(\"p\",null,\"You can provide a way better UX than this when your app throws errors by providing your own \",/*#__PURE__*/React.createElement(\"code\",{style:codeStyles},\"ErrorBoundary\"),\" or\",\" \",/*#__PURE__*/React.createElement(\"code\",{style:codeStyles},\"errorElement\"),\" prop on your route.\"));}return/*#__PURE__*/React.createElement(React.Fragment,null,/*#__PURE__*/React.createElement(\"h2\",null,\"Unexpected Application Error!\"),/*#__PURE__*/React.createElement(\"h3\",{style:{fontStyle:\"italic\"}},message),stack?/*#__PURE__*/React.createElement(\"pre\",{style:preStyles},stack):null,devInfo);}const defaultErrorElement=/*#__PURE__*/React.createElement(DefaultErrorComponent,null);class RenderErrorBoundary extends React.Component{constructor(props){super(props);this.state={location:props.location,revalidation:props.revalidation,error:props.error};}static getDerivedStateFromError(error){return{error:error};}static getDerivedStateFromProps(props,state){// When we get into an error state, the user will likely click \"back\" to the\n// previous page that didn't have an error. Because this wraps the entire\n// application, that will have no effect--the error page continues to display.\n// This gives us a mechanism to recover from the error when the location changes.\n//\n// Whether we're in an error state or not, we update the location in state\n// so that when we are in an error state, it gets reset when a new location\n// comes in and the user recovers from the error.\nif(state.location!==props.location||state.revalidation!==\"idle\"&&props.revalidation===\"idle\"){return{error:props.error,location:props.location,revalidation:props.revalidation};}// If we're not changing locations, preserve the location but still surface\n// any new errors that may come through. We retain the existing error, we do\n// this because the error provided from the app state may be cleared without\n// the location changing.\nreturn{error:props.error||state.error,location:state.location,revalidation:props.revalidation||state.revalidation};}componentDidCatch(error,errorInfo){console.error(\"React Router caught the following error during render\",error,errorInfo);}render(){return this.state.error?/*#__PURE__*/React.createElement(RouteContext.Provider,{value:this.props.routeContext},/*#__PURE__*/React.createElement(RouteErrorContext.Provider,{value:this.state.error,children:this.props.component})):this.props.children;}}function RenderedRoute(_ref){let{routeContext,match,children}=_ref;let dataRouterContext=React.useContext(DataRouterContext);// Track how deep we got in our render pass to emulate SSR componentDidCatch\n// in a DataStaticRouter\nif(dataRouterContext&&dataRouterContext.static&&dataRouterContext.staticContext&&(match.route.errorElement||match.route.ErrorBoundary)){dataRouterContext.staticContext._deepestRenderedBoundaryId=match.route.id;}return/*#__PURE__*/React.createElement(RouteContext.Provider,{value:routeContext},children);}function _renderMatches(matches,parentMatches,dataRouterState){var _dataRouterState2;if(parentMatches===void 0){parentMatches=[];}if(dataRouterState===void 0){dataRouterState=null;}if(matches==null){var _dataRouterState;if((_dataRouterState=dataRouterState)!=null&&_dataRouterState.errors){// Don't bail if we have data router errors so we can render them in the\n// boundary.  Use the pre-matched (or shimmed) matches\nmatches=dataRouterState.matches;}else{return null;}}let renderedMatches=matches;// If we have data errors, trim matches to the highest error boundary\nlet errors=(_dataRouterState2=dataRouterState)==null?void 0:_dataRouterState2.errors;if(errors!=null){let errorIndex=renderedMatches.findIndex(m=>m.route.id&&(errors==null?void 0:errors[m.route.id]));!(errorIndex>=0)?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,\"Could not find a matching route for errors on route IDs: \"+Object.keys(errors).join(\",\")):UNSAFE_invariant(false):void 0;renderedMatches=renderedMatches.slice(0,Math.min(renderedMatches.length,errorIndex+1));}return renderedMatches.reduceRight((outlet,match,index)=>{let error=match.route.id?errors==null?void 0:errors[match.route.id]:null;// Only data routers handle errors\nlet errorElement=null;if(dataRouterState){errorElement=match.route.errorElement||defaultErrorElement;}let matches=parentMatches.concat(renderedMatches.slice(0,index+1));let getChildren=()=>{let children;if(error){children=errorElement;}else if(match.route.Component){// Note: This is a de-optimized path since React won't re-use the\n// ReactElement since it's identity changes with each new\n// React.createElement call.  We keep this so folks can use\n// `<Route Component={...}>` in `<Routes>` but generally `Component`\n// usage is only advised in `RouterProvider` when we can convert it to\n// `element` ahead of time.\nchildren=/*#__PURE__*/React.createElement(match.route.Component,null);}else if(match.route.element){children=match.route.element;}else{children=outlet;}return/*#__PURE__*/React.createElement(RenderedRoute,{match:match,routeContext:{outlet,matches,isDataRoute:dataRouterState!=null},children:children});};// Only wrap in an error boundary within data router usages when we have an\n// ErrorBoundary/errorElement on this route.  Otherwise let it bubble up to\n// an ancestor ErrorBoundary/errorElement\nreturn dataRouterState&&(match.route.ErrorBoundary||match.route.errorElement||index===0)?/*#__PURE__*/React.createElement(RenderErrorBoundary,{location:dataRouterState.location,revalidation:dataRouterState.revalidation,component:errorElement,error:error,children:getChildren(),routeContext:{outlet:null,matches,isDataRoute:true}}):getChildren();},null);}var DataRouterHook=/*#__PURE__*/function(DataRouterHook){DataRouterHook[\"UseBlocker\"]=\"useBlocker\";DataRouterHook[\"UseRevalidator\"]=\"useRevalidator\";DataRouterHook[\"UseNavigateStable\"]=\"useNavigate\";return DataRouterHook;}(DataRouterHook||{});var DataRouterStateHook=/*#__PURE__*/function(DataRouterStateHook){DataRouterStateHook[\"UseBlocker\"]=\"useBlocker\";DataRouterStateHook[\"UseLoaderData\"]=\"useLoaderData\";DataRouterStateHook[\"UseActionData\"]=\"useActionData\";DataRouterStateHook[\"UseRouteError\"]=\"useRouteError\";DataRouterStateHook[\"UseNavigation\"]=\"useNavigation\";DataRouterStateHook[\"UseRouteLoaderData\"]=\"useRouteLoaderData\";DataRouterStateHook[\"UseMatches\"]=\"useMatches\";DataRouterStateHook[\"UseRevalidator\"]=\"useRevalidator\";DataRouterStateHook[\"UseNavigateStable\"]=\"useNavigate\";DataRouterStateHook[\"UseRouteId\"]=\"useRouteId\";return DataRouterStateHook;}(DataRouterStateHook||{});function getDataRouterConsoleError(hookName){return hookName+\" must be used within a data router.  See https://reactrouter.com/routers/picking-a-router.\";}function useDataRouterContext(hookName){let ctx=React.useContext(DataRouterContext);!ctx?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,getDataRouterConsoleError(hookName)):UNSAFE_invariant(false):void 0;return ctx;}function useDataRouterState(hookName){let state=React.useContext(DataRouterStateContext);!state?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,getDataRouterConsoleError(hookName)):UNSAFE_invariant(false):void 0;return state;}function useRouteContext(hookName){let route=React.useContext(RouteContext);!route?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,getDataRouterConsoleError(hookName)):UNSAFE_invariant(false):void 0;return route;}// Internal version with hookName-aware debugging\nfunction useCurrentRouteId(hookName){let route=useRouteContext(hookName);let thisRoute=route.matches[route.matches.length-1];!thisRoute.route.id?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,hookName+\" can only be used on routes that contain a unique \\\"id\\\"\"):UNSAFE_invariant(false):void 0;return thisRoute.route.id;}/**\n * Returns the ID for the nearest contextual route\n */function useRouteId(){return useCurrentRouteId(DataRouterStateHook.UseRouteId);}/**\n * Returns the current navigation, defaulting to an \"idle\" navigation when\n * no navigation is in progress\n */function useNavigation(){let state=useDataRouterState(DataRouterStateHook.UseNavigation);return state.navigation;}/**\n * Returns a revalidate function for manually triggering revalidation, as well\n * as the current state of any manual revalidations\n */function useRevalidator(){let dataRouterContext=useDataRouterContext(DataRouterHook.UseRevalidator);let state=useDataRouterState(DataRouterStateHook.UseRevalidator);return React.useMemo(()=>({revalidate:dataRouterContext.router.revalidate,state:state.revalidation}),[dataRouterContext.router.revalidate,state.revalidation]);}/**\n * Returns the active route matches, useful for accessing loaderData for\n * parent/child routes or the route \"handle\" property\n */function useMatches(){let{matches,loaderData}=useDataRouterState(DataRouterStateHook.UseMatches);return React.useMemo(()=>matches.map(match=>{let{pathname,params}=match;// Note: This structure matches that created by createUseMatchesMatch\n// in the @remix-run/router , so if you change this please also change\n// that :)  Eventually we'll DRY this up\nreturn{id:match.route.id,pathname,params,data:loaderData[match.route.id],handle:match.route.handle};}),[matches,loaderData]);}/**\n * Returns the loader data for the nearest ancestor Route loader\n */function useLoaderData(){let state=useDataRouterState(DataRouterStateHook.UseLoaderData);let routeId=useCurrentRouteId(DataRouterStateHook.UseLoaderData);if(state.errors&&state.errors[routeId]!=null){console.error(\"You cannot `useLoaderData` in an errorElement (routeId: \"+routeId+\")\");return undefined;}return state.loaderData[routeId];}/**\n * Returns the loaderData for the given routeId\n */function useRouteLoaderData(routeId){let state=useDataRouterState(DataRouterStateHook.UseRouteLoaderData);return state.loaderData[routeId];}/**\n * Returns the action data for the nearest ancestor Route action\n */function useActionData(){let state=useDataRouterState(DataRouterStateHook.UseActionData);let route=React.useContext(RouteContext);!route?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,\"useActionData must be used inside a RouteContext\"):UNSAFE_invariant(false):void 0;return Object.values((state==null?void 0:state.actionData)||{})[0];}/**\n * Returns the nearest ancestor Route error, which could be a loader/action\n * error or a render error.  This is intended to be called from your\n * ErrorBoundary/errorElement to display a proper error message.\n */function useRouteError(){var _state$errors;let error=React.useContext(RouteErrorContext);let state=useDataRouterState(DataRouterStateHook.UseRouteError);let routeId=useCurrentRouteId(DataRouterStateHook.UseRouteError);// If this was a render error, we put it in a RouteError context inside\n// of RenderErrorBoundary\nif(error){return error;}// Otherwise look for errors from our data router state\nreturn(_state$errors=state.errors)==null?void 0:_state$errors[routeId];}/**\n * Returns the happy-path data from the nearest ancestor <Await /> value\n */function useAsyncValue(){let value=React.useContext(AwaitContext);return value==null?void 0:value._data;}/**\n * Returns the error from the nearest ancestor <Await /> value\n */function useAsyncError(){let value=React.useContext(AwaitContext);return value==null?void 0:value._error;}let blockerId=0;/**\n * Allow the application to block navigations within the SPA and present the\n * user a confirmation dialog to confirm the navigation.  Mostly used to avoid\n * using half-filled form data.  This does not handle hard-reloads or\n * cross-origin navigations.\n */function useBlocker(shouldBlock){let{router,basename}=useDataRouterContext(DataRouterHook.UseBlocker);let state=useDataRouterState(DataRouterStateHook.UseBlocker);let[blockerKey,setBlockerKey]=React.useState(\"\");let blockerFunction=React.useCallback(arg=>{if(typeof shouldBlock!==\"function\"){return!!shouldBlock;}if(basename===\"/\"){return shouldBlock(arg);}// If they provided us a function and we've got an active basename, strip\n// it from the locations we expose to the user to match the behavior of\n// useLocation\nlet{currentLocation,nextLocation,historyAction}=arg;return shouldBlock({currentLocation:_extends({},currentLocation,{pathname:stripBasename(currentLocation.pathname,basename)||currentLocation.pathname}),nextLocation:_extends({},nextLocation,{pathname:stripBasename(nextLocation.pathname,basename)||nextLocation.pathname}),historyAction});},[basename,shouldBlock]);// This effect is in charge of blocker key assignment and deletion (which is\n// tightly coupled to the key)\nReact.useEffect(()=>{let key=String(++blockerId);setBlockerKey(key);return()=>router.deleteBlocker(key);},[router]);// This effect handles assigning the blockerFunction.  This is to handle\n// unstable blocker function identities, and happens only after the prior\n// effect so we don't get an orphaned blockerFunction in the router with a\n// key of \"\".  Until then we just have the IDLE_BLOCKER.\nReact.useEffect(()=>{if(blockerKey!==\"\"){router.getBlocker(blockerKey,blockerFunction);}},[router,blockerKey,blockerFunction]);// Prefer the blocker from `state` not `router.state` since DataRouterContext\n// is memoized so this ensures we update on blocker state updates\nreturn blockerKey&&state.blockers.has(blockerKey)?state.blockers.get(blockerKey):IDLE_BLOCKER;}/**\n * Stable version of useNavigate that is used when we are in the context of\n * a RouterProvider.\n */function useNavigateStable(){let{router}=useDataRouterContext(DataRouterHook.UseNavigateStable);let id=useCurrentRouteId(DataRouterStateHook.UseNavigateStable);let activeRef=React.useRef(false);useIsomorphicLayoutEffect(()=>{activeRef.current=true;});let navigate=React.useCallback(function(to,options){if(options===void 0){options={};}process.env.NODE_ENV!==\"production\"?UNSAFE_warning(activeRef.current,navigateEffectWarning):void 0;// Short circuit here since if this happens on first render the navigate\n// is useless because we haven't wired up our router subscriber yet\nif(!activeRef.current)return;if(typeof to===\"number\"){router.navigate(to);}else{router.navigate(to,_extends({fromRouteId:id},options));}},[router,id]);return navigate;}const alreadyWarned={};function warningOnce(key,cond,message){if(!cond&&!alreadyWarned[key]){alreadyWarned[key]=true;process.env.NODE_ENV!==\"production\"?UNSAFE_warning(false,message):void 0;}}/**\n  Webpack + React 17 fails to compile on any of the following because webpack\n  complains that `startTransition` doesn't exist in `React`:\n  * import { startTransition } from \"react\"\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React.startTransition(() => setState()) : setState()\n  * import * as React from from \"react\";\n    \"startTransition\" in React ? React[\"startTransition\"](() => setState()) : setState()\n\n  Moving it to a constant such as the following solves the Webpack/React 17 issue:\n  * import * as React from from \"react\";\n    const START_TRANSITION = \"startTransition\";\n    START_TRANSITION in React ? React[START_TRANSITION](() => setState()) : setState()\n\n  However, that introduces webpack/terser minification issues in production builds\n  in React 18 where minification/obfuscation ends up removing the call of\n  React.startTransition entirely from the first half of the ternary.  Grabbing\n  this exported reference once up front resolves that issue.\n\n  See https://github.com/remix-run/react-router/issues/10579\n*/const START_TRANSITION=\"startTransition\";const startTransitionImpl=React[START_TRANSITION];/**\n * Given a Remix Router instance, render the appropriate UI\n */function RouterProvider(_ref){let{fallbackElement,router,future}=_ref;// Need to use a layout effect here so we are subscribed early enough to\n// pick up on any render-driven redirects/navigations (useEffect/<Navigate>)\nlet[state,setStateImpl]=React.useState(router.state);let{v7_startTransition}=future||{};let setState=React.useCallback(newState=>{v7_startTransition&&startTransitionImpl?startTransitionImpl(()=>setStateImpl(newState)):setStateImpl(newState);},[setStateImpl,v7_startTransition]);React.useLayoutEffect(()=>router.subscribe(setState),[router,setState]);let navigator=React.useMemo(()=>{return{createHref:router.createHref,encodeLocation:router.encodeLocation,go:n=>router.navigate(n),push:(to,state,opts)=>router.navigate(to,{state,preventScrollReset:opts==null?void 0:opts.preventScrollReset}),replace:(to,state,opts)=>router.navigate(to,{replace:true,state,preventScrollReset:opts==null?void 0:opts.preventScrollReset})};},[router]);let basename=router.basename||\"/\";let dataRouterContext=React.useMemo(()=>({router,navigator,static:false,basename}),[router,navigator,basename]);// The fragment and {null} here are important!  We need them to keep React 18's\n// useId happy when we are server-rendering since we may have a <script> here\n// containing the hydrated server-side staticContext (from StaticRouterProvider).\n// useId relies on the component tree structure to generate deterministic id's\n// so we need to ensure it remains the same on the client even though\n// we don't need the <script> tag\nreturn/*#__PURE__*/React.createElement(React.Fragment,null,/*#__PURE__*/React.createElement(DataRouterContext.Provider,{value:dataRouterContext},/*#__PURE__*/React.createElement(DataRouterStateContext.Provider,{value:state},/*#__PURE__*/React.createElement(Router,{basename:basename,location:state.location,navigationType:state.historyAction,navigator:navigator},state.initialized?/*#__PURE__*/React.createElement(DataRoutes,{routes:router.routes,state:state}):fallbackElement))),null);}function DataRoutes(_ref2){let{routes,state}=_ref2;return useRoutesImpl(routes,undefined,state);}/**\n * A <Router> that stores all entries in memory.\n *\n * @see https://reactrouter.com/router-components/memory-router\n */function MemoryRouter(_ref3){let{basename,children,initialEntries,initialIndex,future}=_ref3;let historyRef=React.useRef();if(historyRef.current==null){historyRef.current=createMemoryHistory({initialEntries,initialIndex,v5Compat:true});}let history=historyRef.current;let[state,setStateImpl]=React.useState({action:history.action,location:history.location});let{v7_startTransition}=future||{};let setState=React.useCallback(newState=>{v7_startTransition&&startTransitionImpl?startTransitionImpl(()=>setStateImpl(newState)):setStateImpl(newState);},[setStateImpl,v7_startTransition]);React.useLayoutEffect(()=>history.listen(setState),[history,setState]);return/*#__PURE__*/React.createElement(Router,{basename:basename,children:children,location:state.location,navigationType:state.action,navigator:history});}/**\n * Changes the current location.\n *\n * Note: This API is mostly useful in React.Component subclasses that are not\n * able to use hooks. In functional components, we recommend you use the\n * `useNavigate` hook instead.\n *\n * @see https://reactrouter.com/components/navigate\n */function Navigate(_ref4){let{to,replace,state,relative}=_ref4;!useInRouterContext()?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,// TODO: This error is probably because they somehow have 2 versions of\n// the router loaded. We can help them understand how to avoid that.\n\"<Navigate> may be used only in the context of a <Router> component.\"):UNSAFE_invariant(false):void 0;process.env.NODE_ENV!==\"production\"?UNSAFE_warning(!React.useContext(NavigationContext).static,\"<Navigate> must not be used on the initial render in a <StaticRouter>. \"+\"This is a no-op, but you should modify your code so the <Navigate> is \"+\"only ever rendered in response to some user interaction or state change.\"):void 0;let{matches}=React.useContext(RouteContext);let{pathname:locationPathname}=useLocation();let navigate=useNavigate();// Resolve the path outside of the effect so that when effects run twice in\n// StrictMode they navigate to the same place\nlet path=resolveTo(to,UNSAFE_getPathContributingMatches(matches).map(match=>match.pathnameBase),locationPathname,relative===\"path\");let jsonPath=JSON.stringify(path);React.useEffect(()=>navigate(JSON.parse(jsonPath),{replace,state,relative}),[navigate,jsonPath,relative,replace,state]);return null;}/**\n * Renders the child route's element, if there is one.\n *\n * @see https://reactrouter.com/components/outlet\n */function Outlet(props){return useOutlet(props.context);}/**\n * Declares an element that should be rendered at a certain URL path.\n *\n * @see https://reactrouter.com/components/route\n */function Route(_props){process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,\"A <Route> is only ever to be used as the child of <Routes> element, \"+\"never rendered directly. Please wrap your <Route> in a <Routes>.\"):UNSAFE_invariant(false);}/**\n * Provides location context for the rest of the app.\n *\n * Note: You usually won't render a <Router> directly. Instead, you'll render a\n * router that is more specific to your environment such as a <BrowserRouter>\n * in web browsers or a <StaticRouter> for server rendering.\n *\n * @see https://reactrouter.com/router-components/router\n */function Router(_ref5){let{basename:basenameProp=\"/\",children=null,location:locationProp,navigationType=Action.Pop,navigator,static:staticProp=false}=_ref5;!!useInRouterContext()?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,\"You cannot render a <Router> inside another <Router>.\"+\" You should never have more than one in your app.\"):UNSAFE_invariant(false):void 0;// Preserve trailing slashes on basename, so we can let the user control\n// the enforcement of trailing slashes throughout the app\nlet basename=basenameProp.replace(/^\\/*/,\"/\");let navigationContext=React.useMemo(()=>({basename,navigator,static:staticProp}),[basename,navigator,staticProp]);if(typeof locationProp===\"string\"){locationProp=parsePath(locationProp);}let{pathname=\"/\",search=\"\",hash=\"\",state=null,key=\"default\"}=locationProp;let locationContext=React.useMemo(()=>{let trailingPathname=stripBasename(pathname,basename);if(trailingPathname==null){return null;}return{location:{pathname:trailingPathname,search,hash,state,key},navigationType};},[basename,pathname,search,hash,state,key,navigationType]);process.env.NODE_ENV!==\"production\"?UNSAFE_warning(locationContext!=null,\"<Router basename=\\\"\"+basename+\"\\\"> is not able to match the URL \"+(\"\\\"\"+pathname+search+hash+\"\\\" because it does not start with the \")+\"basename, so the <Router> won't render anything.\"):void 0;if(locationContext==null){return null;}return/*#__PURE__*/React.createElement(NavigationContext.Provider,{value:navigationContext},/*#__PURE__*/React.createElement(LocationContext.Provider,{children:children,value:locationContext}));}/**\n * A container for a nested tree of <Route> elements that renders the branch\n * that best matches the current location.\n *\n * @see https://reactrouter.com/components/routes\n */function Routes(_ref6){let{children,location}=_ref6;return useRoutes(createRoutesFromChildren(children),location);}/**\n * Component to use for rendering lazily loaded data from returning defer()\n * in a loader function\n */function Await(_ref7){let{children,errorElement,resolve}=_ref7;return/*#__PURE__*/React.createElement(AwaitErrorBoundary,{resolve:resolve,errorElement:errorElement},/*#__PURE__*/React.createElement(ResolveAwait,null,children));}var AwaitRenderStatus=/*#__PURE__*/function(AwaitRenderStatus){AwaitRenderStatus[AwaitRenderStatus[\"pending\"]=0]=\"pending\";AwaitRenderStatus[AwaitRenderStatus[\"success\"]=1]=\"success\";AwaitRenderStatus[AwaitRenderStatus[\"error\"]=2]=\"error\";return AwaitRenderStatus;}(AwaitRenderStatus||{});const neverSettledPromise=new Promise(()=>{});class AwaitErrorBoundary extends React.Component{constructor(props){super(props);this.state={error:null};}static getDerivedStateFromError(error){return{error};}componentDidCatch(error,errorInfo){console.error(\"<Await> caught the following error during render\",error,errorInfo);}render(){let{children,errorElement,resolve}=this.props;let promise=null;let status=AwaitRenderStatus.pending;if(!(resolve instanceof Promise)){// Didn't get a promise - provide as a resolved promise\nstatus=AwaitRenderStatus.success;promise=Promise.resolve();Object.defineProperty(promise,\"_tracked\",{get:()=>true});Object.defineProperty(promise,\"_data\",{get:()=>resolve});}else if(this.state.error){// Caught a render error, provide it as a rejected promise\nstatus=AwaitRenderStatus.error;let renderError=this.state.error;promise=Promise.reject().catch(()=>{});// Avoid unhandled rejection warnings\nObject.defineProperty(promise,\"_tracked\",{get:()=>true});Object.defineProperty(promise,\"_error\",{get:()=>renderError});}else if(resolve._tracked){// Already tracked promise - check contents\npromise=resolve;status=promise._error!==undefined?AwaitRenderStatus.error:promise._data!==undefined?AwaitRenderStatus.success:AwaitRenderStatus.pending;}else{// Raw (untracked) promise - track it\nstatus=AwaitRenderStatus.pending;Object.defineProperty(resolve,\"_tracked\",{get:()=>true});promise=resolve.then(data=>Object.defineProperty(resolve,\"_data\",{get:()=>data}),error=>Object.defineProperty(resolve,\"_error\",{get:()=>error}));}if(status===AwaitRenderStatus.error&&promise._error instanceof AbortedDeferredError){// Freeze the UI by throwing a never resolved promise\nthrow neverSettledPromise;}if(status===AwaitRenderStatus.error&&!errorElement){// No errorElement, throw to the nearest route-level error boundary\nthrow promise._error;}if(status===AwaitRenderStatus.error){// Render via our errorElement\nreturn/*#__PURE__*/React.createElement(AwaitContext.Provider,{value:promise,children:errorElement});}if(status===AwaitRenderStatus.success){// Render children with resolved value\nreturn/*#__PURE__*/React.createElement(AwaitContext.Provider,{value:promise,children:children});}// Throw to the suspense boundary\nthrow promise;}}/**\n * @private\n * Indirection to leverage useAsyncValue for a render-prop API on <Await>\n */function ResolveAwait(_ref8){let{children}=_ref8;let data=useAsyncValue();let toRender=typeof children===\"function\"?children(data):children;return/*#__PURE__*/React.createElement(React.Fragment,null,toRender);}///////////////////////////////////////////////////////////////////////////////\n// UTILS\n///////////////////////////////////////////////////////////////////////////////\n/**\n * Creates a route config from a React \"children\" object, which is usually\n * either a `<Route>` element or an array of them. Used internally by\n * `<Routes>` to create a route config from its children.\n *\n * @see https://reactrouter.com/utils/create-routes-from-children\n */function createRoutesFromChildren(children,parentPath){if(parentPath===void 0){parentPath=[];}let routes=[];React.Children.forEach(children,(element,index)=>{if(!/*#__PURE__*/React.isValidElement(element)){// Ignore non-elements. This allows people to more easily inline\n// conditionals in their route config.\nreturn;}let treePath=[...parentPath,index];if(element.type===React.Fragment){// Transparently support React.Fragment and its children.\nroutes.push.apply(routes,createRoutesFromChildren(element.props.children,treePath));return;}!(element.type===Route)?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,\"[\"+(typeof element.type===\"string\"?element.type:element.type.name)+\"] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>\"):UNSAFE_invariant(false):void 0;!(!element.props.index||!element.props.children)?process.env.NODE_ENV!==\"production\"?UNSAFE_invariant(false,\"An index route cannot have child routes.\"):UNSAFE_invariant(false):void 0;let route={id:element.props.id||treePath.join(\"-\"),caseSensitive:element.props.caseSensitive,element:element.props.element,Component:element.props.Component,index:element.props.index,path:element.props.path,loader:element.props.loader,action:element.props.action,errorElement:element.props.errorElement,ErrorBoundary:element.props.ErrorBoundary,hasErrorBoundary:element.props.ErrorBoundary!=null||element.props.errorElement!=null,shouldRevalidate:element.props.shouldRevalidate,handle:element.props.handle,lazy:element.props.lazy};if(element.props.children){route.children=createRoutesFromChildren(element.props.children,treePath);}routes.push(route);});return routes;}/**\n * Renders the result of `matchRoutes()` into a React element.\n */function renderMatches(matches){return _renderMatches(matches);}function mapRouteProperties(route){let updates={// Note: this check also occurs in createRoutesFromChildren so update\n// there if you change this -- please and thank you!\nhasErrorBoundary:route.ErrorBoundary!=null||route.errorElement!=null};if(route.Component){if(process.env.NODE_ENV!==\"production\"){if(route.element){process.env.NODE_ENV!==\"production\"?UNSAFE_warning(false,\"You should not include both `Component` and `element` on your route - \"+\"`Component` will be used.\"):void 0;}}Object.assign(updates,{element:/*#__PURE__*/React.createElement(route.Component),Component:undefined});}if(route.ErrorBoundary){if(process.env.NODE_ENV!==\"production\"){if(route.errorElement){process.env.NODE_ENV!==\"production\"?UNSAFE_warning(false,\"You should not include both `ErrorBoundary` and `errorElement` on your route - \"+\"`ErrorBoundary` will be used.\"):void 0;}}Object.assign(updates,{errorElement:/*#__PURE__*/React.createElement(route.ErrorBoundary),ErrorBoundary:undefined});}return updates;}function createMemoryRouter(routes,opts){return createRouter({basename:opts==null?void 0:opts.basename,future:_extends({},opts==null?void 0:opts.future,{v7_prependBasename:true}),history:createMemoryHistory({initialEntries:opts==null?void 0:opts.initialEntries,initialIndex:opts==null?void 0:opts.initialIndex}),hydrationData:opts==null?void 0:opts.hydrationData,routes,mapRouteProperties}).initialize();}export{Await,MemoryRouter,Navigate,Outlet,Route,Router,RouterProvider,Routes,DataRouterContext as UNSAFE_DataRouterContext,DataRouterStateContext as UNSAFE_DataRouterStateContext,LocationContext as UNSAFE_LocationContext,NavigationContext as UNSAFE_NavigationContext,RouteContext as UNSAFE_RouteContext,mapRouteProperties as UNSAFE_mapRouteProperties,useRouteId as UNSAFE_useRouteId,useRoutesImpl as UNSAFE_useRoutesImpl,createMemoryRouter,createRoutesFromChildren,createRoutesFromChildren as createRoutesFromElements,renderMatches,useBlocker as unstable_useBlocker,useActionData,useAsyncError,useAsyncValue,useHref,useInRouterContext,useLoaderData,useLocation,useMatch,useMatches,useNavigate,useNavigation,useNavigationType,useOutlet,useOutletContext,useParams,useResolvedPath,useRevalidator,useRouteError,useRouteLoaderData,useRoutes};"],"names":["Action","ResultType","_extends","Object","assign","bind","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","apply","PopStateEventType","createBrowserHistory","options","getUrlBasedHistory","globalHistory","pathname","search","hash","location","createLocation","state","usr","to","createPath","createHashHistory","parsePath","substr","startsWith","base","document","querySelector","href","getAttribute","url","hashIndex","indexOf","slice","warning","charAt","JSON","stringify","invariant","value","message","Error","cond","console","warn","e","getHistoryState","index","idx","current","Math","random","toString","_ref","path","parsedPath","searchIndex","getLocation","createHref","validateLocation","window","defaultView","v5Compat","history","action","Pop","listener","getIndex","handlePop","nextIndex","delta","replaceState","createURL","origin","URL","listen","fn","addEventListener","removeEventListener","encodeLocation","push","Push","historyState","pushState","error","DOMException","name","replace","Replace","go","n","immutableRouteKeys","Set","convertRoutesToDataRoutes","routes","mapRouteProperties","parentPath","manifest","map","route","treePath","id","join","children","indexRoute","pathOrLayoutRoute","undefined","matchRoutes","locationArg","basename","stripBasename","branches","flattenRoutes","parentsMeta","flattenRoute","relativePath","meta","caseSensitive","childrenIndex","joinPaths","routesMeta","concat","score","computeScore","segments","split","initialScore","some","isSplat","filter","s","reduce","segment","paramRe","test","forEach","_route$path","includes","exploded","explodeOptionalSegments","first","rest","isOptional","endsWith","required","restExploded","result","subpath","rankRouteBranches","sort","a","b","compareIndexes","siblings","every","matches","matchRouteBranch","branch","matchedParams","matchedPathname","end","remainingPathname","match","matchPath","pattern","matcher","paramNames","compilePath","regexpSource","_","paramName","RegExp","pathnameBase","captureGroups","params","memo","splatValue","safelyDecodeURIComponent","decodeURIComponent","normalizePathname","safelyDecodeURI","decodeURI","toLowerCase","startIndex","nextChar","getInvalidPathError","char","field","dest","getPathContributingMatches","resolveTo","toArg","routePathnames","locationPathname","isPathRelative","from","isEmptyPath","toPathname","routePathnameIndex","toSegments","shift","resolvePath","fromPathname","resolvePathname","relativeSegments","pop","normalizeSearch","normalizeHash","hasExplicitTrailingSlash","hasCurrentTrailingSlash","paths","ErrorResponse","constructor","status","statusText","data","internal","isRouteErrorResponse","validMutationMethodsArr","validMutationMethods","validRequestMethodsArr","validRequestMethods","redirectStatusCodes","redirectPreserveMethodStatusCodes","IDLE_NAVIGATION","formMethod","formAction","formEncType","formData","json","text","IDLE_FETCHER","IDLE_BLOCKER","proceed","reset","ABSOLUTE_URL_REGEX","defaultMapRouteProperties","hasErrorBoundary","Boolean","createRouter","init","inFlightDataRoutes","router","pendingNavigationController","routerWindow","isBrowser","createElement","isServer","detectErrorBoundary","dataRoutes","future","v7_normalizeFormMethod","v7_prependBasename","unlistenHistory","subscribers","savedScrollPositions","getScrollRestorationKey","getScrollPosition","initialScrollRestored","hydrationData","initialMatches","initialErrors","getInternalRouterError","getShortCircuitMatches","initialized","m","lazy","loader","historyAction","navigation","restoreScrollPosition","preventScrollReset","revalidation","loaderData","actionData","errors","fetchers","Map","blockers","pendingAction","pendingPreventScrollReset","isUninterruptedRevalidation","isRevalidationRequired","cancelledDeferredRoutes","cancelledFetcherLoads","fetchControllers","incrementingLoadId","pendingNavigationLoadId","fetchReloadIds","fetchRedirectIds","fetchLoadMatches","activeDeferreds","blockerFunctions","ignoreNextHistoryUpdate","updateState","newState","subscriber","completeNavigation","_location$state","_location$state2","isActionReload","isMutationMethod","_isRedirect","keys","mergeLoaderData","size","k","set","getSavedScrollPosition","navigate","opts","normalizedPath","normalizeTo","fromRouteId","relative","submission","normalizeNavigateOptions","currentLocation","nextLocation","userReplace","blockerKey","shouldBlockNavigation","updateBlocker","startNavigation","pendingError","abort","startUninterruptedRevalidation","saveScrollPosition","getScrollKey","pendingActionData","routesToUse","loadingNavigation","overrideNavigation","notFoundMatches","cancelActiveDeferreds","isHashChangeOnly","AbortController","request","createClientSideRequest","signal","findNearestBoundary","actionOutput","handleAction","shortCircuited","pendingActionError","getLoadingNavigation","Request","handleLoaders","fetcherSubmission","interruptActiveLoads","getSubmittingNavigation","actionMatch","getTargetMatch","callLoaderOrAction","aborted","type","method","routeId","isRedirectResult","startRedirectNavigation","isErrorResult","boundaryMatch","isDeferredResult","activeSubmission","getSubmissionFromNavigation","matchesToLoad","revalidatingFetchers","getMatchesToLoad","updatedFetchers","markFetchRedirectsDone","rf","fetcher","get","revalidatingFetcher","getLoadingFetcher","has","abortFetcher","controller","abortPendingFetchRevalidations","f","results","loaderResults","fetcherResults","callLoadersAndMaybeResolveData","delete","redirect","findRedirect","fetcherKey","add","processLoaderData","deferredData","subscribe","done","didAbortFetchLoads","abortStaleFetchLoads","shouldUpdateFetchers","getFetcher","requestMatches","setFetcherError","getSubmittingFetcher","existingFetcher","abortController","fetchRequest","originatingLoadId","actionResult","doneFetcher","getDoneFetcher","loadingFetcher","isFetchActionRedirect","revalidationRequest","loadId","loadFetcher","staleKey","r","resolveDeferredData","_temp","revalidate","redirectLocation","_isFetchActionRedirect","isDocumentReload","reloadDocument","redirectHistoryAction","currentMatches","fetchersToLoad","Promise","all","resolveDeferredResults","deleteFetcher","markFetchersDone","doneKeys","landedId","yeetedKeys","deleteBlocker","newBlocker","blocker","_ref2","entries","Array","blockerFunction","predicate","cancelledRouteIds","dfd","cancel","createUseMatchesMatch","handle","y","initialize","enableScrollRestoration","positions","getPosition","getKey","fetch","handleFetcherAction","handleFetcherLoader","dispose","clear","getBlocker","_internalFetchControllers","_internalActiveDeferreds","_internalSetRoutes","newRoutes","Symbol","prependBasename","contextualMatches","activeRouteMatch","hasNakedIndexQuery","normalizeFormMethod","isFetcher","body","isValidMethod","searchParams","getInvalidBodyError","rawFormMethod","toUpperCase","stripHashFromPath","FormData","URLSearchParams","acc","_ref3","String","parse","convertFormDataToSearchParams","convertSearchParamsToFormData","append","values","currentUrl","nextUrl","navigationMatches","boundaryMatches","getLoaderMatchesUntilBoundary","boundaryId","findIndex","isNewLoader","currentLoaderData","currentMatch","isNew","isMissingData","currentRouteMatch","shouldRevalidateLoader","currentParams","nextParams","nextRouteMatch","defaultShouldRevalidate","isNewRouteInstance","fetcherMatches","fetcherMatch","shouldRevalidate","currentPath","loaderMatch","arg","routeChoice","loadLazyRouteModule","lazyRoute","routeToUpdate","routeUpdates","lazyRouteProperty","isPropertyStaticallyDefined","staticRouteValue","_result$init","_result$init2","runHandler","handler","reject","abortPromise","onReject","race","context","requestContext","resultType","isResponse","headers","isStaticRequest","protocol","isSameBasename","isRouteRequest","response","contentType","statusCode","isDeferredData","deferred","resolveData","Headers","foundError","loaderHeaders","newLoaderData","mergedLoaderData","eligibleMatches","reverse","find","_temp4","errorMessage","signals","isRevalidatingLoader","then","unwrap","unwrappedData","getAll","v","pathMatches","DataRouterHook","DataRouterStateHook","_objectWithoutPropertiesLoose","excluded","sourceKeys","defaultEncType","isHtmlElement","object","tagName","_formDataSupportsSubmitter","supportedFormEncTypes","getFormEncType","encType","_excluded","_excluded3","createBrowserRouter","parseHydrationData","UNSAFE_mapRouteProperties","createHashRouter","_window","__staticRouterHydrationData","deserializeErrors","serialized","val","__type","__subType","ErrorConstructor","stack","FormImpl","_ref6","forwardedRef","onSubmit","submit","props","useFormAction","_temp2","UNSAFE_NavigationContext","routeContext","UNSAFE_RouteContext","UNSAFE_invariant","useResolvedPath","useLocation","ref","event","defaultPrevented","preventDefault","submitter","nativeEvent","submitMethod","currentTarget","createRoutesFromChildren","element","Route","Component","errorElement","ErrorBoundary","AwaitRenderStatus","DataRouterContext","DataRouterStateContext","NavigationContext","LocationContext","RouteContext","outlet","isDataRoute","RouteErrorContext","useHref","useInRouterContext","navigator","joinedPathname","useIsomorphicLayoutEffect","cb","static","useNavigate","useNavigateStable","hookName","ctx","UseNavigateStable","useCurrentRouteId","activeRef","useNavigateUnstable","dataRouterContext","routePathnamesJson","UNSAFE_getPathContributingMatches","OutletContext","defaultErrorElement","useRouteError","_state$errors","useDataRouterState","UseRouteError","style","fontStyle","padding","backgroundColor","RenderErrorBoundary","getDerivedStateFromError","getDerivedStateFromProps","componentDidCatch","errorInfo","render","Provider","component","RenderedRoute","staticContext","_deepestRenderedBoundaryId","thisRoute","useRouteId","UseRouteId","useMatches","UseMatches","startTransitionImpl","RouterProvider","fallbackElement","setStateImpl","v7_startTransition","setState","Router","navigationType","DataRoutes","useRoutesImpl","dataRouterState","parentMatches","routeMatch","parentParams","parentPathnameBase","locationFromContext","_parsedLocationArg$pa","parsedLocationArg","renderedMatches","_renderMatches","_dataRouterState","_dataRouterState2","errorIndex","min","reduceRight","getChildren","Outlet","_props","_ref5","basenameProp","locationProp","staticProp","navigationContext","locationContext","trailingPathname","updates"],"mappings":"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"}