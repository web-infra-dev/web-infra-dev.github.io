(self.webpackChunk_modern_js_module_tools_docs=self.webpackChunk_modern_js_module_tools_docs||[]).push([["docs_zh_guide_basic_before-getting-started_md"],{74180:function(e,n,r){"use strict";r.r(n),r.d(n,{default:function(){return h}});var s,d=r("15169"),i=r("43932"),c=r("9880"),l=r("23169");function p(e){var n=Object.assign({h1:"h1",a:"a",h2:"h2",p:"p",strong:"strong",code:"code",pre:"pre",ul:"ul",li:"li",blockquote:"blockquote",div:"div",h3:"h3",h4:"h4"},(0,l.useMDXComponents)(),e.components);return(0,c.jsxs)(c.Fragment,{children:[(0,c.jsxs)(n.h1,{id:"开始之前",children:["开始之前",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#开始之前",children:"#"})]}),"\n",(0,c.jsxs)(n.h2,{id:"环境准备",children:["环境准备",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#环境准备",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["为了使用 Modern.js 模块工程解决方案，首先需要 ",(0,c.jsx)(n.a,{href:"https://nodejs.org/zh/",target:"_blank",rel:"noopener noreferrer",children:"NodeJS"}),"，我们推荐最新的",(0,c.jsx)(n.a,{href:"https://github.com/nodejs/Release",target:"_blank",rel:"noopener noreferrer",children:"长期维护版本"}),"，并确保 Node 版本大于等于 ",(0,c.jsx)(n.strong,{children:"14.18.0"}),"。因为非稳定的 NodeJS 时常有一些 Bug，你可以使用 ",(0,c.jsx)(n.a,{href:"https://github.com/coreybutler/nvm-windows",target:"_blank",rel:"noopener noreferrer",children:"nvm-windows"})," 和 ",(0,c.jsx)(n.a,{href:"https://github.com/nvm-sh/nvm",target:"_blank",rel:"noopener noreferrer",children:"nvm"}),"（Mac / Linux）安装，这样你就可以方便地切换到不同的 NodeJS 版本，这些版本可能会用于不同的项目。"]}),"\n",(0,c.jsxs)(n.h2,{id:"初识-npm",children:["初识 npm",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#初识-npm",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["当 NodeJS 被安装后，你不仅可以在命令行中访问 ",(0,c.jsx)(n.code,{children:"node"})," 可执行程序，同时你也可以执行 ",(0,c.jsx)(n.code,{children:"npm"})," 命令。"]}),"\n",(0,c.jsx)(n.p,{children:"npm 是 NodeJS 的标准软件包管理器。它一开始的用途是用于下载和管理 NodeJS 包的依赖关系，但后来它逐渐变成为一个用于前端 JavaScript 的工具。"}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsxs)(n.strong,{children:["如果你已经对 npm 和 npm 包的使用方式有所了解，那么可以直接跳到",(0,c.jsx)(n.a,{href:"/guide/basic/before-getting-started#npm-%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8",children:"「npm 包管理器」"}),"部分。"]})}),"\n",(0,c.jsxs)(n.h2,{id:"npm-包类型项目",children:["npm 包类型项目",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#npm-包类型项目",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["那么什么是 npm 包类型的项目呢？当我们在一个空的项目目录下执行 ",(0,c.jsx)(n.code,{children:"npm init"})," 命令的时候，它会在当前目录下面创建一个文件名为 ",(0,c.jsx)(n.code,{children:"package.json"})," 的 JSON 文件。在创建过程中，我们需要填写包括但不限于 npm 包的名称、版本号、描述等等内容，这些填写的内容都会在生成的 ",(0,c.jsx)(n.code,{children:"package.json"})," 文件中找到："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-json",children:'{\n  "name": "npm-demo",\n  "version": "1.0.0",\n  "description": "",\n  "main": "index.js",\n  "scripts": {\n    "test": "echo \\"Error: no test specified\\" && exit 1"\n  },\n  "author": "",\n  "license": "ISC"\n}\n'})}),"\n",(0,c.jsxs)(n.p,{children:["此时这个包含了初始化后的 ",(0,c.jsx)(n.code,{children:"package.json"})," 文件的项目就是一个 npm 包类型的项目，你可以执行 ",(0,c.jsx)(n.code,{children:"npm publish"})," 命令将这个项目发布到 ",(0,c.jsx)(n.a,{href:"https://www.npmjs.com/",target:"_blank",rel:"noopener noreferrer",children:"npm Registry"}),"。"]}),"\n",(0,c.jsxs)(n.p,{children:["npm Registry 是一个 ",(0,c.jsx)(n.a,{href:"https://docs.npmjs.com/about-the-public-npm-registry",target:"_blank",rel:"noopener noreferrer",children:"npm 包存储的地方"}),"，开发者们不仅可以将他们自己的 npm 包发布到 npm Registry，还可以通过 npm Registry 使用其他开发者发布的 npm 包。"]}),"\n",(0,c.jsx)(n.p,{children:"优质的 npm 包会有更多的人去使用，因为它不仅节省了很多代码实现的工作，同时也不容易让项目出现问题。"}),"\n",(0,c.jsxs)(n.h2,{id:"使用第三方-npm-包",children:["使用第三方 npm 包",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#使用第三方-npm-包",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["当要为初始化的项目增加第三方的 npm 包的时候，我们可以把这一过程叫做“为项目安装依赖”或是“为项目增加依赖”。在增加依赖之前，首先我们要特别了解一件事情 —— ",(0,c.jsx)(n.strong,{children:"npm 依赖的软件包类型"}),"："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:'"dependencies"'}),"：一种是你的应用程序在生产环境中需要的软件包。"]}),"\n",(0,c.jsxs)(n.li,{children:[(0,c.jsx)(n.code,{children:'"devDependencies"'}),"：另一种是仅在本地开发和测试中需要的软件包。","\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsx)(n.p,{children:"软件包可以理解为是第三方的 npm 包。"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["你可以通过执行 ",(0,c.jsx)(n.code,{children:"npm install npm-package-name"})," 或者 ",(0,c.jsx)(n.code,{children:"npm add npm-package-name"})," 的方式来安装在",(0,c.jsx)(n.strong,{children:"生产环境中需要的软件包"}),"，或者也可以在 ",(0,c.jsx)(n.code,{children:"package.json"})," 文件中手动的将需要安装的包和对应的",(0,c.jsx)(n.a,{href:"https://docs.npmjs.com/about-semantic-versioning",target:"_blank",rel:"noopener noreferrer",children:"语义化版本"}),"写在 ",(0,c.jsx)(n.code,{children:'"dependencies"'})," 里，并执行 ",(0,c.jsx)(n.code,{children:"npm install"})," 命令："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-json",children:'{\n  "name": "your-npm-project",\n  "dependencies": {\n    "npm-package-name": "0.1.0"\n  }\n}\n'})}),"\n",(0,c.jsxs)(n.p,{children:["同理，你也可以执行 ",(0,c.jsx)(n.code,{children:"npm install npm-package-name --save-dev"})," 或 ",(0,c.jsx)(n.code,{children:"npm add npm-package-name --save-dev"})," 的方式来安装",(0,c.jsx)(n.strong,{children:"仅在本地开发和测试中需要的软件包"}),"，或者也可以在 ",(0,c.jsx)(n.code,{children:"package.json"})," 文件中手动的将需要安装的包和对应的",(0,c.jsx)(n.a,{href:"https://docs.npmjs.com/about-semantic-versioning",target:"_blank",rel:"noopener noreferrer",children:"语义化版本"}),"写在 ",(0,c.jsx)(n.code,{children:'"devDependencies"'})," 里，并执行 ",(0,c.jsx)(n.code,{children:"npm install"})," 命令："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-json",children:'{\n  "name": "your-npm-project",\n  "devDependencies": {\n    "npm-package-name": "0.1.0"\n  }\n}\n'})}),"\n",(0,c.jsx)(n.p,{children:(0,c.jsxs)(n.strong,{children:["在安装或者使用第三方 npm 包的时候一定要确定它们的用途，以及通过区分它们的类型确定好它们应该放在 ",(0,c.jsx)(n.code,{children:'"dependencies"'})," 还是 ",(0,c.jsx)(n.code,{children:'"devDependencies"'})," 中。"]})}),"\n",(0,c.jsxs)(n.div,{className:"modern-directive tip",children:[(0,c.jsx)(n.div,{className:"modern-directive-title",children:"TIP"}),(0,c.jsx)(n.div,{className:"modern-directive-content",children:(0,c.jsxs)(n.p,{children:["一般来说，需要在源代码中使用到的包都属于 ",(0,c.jsx)(n.code,{children:"dependencies"})," 依赖。除非你通过打包的方式将依赖的代码输出到本地，那么这种情况可以将它作为 ",(0,c.jsx)(n.code,{children:"devDependencies"})," 依赖。\n"]})})]}),"\n",(0,c.jsxs)(n.h2,{id:"还需要了解的-npm-零碎知识",children:["还需要了解的 npm 零碎知识",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#还需要了解的-npm-零碎知识",children:"#"})]}),"\n",(0,c.jsxs)(n.h3,{id:"npm-包的程序入口",children:["npm 包的程序入口",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#npm-包的程序入口",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["在 ",(0,c.jsx)(n.code,{children:"package.json"})," 中存在一个 ",(0,c.jsx)(n.code,{children:'"main"'})," 属性，它对应的值是一个模块 ID，或者更直观的说是一个 NodeJS 文件路径，它是你程序的主要入口。"]}),"\n",(0,c.jsxs)(n.p,{children:["例如你的包名为 ",(0,c.jsx)(n.code,{children:"foo"}),"，并且用户安装了它，然后执行 ",(0,c.jsx)(n.code,{children:'require("foo")'})," 代码，那么 ",(0,c.jsx)(n.code,{children:"foo"})," 这个 npm 包的 ",(0,c.jsx)(n.code,{children:'"main"'})," 字段对应的文件将会被导出。"]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsxs)(n.strong,{children:["推荐在你的 npm 包里一定要设置 ",(0,c.jsx)(n.code,{children:'"main"'})," 字段"]}),"。如果没有设置 ",(0,c.jsx)(n.code,{children:'"main"'}),"，则默认入口为包的根目录下的 ",(0,c.jsx)(n.code,{children:"index.js"})," 文件。"]}),"\n",(0,c.jsxs)(n.p,{children:["除了需要设置 ",(0,c.jsx)(n.code,{children:'"main"'})," 属性以外，一般还会设置 ",(0,c.jsx)(n.code,{children:'"module"'})," 属性。它与 ",(0,c.jsx)(n.code,{children:'"main"'})," 属性的用途类似，它主要是用于在 webpack 场景下使用。webpack 在大多数情况下，会以 ",(0,c.jsx)(n.strong,{children:'"module" -> "main"'})," 这个顺序读取 npm 包的入口（文件）。"]}),"\n",(0,c.jsxs)(n.blockquote,{children:["\n",(0,c.jsxs)(n.p,{children:["想要了解关于 webpack 如何做这件事，可以查看这个",(0,c.jsx)(n.a,{href:"https://webpack.js.org/configuration/resolve/#resolvemainfields",target:"_blank",rel:"noopener noreferrer",children:"链接"}),"。"]}),"\n"]}),"\n",(0,c.jsxs)(n.h3,{id:"scripts",children:['"scripts"',(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#scripts",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsx)(n.code,{children:"package.json"})," 文件的 ",(0,c.jsx)(n.code,{children:'"scripts"'})," 属性支持一些内置的脚本和 npm 预设的生命周期事件，以及任意的脚本。"]}),"\n",(0,c.jsxs)(n.p,{children:["这些都可以通过运行 ",(0,c.jsx)(n.code,{children:"npm run-script <stage>"})," 或简称 ",(0,c.jsx)(n.code,{children:"npm run <stage>"})," 来执行。"]}),"\n",(0,c.jsxs)(n.p,{children:["名称匹配的",(0,c.jsx)(n.a,{href:"https://docs.npmjs.com/cli/v9/using-npm/scripts#pre--post-scripts",target:"_blank",rel:"noopener noreferrer",children:"前置命令和后置命令"}),"也会被运行（例如 ",(0,c.jsx)(n.code,{children:"premyscript"}),"、",(0,c.jsx)(n.code,{children:"myscript"}),"、",(0,c.jsx)(n.code,{children:"postmyscript"}),"）。"]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-json",children:'{\n  "scripts": {\n    "premyscript": "",\n    "myscript": "",\n    "postmyscript": ""\n  }\n}\n'})}),"\n",(0,c.jsxs)(n.p,{children:["当执行 ",(0,c.jsx)(n.code,{children:"npm run myscripts"})," 的时候，",(0,c.jsx)(n.code,{children:"premyscripts"})," 对应的脚本会在它之前执行，",(0,c.jsx)(n.code,{children:"postmyscripts"})," 对应的脚本会在它之后执行。"]}),"\n",(0,c.jsxs)(n.p,{children:["来自依赖的脚本命令可以用 ",(0,c.jsx)(n.code,{children:"npm explore <pkg> -- npm run <stage>"})," 运行。"]}),"\n",(0,c.jsx)(n.p,{children:"还有一些特殊的生命周期脚本（Life Scripts），只在某些情况下发生。这里介绍几个通常需要了解的情况。"}),"\n",(0,c.jsxs)(n.h4,{id:"npm-install",children:[(0,c.jsx)(n.code,{children:"npm install"}),(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#npm-install",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["当你运行 ",(0,c.jsx)(n.code,{children:"npm install -g <pkg-name>"})," 时，以下脚本会运行。"]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.code,{children:"preinstall"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.code,{children:"install"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.code,{children:"postinstall"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.code,{children:"prepublish"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.code,{children:"preprepare"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.code,{children:"prepare"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.code,{children:"postprepare"})}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["如果你的软件包根目录有一个 ",(0,c.jsx)(n.code,{children:"binding.gyp"})," 文件，而你没有定义 ",(0,c.jsx)(n.code,{children:"install"})," 或 ",(0,c.jsx)(n.code,{children:"preinstall"})," 脚本，那么 npm 将以 ",(0,c.jsx)(n.code,{children:"node-gyp rebuild"})," 作为默认的 install 命令，使用 ",(0,c.jsx)(n.a,{href:"https://github.com/nodejs/node-gyp",target:"_blank",rel:"noopener noreferrer",children:"node-gyp"})," 进行编译。"]}),"\n",(0,c.jsxs)(n.h4,{id:"npm-publish",children:[(0,c.jsx)(n.code,{children:"npm publish"}),(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#npm-publish",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"当发布项目的时候，执行该命令会触发以下脚本："}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.code,{children:"prepublishOnly"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.code,{children:"prepack"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.code,{children:"prepare"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.code,{children:"postpack"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.code,{children:"publish"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.code,{children:"postpublish"})}),"\n"]}),"\n",(0,c.jsxs)(n.p,{children:["当以 ",(0,c.jsx)(n.a,{href:"https://docs.npmjs.com/cli/v7/commands/npm-publish#dry-run",target:"_blank",rel:"noopener noreferrer",children:(0,c.jsx)(n.code,{children:"--dry-run"})})," 模式运行的时候，",(0,c.jsx)(n.code,{children:"prepare"})," 对应的脚本将不会执行。"]}),"\n",(0,c.jsxs)(n.h3,{id:"peerdependencies",children:["peerDependencies",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#peerdependencies",children:"#"})]}),"\n",(0,c.jsx)(n.p,{children:"在某些情况下，你的 npm 项目与它的宿主工具或者库之间存在某种兼容关系（例如一个 webpack 插件项目和 webpack），同时你的 npm 项目不想将宿主作为必要的依赖，这个时候通常说明你的项目可能是这个宿主工具或者库的插件。你的 npm 项目会对宿主包的版本有一定的要求，因为只有在特定的版本下才会暴露出 npm 项目所需要的 API。"}),"\n",(0,c.jsxs)(n.p,{children:["关于更多 ",(0,c.jsx)(n.code,{children:"peerDependencies"})," 的解释，可以通过下面的链接了解 npm、pnpm、Yarn 对于它的不同处理方式："]}),"\n",(0,c.jsxs)(n.ul,{children:["\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"https://docs.npmjs.com/cli/v9/configuring-npm/package-json#peerdependencies",target:"_blank",rel:"noopener noreferrer",children:"npm 对 peerDependencies 的解释"})}),"\n",(0,c.jsx)(n.li,{children:(0,c.jsx)(n.a,{href:"https://pnpm.io/feature-comparison",target:"_blank",rel:"noopener noreferrer",children:"pnpm vs npm VS Yarn"})}),"\n"]}),"\n",(0,c.jsxs)(n.h2,{id:"npm-包管理器",children:["npm 包管理器",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#npm-包管理器",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["除了 npm 这种标准的包管理器以外，目前主流的还有 ",(0,c.jsx)(n.strong,{children:"pnpm"})," 和 ",(0,c.jsx)(n.strong,{children:"Yarn"}),"，它们都是不错的 npm cli 替代品。"]}),"\n",(0,c.jsxs)(n.p,{children:["推荐使用 ",(0,c.jsx)(n.a,{href:"https://pnpm.io/installation",target:"_blank",rel:"noopener noreferrer",children:"pnpm"})," 来管理项目依赖，可以通过下面的方式安装它："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-bash",children:"npm install -g pnpm\n"})}),"\n",(0,c.jsxs)(n.h2,{id:"module-tools-配置文件",children:["Module Tools 配置文件",(0,c.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#module-tools-配置文件",children:"#"})]}),"\n",(0,c.jsxs)(n.p,{children:["通过",(0,c.jsx)(n.code,{children:"@modern-js/create"}),"创建的模块工程项目目录下提供了 Module Tools 的配置文件 —— ",(0,c.jsx)(n.code,{children:"modern.config.(j|t)s"}),"。但 ",(0,c.jsx)(n.code,{children:"modern.config"})," 配置文件不是必须存在的。"]}),"\n",(0,c.jsx)(n.p,{children:"默认情况下，生成的配置文件的内容如下："}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",meta:'title="modern.config.ts"',children:"import { moduleTools, defineConfig } from '@modern-js/module-tools';\n\nexport default defineConfig({\n  plugins: [moduleTools()],\n  buildPreset: 'npm-library',\n});\n"})}),"\n",(0,c.jsxs)(n.p,{children:[(0,c.jsxs)(n.strong,{children:["我们推荐使用 ",(0,c.jsx)(n.code,{children:"defineConfig"})," 函数"]}),"，不过并不强制使用它。因此你也可以在配置文件中直接返回一个对象："]}),"\n",(0,c.jsx)(n.pre,{children:(0,c.jsx)(n.code,{className:"language-ts",meta:'title="modern.config.ts"',children:"import { moduleTools } from '@modern-js/module-tools';\n\nexport default {\n  plugins: [moduleTools()],\n  buildPreset: 'npm-library',\n};\n"})})]})}(s=globalThis).__RSPRESS_PAGE_META||(s.__RSPRESS_PAGE_META={}),globalThis.__RSPRESS_PAGE_META["zh%2Fguide%2Fbasic%2Fbefore-getting-started.md"]={toc:[{text:"环境准备",id:"环境准备",depth:2},{text:"初识 npm",id:"初识-npm",depth:2},{text:"npm 包类型项目",id:"npm-包类型项目",depth:2},{text:"使用第三方 npm 包",id:"使用第三方-npm-包",depth:2},{text:"还需要了解的 npm 零碎知识",id:"还需要了解的-npm-零碎知识",depth:2},{text:"npm 包的程序入口",id:"npm-包的程序入口",depth:3},{text:'\\"scripts\\"',id:"scripts",depth:3},{text:"npm install",id:"npm-install",depth:4},{text:"npm publish",id:"npm-publish",depth:4},{text:"peerDependencies",id:"peerdependencies",depth:3},{text:"npm 包管理器",id:"npm-包管理器",depth:2},{text:"Module Tools 配置文件",id:"module-tools-配置文件",depth:2}],title:"开始之前",frontmatter:{sidebar_position:1}};var h=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=Object.assign({},(0,l.useMDXComponents)(),e.components).wrapper;return n?(0,c.jsx)(n,(0,i._)((0,d._)({},e),{children:(0,c.jsx)(p,(0,d._)({},e))})):p(e)}}}]);