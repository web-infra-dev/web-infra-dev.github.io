[{"id":306,"title":"命令","content":"#\n\nModern.js 内置了一些命令，可以帮助你快速启动开发服务器、构建生产环境代码等。\n\n通过本章节，你可以了解到 Modern.js 内置的命令有哪些，以及如何使用这些命令。\n\n\nmodern dev#\n\nmodern dev 命令用于启动一个本地开发服务器，对源代码进行开发环境编译。\n\n\n\n运行 modern dev 后，Modern.js 会监听源文件变化并进行模块热更新。\n\n\n\n\n编译部分页面#\n\n在多页面（MPA）项目中，可以添加 --entry 参数来指定编译其中的一个或多个页面。这样可以只编译项目中的部分代码，从而提升 dev 启动速度。\n\n比如执行 modern dev --entry，在命令行界面中会展示入口选择框：\n\n\n\n比如选择 foo 入口，那么只有 foo 入口相关的代码会进行编译，其他页面的代码将不会参与构建。\n\n\n通过参数指定页面#\n\n你也可以在 --entry 后面通过参数来指定页面名称，多个页面的名称使用逗号分隔。\n\n\n\n\nmodern start#\n\nmodern start 是 modern dev 命令的别名，两者的功能和用法完全一致。\n\n\nmodern build#\n\nmodern build 命令默认会在 dist/ 目录下构建出可用于生产环境的产物。你可以通过修改配置 output.distPath 指定产物的输出目录。\n\n\n\n\n分析构建产物体积#\n\n执行 npx modern build --analyze 命令，可以在打包生产环境代码的同时，产出一个分析构建产物体积的 HTML 文件：\n\n\n\n手动在浏览器中打开上述 HTML 文件，可以看到打包产物的瓦片图，并进行包体积分析和优化：\n\n> 该功能基于 webpack-bundle-analyzer 实现。\n\n\nmodern new#\n\nmodern new 命令用于在已有项目中添加项目元素。\n\n比如添加应用入口、启用一些可选功能如 Tailwind CSS、微前端开发模式等。\n\n\n\n\n添加入口#\n\n在 Modern.js 工程中，执行 new 命令添加入口的步骤如下：\n\n\n\n\n启用可选功能#\n\n在 Modern.js 工程中，执行 new 命令启用可选能力的步骤如下：\n\n\n\nTIP\n\n--config 参数对应参数值需要使用 JSON 字符串。\n\npnpm 暂不支持使用 JSON 字符串作为参数值，可使用 npm new 开启相关功能。【相关 Issue】\n\n\nmodern serve#\n\nmodern serve 命令用于在生产环境下启动 Modern.js 工程, 也可以用于在本地预览生产环境构建的产物。注意你需要提前执行 build\n命令构建出对应产物。\n\n\n\n默认情况下，应用将会在 localhost:8080 启动，可以通过 server.port 修改 Server 端口号：\n\n\n\n\nmodern upgrade#\n\n在项目根目录下执行命令 npx modern upgrade，会默认将当前执行命令项目的 package.json 中的 Modern.js\n相关依赖更新至最新版本。\n\n\n\n\nmodern inspect#\n\nmodern inspect 命令用于查看项目的 Rsbuild 配置 以及 webpack 或 Rspack 配置。\n\n\n\n在项目根目录下执行命令 npx modern inspect 后，会在项目的 dist 目录生成以下文件：\n\n * rsbuild.config.mjs: 表示在构建时使用的 Rsbuild 配置。\n * webpack.config.web.mjs: 表示在构建时使用的 webpack 配置。\n\n\n\n\n指定环境#\n\n默认情况下，inspect 命令会输出开发环境的配置，你可以添加 --env production 选项来输出生产环境的配置：\n\n\n\n\n完整内容#\n\n默认情况下，inspect 命令会省略配置对象中的函数内容，你可以添加 --verbose 选项来输出函数的完整内容：\n\n\n\n\nSSR 构建配置#\n\n如果项目开启了 SSR 能力，则在 dist 目录会另外生成一份 webpack.config.node.mjs 文件，对应 SSR 构建时的 webpack\n配置。\n\n\n\n\nmodern lint#\n\n运行 ESLint 进行代码语法检查。\n\n\n\n通常情况下，我们只需要在 git commit 阶段通过 lint-staged 检查本次提交修改的部分代码。\n\n * 设置 --no-fix 参数后可以关闭自动修复 lint 错误代码的能力。","routePath":"/apis/app/commands","lang":"zh","toc":[{"text":"modern dev","id":"modern-dev","depth":2,"charIndex":93},{"text":"编译部分页面","id":"编译部分页面","depth":3,"charIndex":198},{"text":"通过参数指定页面","id":"通过参数指定页面","depth":3,"charIndex":379},{"text":"modern start","id":"modern-start","depth":2,"charIndex":437},{"text":"modern build","id":"modern-build","depth":2,"charIndex":500},{"text":"分析构建产物体积","id":"分析构建产物体积","depth":3,"charIndex":599},{"text":"modern new","id":"modern-new","depth":2,"charIndex":769},{"text":"添加入口","id":"添加入口","depth":3,"charIndex":858},{"text":"启用可选功能","id":"启用可选功能","depth":3,"charIndex":905},{"text":"modern serve","id":"modern-serve","depth":2,"charIndex":1050},{"text":"modern upgrade","id":"modern-upgrade","depth":2,"charIndex":1221},{"text":"modern inspect","id":"modern-inspect","depth":2,"charIndex":1326},{"text":"指定环境","id":"指定环境","depth":3,"charIndex":1559},{"text":"完整内容","id":"完整内容","depth":3,"charIndex":1634},{"text":"SSR 构建配置","id":"ssr-构建配置","depth":3,"charIndex":1705},{"text":"modern lint","id":"modern-lint","depth":2,"charIndex":1804}],"domain":"","frontmatter":{"sidebar_position":1},"version":""},{"id":307,"title":"**/*.[tj]s","content":"#\n\n在 BFF 函数写法下，声明 API 路由的文件。除了某些约定文件外，api 目录下的文件会被注册为接口的路由。\n\nINFO\n\n使用 api 目录需要开启 BFF 功能，需要在项目下执行 new 命令启用「BFF」功能。\n\n该文件支持使用 js 或 ts 语言，但必须使用 esm 语法导出函数。\n\n\n该文件约定路由如下：#\n\n\n默认路由#\n\n路由系统会将以 index 命名的文件会被映射到上一层目录。\n\n * api/index.ts -> $BASENAME/\n * api/user/index.ts -> $BASENAME/user\n\n\n嵌套路由#\n\n路由系统也支持解析嵌套的文件，如果创建嵌套文件夹结构，文件仍会以相同方式自动解析路由。\n\n * api/hello.ts -> $BASENAME/hello\n * api/user/list.ts -> $BASENAME/user/list\n\n\n动态路由#\n\n路由系统支持通过 [] 命名的文件目录生成动态路由。\n\n * api/user/[username]/info.ts -> $BASENAME/user/:username/info\n * api/user/[username]/delete.ts -> $BASENAME/user/:username/delete\n * api/article/[id]/info.ts -> $BASENAME/article/:id/info\n\n其中的 $BASENAME 可以在 modern.config.js 中进行配置，默认值为 /api。\n\n\n白名单#\n\n默认 api 目录下所有文件都会当作 BFF 函数文件去解析，但同样我们也设置了白名单，这些文件不被被解析：\n\n * 命名以 _ 开头的文件。例如：_utils.ts。\n * 命名以 _ 开头的文件夹下所有文件。例如：_utils/index.ts、_utils/cp.ts。\n * 测试文件。例如：foo.test.ts。\n * TypeScript 类型文件。例如：hello.d.ts。\n * node_module 下的文件。\n\n\n函数定义#\n\n除了上面的路由规则之外，代码中函数定义与导出也有相应的约定。\n\n函数通过具名导出，导出函数的名字为对应接口接受的 HTTP Method，即：\n\n\n\n这样导出函数，则会得到一个 GET 接口。\n\nModern.js 工程中支持了 9 个 Method\n定义，即：GET、POST、PUT、DELETE、CONNECT、TRACE、PATCH、OPTION、HEAD，即可以用这些 Method\n作为函数导出的名字。\n\n名字是大小不敏感的，就是说，如果是 GET，写成 get、Get、GEt、GET，都可以准确识别。而默认导出，即 export default xxx\n则会被映射为 Get。\n\n因为 delete 是 JavaScript 中的关键字，可以使用 del 或者 DELETE 代替。\n\n可以在一个文件中定义多个不同 Method 的函数，但如果定义多个相同 Method 的函数，则只有第一个会生效。\n\nINFO\n\n需要注意的是，定义的函数都应该是异步的，这个与函数调用时类型有关。","routePath":"/apis/app/hooks/api/api","lang":"zh","toc":[{"text":"该文件约定路由如下：","id":"该文件约定路由如下","depth":2,"charIndex":153},{"text":"默认路由","id":"默认路由","depth":3,"charIndex":167},{"text":"嵌套路由","id":"嵌套路由","depth":3,"charIndex":277},{"text":"动态路由","id":"动态路由","depth":3,"charIndex":409},{"text":"白名单","id":"白名单","depth":3,"charIndex":689},{"text":"函数定义","id":"函数定义","depth":2,"charIndex":915}],"domain":"","frontmatter":{"title":"**/*.[tj]s","sidebar_position":1},"version":""},{"id":308,"title":"_app.[tj]s","content":"#\n\n在 BFF 函数写法下，该文件可以为 BFF 函数添加前置中间件。\n\nNOTE\n\n具体示例请参考 hook","routePath":"/apis/app/hooks/api/app","lang":"zh","toc":[],"domain":"","frontmatter":{"title":"_app.[tj]s","sidebar_position":2},"version":""},{"id":309,"title":"lambda/*.[tj]s","content":"#\n\n在 BFF 框架写法下，声明 API 路由的文件。除了某些约定文件外，lambda/ 目录下的文件会被注册为接口的路由。\n\nINFO\n\n使用 api 目录需要开启 BFF 功能，需要在项目下执行 new 命令启用「BFF」功能。\n\nTIP\n\n该文件支持使用 js 或 ts 语言，但必须使用 esm 语法导出函数。\n\n\n路由规则#\n\n\n默认路由#\n\n路由系统会将以 index 命名的文件会被映射到上一层目录。\n\n * api/lambda/index.ts -> $BASENAME/\n * api/lambda/user/index.ts -> $BASENAME/user\n\n\n多级路由#\n\n路由系统也支持解析多级的文件，如果创建文件夹结构，文件仍会以相同方式自动解析路由。\n\n * api/lambda/hello.ts -> $BASENAME/hello\n * api/lambda/user/list.ts -> $BASENAME/user/list\n\n\n动态路由#\n\n路由系统支持通过 [] 命名的文件目录生成动态路由。\n\n * api/lambda/user/[username]/info.ts -> $BASENAME/user/:username/info\n * api/lambda/user/[username]/delete.ts -> $BASENAME/user/:username/delete\n * api/lambda/article/[id]/info.ts -> $BASENAME/article/:id/info\n\n其中的 $BASENAME 可以在 modern.config.js 中进行配置，默认值为 /api。\n\n\n白名单#\n\n默认 lambda 目录下所有文件都会当作 BFF 函数文件去解析，但同样我们也设置了白名单，这些文件不被被解析：\n\n * 命名以 _ 开头的文件。例如：_utils.ts。\n * 命名以 _ 开头的文件夹下所有文件。例如：_utils/index.ts、_utils/cp.ts。\n * 测试文件。例如：foo.test.ts。\n * TypeScript 类型文件。例如：hello.d.ts。\n * node_module 下的文件。\n\n\n函数定义#\n\n和函数写法下函数定义完全一致。","routePath":"/apis/app/hooks/api/lambda","lang":"zh","toc":[{"text":"路由规则","id":"路由规则","depth":2,"charIndex":162},{"text":"默认路由","id":"默认路由","depth":3,"charIndex":170},{"text":"多级路由","id":"多级路由","depth":3,"charIndex":294},{"text":"动态路由","id":"动态路由","depth":3,"charIndex":438},{"text":"白名单","id":"白名单","depth":3,"charIndex":739},{"text":"函数定义","id":"函数定义","depth":2,"charIndex":968}],"domain":"","frontmatter":{"title":"lambda/*.[tj]s","sidebar_position":3},"version":""},{"id":310,"title":"html/","content":"#\n\n通过 config/html 目录可以在内部默认 html 模板的不同位置注入自定义的 html 片段。\n\n具体使用方式请参考: 自定义 HTML","routePath":"/apis/app/hooks/config/html","lang":"zh","toc":[],"domain":"","frontmatter":{"title":"html/","sidebar_position":1},"version":""},{"id":311,"title":"icon/","content":"#\n\n\nFavicon#\n\n当项目根目录的 config 目录下存在 favicon.* 文件时，Modern.js 会自动将该文件设置到 html.favicon\n配置项中，用于生成页面的 favicon 图标：\n\n\n\n构建完成后，可以看到 HTML 中自动生成了以下标签：\n\n\n\n\n查找顺序#\n\n在设置 app icon 时，Modern.js 会按以下顺序寻找文件：\n\n * favicon.png\n * favicon.jpg\n * favicon.jpeg\n * favicon.svg\n * favicon.ico\n\n\nApple Touch Icon#\n\n当项目根目录的 config 目录下存在 icon.* 文件时，Modern.js 会自动将该文件设置到 html.appIcon 配置项中，用于生成 iOS\n系统下的 Apple Touch Icon 图标。\n\n\n\n构建完成后，可以看到 HTML 中自动生成了以下标签：\n\n\n\n\n查找顺序#\n\n在设置 app icon 时，Modern.js 会按以下顺序寻找文件：\n\n * icon.png\n * icon.jpg\n * icon.jpeg\n * icon.svg\n * icon.ico","routePath":"/apis/app/hooks/config/icon","lang":"zh","toc":[{"text":"Favicon","id":"favicon","depth":2,"charIndex":3},{"text":"查找顺序","id":"查找顺序","depth":3,"charIndex":142},{"text":"Apple Touch Icon","id":"apple-touch-icon","depth":2,"charIndex":265},{"text":"查找顺序","id":"查找顺序-1","depth":3,"charIndex":425}],"domain":"","frontmatter":{"title":"icon/","sidebar_position":2},"version":""},{"id":312,"title":"mock/","content":"#\n\n当项目目录下存在 config/mock/index.js 时，Modern.js 在开发环节将自动开启 Mock 服务。","routePath":"/apis/app/hooks/config/mock","lang":"zh","toc":[],"domain":"","frontmatter":{"title":"mock/","sidebar_position":5},"version":""},{"id":313,"title":"public/","content":"#\n\npublic/ 目录中可以放置任意格式的静态资源文件，文件会被服务端部署到对应的应用域名下。\n\n\n说明#\n\n文件路由基于目录结构的约定，其中，public/ 为根目录，对应 Web 应用根路径。\n\n例如 config/public/sdk/index.js 文件，在部署后将会被部署在 ${domain}/sdk/index.js 下。\n\n\n场景#\n\n例如 robots.txt，auth.xml 等第三方系统需要的认证文件。\n\n或者是给其他业务方（要求路由不变）的 SDK，也可以是无需入口的 HTML 文件等。\n\nINFO\n\n对于需要在源码中通过 import 引用的静态资源（比如 SVG 图片），建议放到 src/assets 目录下进行管理。\n\n\n代码压缩#\n\n如果目录下的文件是一个 .js 文件，在生产环境构建时，会自动对其进行代码压缩。\n\n如果该文件以 .min.js 结尾，则不会经过代码压缩处理。","routePath":"/apis/app/hooks/config/public","lang":"zh","toc":[{"text":"说明","id":"说明","depth":2,"charIndex":51},{"text":"场景","id":"场景","depth":2,"charIndex":173},{"text":"代码压缩","id":"代码压缩","depth":2,"charIndex":331}],"domain":"","frontmatter":{"title":"public/","sidebar_position":3},"version":""},{"id":314,"title":"storybook/","content":"#\n\nModern.js 支持使用 Storybook 进行调试，当需要对 Storybook 进行配置时，需要在项目 config/storybook\n目录进行配置。\n\nStorybook 配置请查看：Storybook 配置\n\nINFO\n\n使用 Storybook 进行调试需要提前在项目下执行 new 命令启用「Storybook」模式功能。\n\n\n示例#\n\n对于 Storybook Manager app 部分的 webpack 配置，可以通过增加 ./config/storybook/main.js\n文件进行配置。\n\n\n\n\n限制#\n\n在使用 config/storybook 目录进行配置时，存在以下限制：\n\n * 不能修改 Story 文件存放的位置，即无法在 main.js 文件里修改 stories 配置。\n * 不支持在 main.js 中修改 Webpack 和 Babel 相关配置，相关需求可通过 tools.webpack / tools.babel 修改。","routePath":"/apis/app/hooks/config/storybook","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":176},{"text":"限制","id":"限制","depth":3,"charIndex":267}],"domain":"","frontmatter":{"title":"storybook/","sidebar_position":7},"version":""},{"id":315,"title":"upload/","content":"#\n\nupload/ 目录中可以放置任意格式的静态资源文件。\n\n\n说明#\n\n在开发环境下，该目录下的静态资源文件会被托管在 /upload 路径下。构建应用产物后，该目录下的文件会被复制到产物目录中。\n\n该文件约定主要用于开发者使用插件，主动上传静态资源文件到 CDN。\n\n\n场景#\n\n例如 google-analysis.js 等项目自用的 SDK（通常需要 HTTP 缓存）。\n\n图片、字体文件、通用 CSS 等。\n\n\n代码压缩#\n\n如果目录下的文件是一个 .js 文件，在生产环境构建时，会自动对其进行代码压缩。\n\n如果该文件以 .min.js 结尾，则不会经过代码压缩处理。\n\n\n更多用法#\n\n在 React 组件中，可以通过内置环境变量来添加该前缀：\n\n\n\n另外，不论是在自定义 HTML 中，或是在 config/public/ 下的任意 HTML 文件中，都可以直接使用 HTML 标签引用\nconfig/upload/ 目录下的资源：\n\n\n\n如果设置了 dev.assetPrefix 或 output.assetPrefix 前缀，也可以直接使用模板语法添加该前缀：\n\n\n\nINFO\n\nModern.js 没有支持在 config/public/*.css（例如 background-image）中通过 URL 使用\nconfig/upload/ 下的文件。","routePath":"/apis/app/hooks/config/upload","lang":"zh","toc":[{"text":"说明","id":"说明","depth":2,"charIndex":32},{"text":"场景","id":"场景","depth":2,"charIndex":137},{"text":"代码压缩","id":"代码压缩","depth":2,"charIndex":211},{"text":"更多用法","id":"更多用法","depth":2,"charIndex":293}],"domain":"","frontmatter":{"title":"upload/","sidebar_position":4},"version":""},{"id":316,"title":"modern.config.[tj]s","content":"#\n\nModern.js 配置文件, 通过该文件可以对当前项目的各个方面进行个性化配置。\n\n了解配置的具体用法，请参考配置使用。","routePath":"/apis/app/hooks/modern-config","lang":"zh","toc":[],"domain":"","frontmatter":{"title":"modern.config.[tj]s","sidebar_position":8},"version":""},{"id":317,"title":"index.[tj]s","content":"#\n\n扩展 Modern.js Web Server 的文件，在此文件中可以给 Modern.js 工程启动的 Web Server 添加 Hook 或\nMiddleware。\n\n可以对请求和响应进行拦截处理，鉴权与角色、请求预处理、异常兜底等。也可在内置处理逻辑（包括路由匹配、资源寻址、头部注入、页面渲染，静态 Web\n托管）插入特定的业务逻辑。","routePath":"/apis/app/hooks/server/index_","lang":"zh","toc":[],"domain":"","frontmatter":{"title":"index.[tj]s","sidebar_position":1},"version":""},{"id":318,"title":"shared/","content":"#\n\n共享源码目录。当项目在 api/、server/、src/ 下有公共代码时，可将这些代码放到 shared 目录下，而不是直接引用。","routePath":"/apis/app/hooks/shared","lang":"zh","toc":[],"domain":"","frontmatter":{"title":"shared/","sidebar_position":5},"version":""},{"id":319,"title":"App.[tj]sx","content":"#\n\n应用使用自控路由时的入口标识符。\n\nApp.[tj]sx 并不是实际的应用入口，Modern.js 会自动生成真正的构建打包的入口文件, 内容大致如下：\n\n\n\nNOTE\n\n在多入口的场景下，每个入口都可以拥有独立的 App.[jt]sx，详见入口。","routePath":"/apis/app/hooks/src/app","lang":"zh","toc":[],"domain":"","frontmatter":{"title":"App.[tj]sx","sidebar_position":1},"version":""},{"id":320,"title":"entry.[tj]s","content":"#\n\n通常情况下routes/ 和 App.[tj]sx 钩子文件已经能满足我们的需求，当我们需要在组件渲染之前添加自定义行为或者完全接管 webpack\n打包入口时，可以在 src 或者入口目录下放置 entry.[tj]s。 下面有分两种情况进行讨论：\n\nINFO\n\n使用该文件需要开启 source.enableCustomEntry。\n\n\n在组件渲染前添加自定义行为#\n\n在 src/entry.[tj]s 中这样实现：\n\n\n\n\n完全接管 webpack 入口#\n\n当项目未安装 @modern-js/runtime 依赖时， src/entry.[tj]sx? 即为真正的 webpack 打包入口文件, 可以直接像使用\ncreate-react-app 等脚手架一样组织代码：\n\n","routePath":"/apis/app/hooks/src/entry","lang":"zh","toc":[{"text":"在组件渲染前添加自定义行为","id":"在组件渲染前添加自定义行为","depth":2,"charIndex":173},{"text":"完全接管 webpack 入口","id":"完全接管-webpack-入口","depth":2,"charIndex":218}],"domain":"","frontmatter":{"title":"entry.[tj]s","sidebar_position":4},"version":""},{"id":321,"title":"entry.server.[tj]sx","content":"#\n\n当项目开启 server.ssr 时，Modern.js 生成一个默认的 Server-Side 入口。示例代码如下：\n\n\n\n\n添加自定义行为#\n\n如果用户需自定义 Server-Side Rendering 入口，可以在\nsrc/entry.server.ts、src/{entryName}/entry.server.ts 中自定义 server 入口\n\n","routePath":"/apis/app/hooks/src/entry.server","lang":"zh","toc":[{"text":"添加自定义行为","id":"添加自定义行为","depth":2,"charIndex":66}],"domain":"","frontmatter":{"title":"entry.server.[tj]sx","sidebar_position":5},"version":""},{"id":322,"title":"index.[tj]s","content":"#\n\nWARNING\n\n即将废弃，推荐使用 entry.[tj]s。\n\n应用使用自定义 bootstrap 时的入口标识。\n\n通常情况下 App.[tj]sx 钩子文件已经能满足我们的需求，当我们需要在 bootstrap 之前添加自定义行为或者完全接管 webpack\n打包入口时，可以在 src 或者入口目录下放置 index.[tj]s。 下面有分两种情况进行讨论：\n\n\n在 bootstrap 之前添加自定义行为#\n\n只需要 src/index.[tj]s 默认导出函数：\n\n\n\n\n完全接管 webpack 入口#\n\n当 src/index.[tj]sx? 下没有默认导出函数时，该文件即为真正的 webpack 打包入口文件, 可以直接像使用 create-react-app\n等脚手架一样组织代码：\n\n","routePath":"/apis/app/hooks/src/index_","lang":"zh","toc":[{"text":"在 bootstrap 之前添加自定义行为","id":"在-bootstrap-之前添加自定义行为","depth":2,"charIndex":188},{"text":"完全接管 webpack 入口","id":"完全接管-webpack-入口","depth":2,"charIndex":244}],"domain":"","frontmatter":{"title":"index.[tj]s","sidebar_position":4},"version":""},{"id":323,"title":"routes/","content":"#\n\n应用使用约定式路由时的入口标识。\n\n约定式路由以 routes/ 为约定的入口， 会分析 src/routes 目录下的文件得到客户端路由配置。\n\n任何在 src/routes 下的 layout.[tj]sx 和 page.[tj]sx 都会作为应用的路由：\n\n\n\n\n基本示例#\n\nroutes 目录下的目录名会作为路由 url 的映射，其中 layout.tsx 中作为布局组件，page.tsx\n作为内容组件，是整条路由的叶子节点，例如以下目录结构：\n\n\n\n会产出下面两条路由：\n\n * /\n * /user\n\n\n动态路由#\n\n如果路由文件的目录名以 [] 命名，生成的路由会作为动态路由。例如以下文件目录：\n\n\n\nroutes/[id]/page.tsx 文件会转为 /:id 路由。除了可以确切匹配的 /blog 路由，其他所有 /xxx 都会匹配到该路由。\n\n在组件中，可以通过 useParams 获取对应命名的参数。\n\n在使用 loader 函数获取数据时，params 会作为 loader 函数的入参，通过 params 的属性可以获取到对应的参数。\n\n\n布局组件#\n\n如下面的例子，可以通过添加 layout.tsx，为所有路由组件添加公共的布局组件：\n\n\n\n在布局组件中可以通过使用 表示子组件：\n\n\n\nNOTE\n\n是 React Router 6 中新的 API，详情可以查看 Outlet.","routePath":"/apis/app/hooks/src/routes","lang":"zh","toc":[{"text":"基本示例","id":"基本示例","depth":2,"charIndex":137},{"text":"动态路由","id":"动态路由","depth":2,"charIndex":262},{"text":"布局组件","id":"布局组件","depth":2,"charIndex":490}],"domain":"","frontmatter":{"title":"routes/","sidebar_position":2},"version":""},{"id":324,"title":"*.[server|node].[tj]sx","content":"#\n\n应用项目中使用，用于放置服务端代码，当 *.tsx 和 *.[server|node].tsx 共存时，SSR 在服务端执行渲染时，会优先使用\n*.[server|node].tsx 文件，而不是 *.tsx 文件。","routePath":"/apis/app/hooks/src/server","lang":"zh","toc":[],"domain":"","frontmatter":{"title":"*.[server|node].[tj]sx","sidebar_position":8},"version":""},{"id":325,"title":"**/*.stories.[tj]sx","content":"#\n\n应用项目 Storybook 调试文件。\n\n可以在项目源码目录 src/ 下创建 *.stories.(js|jsx|ts|tsx|mdx) 格式的文件作为 Storybook 的调试文件。\n\n在项目下执行 npm run dev story 命令，支持使用这些文件在 Storybook 中对相关内容进行调试。\n\nINFO\n\n使用 Storybook 需要提前在项目下执行 new 命令启用「Storybook」。","routePath":"/apis/app/hooks/src/stories","lang":"zh","toc":[],"domain":"","frontmatter":{"title":"**/*.stories.[tj]sx","sidebar_position":7},"version":""},{"id":326,"title":"defineConfig","content":"#\n\n用于动态配置应用。\n\n\n使用姿势#\n\n\n\nRuntime 配置通常可以在 modern.config.js 的 runtime 空间下配置，如 router 配置。\n\nmodern.config.js 中的配置是构建时确定的，如果一些配置参数是运行时获取的，或者配置参数是来自于源码中的一个模块（如组件），就需要使用\ndefineConfig API 进行运行时配置。\n\nINFO\n\n@modern-js/app-tools 拥有同名 API，用于为配置提供 TS 类型，请开发者加以区分。\n\n\n函数签名#\n\n\n\n\n参数#\n\n * Component：React.ComponentType，App 根组件。\n * config：Record，运行时的配置。\n\n\n示例#\n\n\n\n 1. defineConfig 里可配置 runtime.state、runtime.router 等运行时配置。\n\n 2. defineConfig 在配置某个属性之前，如 router，需要确保 modern.config.js 已经配置开启了该功能。\n\n 3. defineConfig 传入的配置会和 modern.config.js 中的配置浅 merge，以 router 为例，最终应用的配置如下：\n\n","routePath":"/apis/app/runtime/app/define-config","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":14},{"text":"函数签名","id":"函数签名","depth":2,"charIndex":250},{"text":"参数","id":"参数","depth":3,"charIndex":260},{"text":"示例","id":"示例","depth":2,"charIndex":334}],"domain":"","frontmatter":{"sidebar_position":1,"title":"defineConfig"},"version":""},{"id":327,"title":"hook","content":"#\n\n用于在 BFF 函数写法下添加框架中间件，添加的中间件的执行会在 BFF 函数定义的路由之前。\n\n\n使用姿势#\n\n根据使用的框架拓展插件，从对应的命名空间中导出：\n\n\n\n\n函数签名#\n\n\n\n\n参数#\n\n * options: Modern.js 提供的一系列钩子。\n   * addMiddleware: 添加 BFF 中间件的钩子。\n\n\n示例#\n\n使用不同的框架，应添加不同框架的中间件（示例为使用 koa 框架时）：\n\n","routePath":"/apis/app/runtime/bff/hook","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":52},{"text":"函数签名","id":"函数签名","depth":2,"charIndex":88},{"text":"参数","id":"参数","depth":3,"charIndex":98},{"text":"示例","id":"示例","depth":2,"charIndex":172}],"domain":"","frontmatter":{"title":"hook"},"version":""},{"id":328,"title":"useContext","content":"#\n\n用于在一体化 BFF 函数中获取请求上下文。\n\n\n使用姿势#\n\n根据使用的框架拓展插件，从对应的命名空间中导出：\n\n\n\n\n函数签名#\n\nfunction useContext(): any\n\n\n示例#\n\n开发者可以通过 context 获取更多的请求信息，例如获取请求 UA（示例为使用 koa 框架时）：\n\n\n\n注意\n\n只有在一体化 BFF 函数中，你才可以使用 useContext API 。\n\n使用不同的运行时框架时，虽然均支持 useContext API，但它们的返回值的类型是不同的。","routePath":"/apis/app/runtime/bff/use-context","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":27},{"text":"函数签名","id":"函数签名","depth":2,"charIndex":63},{"text":"示例","id":"示例","depth":2,"charIndex":99}],"domain":"","frontmatter":{"title":"useContext"},"version":""},{"id":329,"title":"bootstrap","content":"#\n\nWARNING\n\n即将废弃，推荐使用 render。\n\n用于启动和挂载应用，通常情况下不做手动调用。只有在使用自定义 Bootstrap 时，才需要使用该 API。\n\n\n使用姿势#\n\n\n\n\n函数签名#\n\n\n\n\n参数#\n\n * AppComponent：通过 createApp 创建的 ReactElement 实例。\n * id：要挂载的 DOM 根元素 id，如 \"root\"。\n * root: ReactDOM.createRoot 的返回值，用于 bootstrap 函数外需要 root 销毁组件的场景。\n * ReactDOM: ReactDOM 对象，用于区分 React 18 和 React 17 API。\n\n\n示例#\n\n\n\nINFO\n\n由于 @modern-js/runtime/plugins 是别名处理的，在 ts 项目中使用时需要声明其类型， 只需要在\nsrc/modern-app-env.d.ts 添加以下类型声明即可：\n\n\n\nWARNING\n\nbootstrap 只支持在 CSR 场景下使用。","routePath":"/apis/app/runtime/core/bootstrap","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":87},{"text":"函数签名","id":"函数签名","depth":2,"charIndex":97},{"text":"参数","id":"参数","depth":3,"charIndex":107},{"text":"示例","id":"示例","depth":2,"charIndex":318}],"domain":"","frontmatter":{"title":"bootstrap"},"version":""},{"id":330,"title":"createApp","content":"#\n\nWARNING\n\n即将废弃，推荐使用 createRoot。\n\n用于创建自定义入口，定制运行时插件。\n\n\n使用姿势#\n\n\n\n\n函数签名#\n\n\n\n\n参数#\n\n * options: 可选的参数。\n   * plugins：自定义的插件扩展。\n\n\n示例#\n\n\n创建自定义入口#\n\n详见 bootstrap。","routePath":"/apis/app/runtime/core/create-app","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":55},{"text":"函数签名","id":"函数签名","depth":2,"charIndex":65},{"text":"参数","id":"参数","depth":3,"charIndex":75},{"text":"示例","id":"示例","depth":2,"charIndex":124},{"text":"创建自定义入口","id":"创建自定义入口","depth":3,"charIndex":130}],"domain":"","frontmatter":{"title":"createApp"},"version":""},{"id":331,"title":"createRoot","content":"#\n\n用于创建 Modern.js 提供的根组件，该根组件会自动注册 Runtime 插件，并完成 Runtime 插件初始化。\n\n\n使用姿势#\n\n\n\n\n函数签名#\n\n\n\n\n参数#\n\n * UserApp 可选参数，默认为 App.tsx 导出的组件","routePath":"/apis/app/runtime/core/create-root","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":66},{"text":"函数签名","id":"函数签名","depth":2,"charIndex":76},{"text":"参数","id":"参数","depth":3,"charIndex":86}],"domain":"","frontmatter":{"title":"createRoot"},"version":""},{"id":332,"title":"render","content":"#\n\n用于渲染项目组件。\n\n\n使用姿势#\n\n\n\n\n函数签名#\n\n\n\n\n参数#\n\n * App：通过 createRoot 创建的 ReactElement 实例。\n * id：要挂载的 DOM 根元素 id，如 \"root\"。\n\n\n示例#\n\n","routePath":"/apis/app/runtime/core/render","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":14},{"text":"函数签名","id":"函数签名","depth":2,"charIndex":24},{"text":"参数","id":"参数","depth":3,"charIndex":34},{"text":"示例","id":"示例","depth":2,"charIndex":115}],"domain":"","frontmatter":{"title":"render"},"version":""},{"id":333,"title":"useLoader","content":"#\n\n一个同构的 API，通常会用来做异步请求。当 SSR 的时候，服务端使用 useLoader 预加载数据，同时浏览器端也会复用这部分数据。\n\nTIP\n\n在使用 Rspack 作为打包工具时，暂不支持使用 useLoader API。\n\n\n使用姿势#\n\n\n\n\n函数签名#\n\n\n\nINFO\n\nruntimeContext 类型可以参考 useRuntimeContext。\n\n\n参数#\n\n * loaderFn：用于加载数据的函数，返回 Promise。\n * options：可选配置项。\n   * onSuccess：执行成功的回调。\n   * onError：执行失败的回调。\n   * initialData：首次执行前的初始数据，对应返回值中的 data 字段。\n   * skip：当值为 true 时，函数不执行。\n   * params：当 params 序列化结果发生改变时，函数会重新执行。同时，params 也会作为函数的第二个参数被传入。\n   * static：当值为 true 时，useLoader 用于 SSG 编译阶段数据的获取。\n\n\n返回值#\n\n * data：执行成功时的返回数据。\n * loading：表示函数是否处于执行过程中。\n * error：函数执行失败时的错误信息。\n * reload：调用后可以重新执行函数。\n   * params：当值为 undefined 时，函数执行时将复用上次的值；否则会使用新的值重新执行函数。\n * reloading：调用 reload 的执行过程中，reloading 值为 true。\n\n\n示例#\n\n","routePath":"/apis/app/runtime/core/use-loader","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":121},{"text":"函数签名","id":"函数签名","depth":2,"charIndex":131},{"text":"参数","id":"参数","depth":3,"charIndex":189},{"text":"返回值","id":"返回值","depth":3,"charIndex":485},{"text":"示例","id":"示例","depth":2,"charIndex":691}],"domain":"","frontmatter":{"title":"useLoader"},"version":""},{"id":334,"title":"useModuleApps","content":"#\n\n返回所有微前端子应用的 React 组件，用于可自由控制路由。\n\n\n使用姿势#\n\n\n\n\n函数签名#\n\nfunction useModuleApps(): Record>\n\n分别返回包裹每个子应用后的 React 组件。\n\n\n示例#\n\n需要先配置微前端子应用信息。\n\n\n\n这里演示主应用为自控式路由的场景，全部场景参考 体验微前端\n\n\n\n通过 useModuleApps() 获取到 Table 和 Dashboard 子应用组件（名称和配置里的 name 字段对应），之后就可以像使用普通的\nReact 组件一样去加载子应用。\n\n\n集中式路由#\n\n集中式路由 是将子应用的激活路由集中配置的方式。我们给子应用列表信息添加 activeWhen 字段来启用 集中式路由。\n\n\n\n然后在主应用中使用 useModuleApp 方法获取 MApp 组件, 并在主应用渲染 MApp。\n\n\n\n这样启动应用后，访问 /dashboard 路由，会渲染 Dashboard 子应用，访问 /table 路由，会渲染 Table 子应用。\n\n\n加载动画#\n\n可以通过以下方式，自定义组件加载过程的过渡动画。\n\n","routePath":"/apis/app/runtime/core/use-module-apps","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":36},{"text":"函数签名","id":"函数签名","depth":2,"charIndex":46},{"text":"示例","id":"示例","depth":2,"charIndex":114},{"text":"集中式路由","id":"集中式路由","depth":3,"charIndex":268},{"text":"加载动画","id":"加载动画","depth":2,"charIndex":467}],"domain":"","frontmatter":{"title":"useModuleApps"},"version":""},{"id":335,"title":"useRuntimeContext","content":"#\n\n该函数主要用于获取 Runtime 上下文，只能在函数组件中使用。\n\n\n使用姿势#\n\n\n\n\n函数签名#\n\n\n\n\n返回值#\n\n * request：请求上下文中的附加信息。\n   * params：请求路径中的动态参数。\n   * pathname：请求的 pathname。\n   * query：请求的查询字符串对象。\n   * headers：请求头信息。\n   * cookie：请求的 cookie 信息。\n * store：在开启了 state 插件的时候，该值为 Reduck 全局 store。\n * router：在开启 router 插件的时候存在。\n   * location：当前路由对应的位置信息。同 useLocation 返回值。\n   * navigate：导航到给定路径。同 useNavigate 返回值。\n\n\n示例#\n\n","routePath":"/apis/app/runtime/core/use-runtime-context","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":38},{"text":"函数签名","id":"函数签名","depth":2,"charIndex":48},{"text":"返回值","id":"返回值","depth":3,"charIndex":58},{"text":"示例","id":"示例","depth":2,"charIndex":375}],"domain":"","frontmatter":{"title":"useRuntimeContext"},"version":""},{"id":336,"title":"Provider","content":"#\n\n补充信息\n\n默认情况下，本节所有 API 的导出包名为：@modern-js/runtime/model。\n\n如果是在 Modern.js 以外单独集成 Reduck，导出包名为：@modern-js-reduck/react。\n\nProvider 是一个组件，它将 Reduck 的 Store 注入到应用的组件树中，使组件树内部的组件可以访问 Model。一般情况下，Provider\n会定义在组件树的最顶层。\n\n\n函数签名#\n\n\n\n\n参数#\n\n * store：createStore 创建的 Store 对象。\n * config：创建 Reduck Store 的配置，同 createApp 的 config 参数。\n\n\n示例#\n\n","routePath":"/apis/app/runtime/model/Provider","lang":"zh","toc":[{"text":"函数签名","id":"函数签名","depth":2,"charIndex":212},{"text":"参数","id":"参数","depth":3,"charIndex":222},{"text":"示例","id":"示例","depth":2,"charIndex":319}],"domain":"","frontmatter":{"sidebar_position":8,"title":"Provider"},"version":""},{"id":337,"title":"Auto actions","content":"#\n\n补充信息\n\n默认情况下，本节所有 API 的导出包名为：@modern-js/runtime/model。\n\n如果是在 Modern.js 以外单独集成 Reduck，导出包名为：@modern-js-reduck/react。\n\nReduck 可以根据 State 的类型，自动生成相应的 Actions，为修改 State 提供便利。\n\n提示\n\n可通过 runtime.state.autoActions 关闭 auto actions 功能。\n\n\n示例#\n\n\n基础数据类型#\n\nState 类型为 string、number、boolean、null 时，生成 setState Action。\n\n\n\n\n数组 Array#\n\nState 类型为 Array 时，生成下列 Actions：\n\n * push：将一个或多个元素添加到数组的末尾。\n * pop：从数组中删除最后一个元素。\n * shift：从数组中删除第一个元素。\n * unshift：将一个或多个元素添加到数组的开头。\n   * 语法：arr.unshift(element1, ..., elementN)\n   * elementN：要添加到数组开头的元素或多个元素。\n * filter：过滤元素。\n\n * concat：拼接数组。\n\n * splice：通过删除或替换现有元素或者原地添加新的元素来修改数组，并以数组形式返回修改后的数组（注意和原生 splice 返回值不同）。\n   * 语法：splice(start[, deleteCount[, item1[, item2[, ...]]]])\n   * start：指定修改的开始位置（从 0 计数）。\n   * deleteCount：可选，整数，表示要移除的数组元素的个数。\n   * item, item2, ...：可选，要添加进数组的元素，从 start 位置开始。如果不指定，则 splice 将只删除数组元素。\n\n\n\n\n简单对象 PlainObject#\n\nState 类型为 PlainObject 时，根据 State 包含的属性名，生成 set${key}（小驼峰命名）Actions。\n\n","routePath":"/apis/app/runtime/model/auto-actions","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":229},{"text":"基础数据类型","id":"基础数据类型","depth":3,"charIndex":235},{"text":"数组 Array","id":"数组-array","depth":3,"charIndex":307},{"text":"简单对象 PlainObject","id":"简单对象-plainobject","depth":3,"charIndex":840}],"domain":"","frontmatter":{"sidebar_position":6,"title":"Auto actions"},"version":""},{"id":338,"title":"connect","content":"#\n\n补充信息\n\n默认情况下，本节所有 API 的导出包名为：@modern-js/runtime/model。\n\n如果是在 Modern.js 以外单独集成 Reduck，导出包名为：@modern-js-reduck/react。\n\n提示\n\nReduck 原始类型较为复杂，以下涉及类型定义的地方，展示的是简化后的类型信息。原始类型见 connect。\n\nconnect 功能上同 useModel 一致，是对应的 HOC 风格的 API。建议优先使用 Hook 风格的 useModel。\n\n\n类型#\n\n\n\n\n参数#\n\n * models：传入的 1 个或多个 Model，当 models 为数组类型参数时，最后两项元素可以是用于筛选 State 的函数（\n   SelectStateToProps 类型）和用于筛选 Actions 的函数（ SelectActionsToProps 类型）。\n   \n   * SelectStateToProps： modelStates 是传入的 Model 对象的 State 组成的数组，ownProps\n     是当前组件接收外部传递的 props，SelectStateToProps 返回的数据会传递到组件的 props 上。当 models 中没有传入\n     SelectStateToProps 参数时，所有 Model 的 State 进行合并后传递到组件的 props 上。\n   * SelectActionsToProps： modelActions 是传入的 Model 对象的 Actions 组成的数组，ownProps\n     是当前组件接收外部传递的 props，SelectActionsToProps 返回的数据也会传递到组件的 props 上。当 models\n     中没有传入 SelectActionsToProps 参数时，所有 Model 的 Actions 进行合并后传递到组件的 props 上。\n\n * options：可选参数，用于辅助配置。目前支持设置 forwardRef，用于控制是否转发组件的 ref，默认值为 false，表示不转发\n   ref。设置为 {forwardRef: true}，表示转发 ref。\n\n\n返回值#\n\n返回一个高阶组件：接收一个传入的组件，返回一个在 props 上注入了额外 State 和 Actions 的组件。\n\n\n示例#\n\n\n简单用法#\n\n\n\n\n筛选 State 和 Actions#\n\n\n\n\n转发组件的 ref#\n\n","routePath":"/apis/app/runtime/model/connect","lang":"zh","toc":[{"text":"类型","id":"类型","depth":2,"charIndex":249},{"text":"参数","id":"参数","depth":2,"charIndex":257},{"text":"返回值","id":"返回值","depth":2,"charIndex":971},{"text":"示例","id":"示例","depth":2,"charIndex":1038},{"text":"简单用法","id":"简单用法","depth":3,"charIndex":1044},{"text":"筛选 State 和 Actions","id":"筛选-state-和-actions","depth":3,"charIndex":1054},{"text":"转发组件的 ref","id":"转发组件的-ref","depth":3,"charIndex":1078}],"domain":"","frontmatter":{"sidebar_position":5,"title":"connect"},"version":""},{"id":339,"title":"createApp","content":"#\n\n补充信息\n\n默认情况下，本节所有 API 的导出包名为：@modern-js/runtime/model。\n\n如果是在 Modern.js 以外单独集成 Reduck，导出包名为：@modern-js-reduck/react。\n\nReduck 内部默认会使用 createApp 创建一个全局应用，如果整个应用只需要共享一个 Store，那么是不需要使用 createApp\n的。只有当需要在应用局部创建共享 Store 时，才需要使用 createApp。\n\n注意\n\n注意 @modern-js/runtime/model 中导出的 createApp 用于管理状态，而 @modern-js/runtime 导出的\ncreateApp 用于管理整个应用的运行时环境，两者功能不同。\n\n\n函数签名#\n\n\n\n\n参数#\n\n * config：Record\n   * StoreConfig：同 createStore 的参数。\n   * devTools：默认值为 true。是否开启 Redux DevTools，当为对象类型时，支持配置 Redux DevTools 的\n     Options。\n   * autoActions：默认值为 true。是否自动生成 Actions。\n\n\n返回值#\n\nReduck App，有以下属性组成：\n\n * Provider：为应用局部的组件树注入共享 Store 的组件。用法同 Provider。\n * useModel：获取应用局部 Store 挂载的 Model 对象。用法同 useModel。\n * useStaticModel：获取应用局部 Store 挂载的 Model 对象。用法同 useStaticModel。\n * useLocalModel：获取应用局部 Store 挂载的 Model 对象。用法同 useLocalModel。\n * useStore：获取应用局部使用的 Store 对象。用法同 useStore。\n\n\n示例#\n\n通过 createApp 可以创建局部状态，将不同 Reduck 应用间的状态隔离。\n\n","routePath":"/apis/app/runtime/model/create-app","lang":"zh","toc":[{"text":"函数签名","id":"函数签名","depth":2,"charIndex":348},{"text":"参数","id":"参数","depth":3,"charIndex":358},{"text":"返回值","id":"返回值","depth":3,"charIndex":549},{"text":"示例","id":"示例","depth":2,"charIndex":851}],"domain":"","frontmatter":{"sidebar_position":11,"title":"createApp"},"version":""},{"id":340,"title":"createStore","content":"#\n\n补充信息\n\n默认情况下，本节所有 API 的导出包名为：@modern-js/runtime/model。\n\n如果是在 Modern.js 以外单独集成 Reduck，导出包名为：@modern-js-reduck/react。\n\ncreateStore 用于创建一个 Store 对象。Reduck 的 Store 基于 Redux 的 Store\n实现，用于存储应用的状态，同时提供一组用于管理状态和 Model 的方法。\n\n一般情况下，不需要使用这个 API，只有需要完全掌控 Store 的创建时，才会使用这个 API。例如，自定义一个 Store，传入 Provider\n组件使用。\n\n\n函数签名#\n\n\n\n\n参数#\n\n * config?：store 配置选项\n   * initialState?: 设置全局 Store 的初始状态。\n   * models?: 设置提前（Store 创建后）挂载到 Store 的 Model。（正常使用无需提前挂载）\n   * middlewares?: 设置 Redux 中间件。\n   * enhancers?: 设置 Redux 的 Store enhancer 。\n   * plugins?: 设置 Reduck 插件。试验性配置，不推荐使用。\n\n\n返回值#\n\nReduck Store 对象：\n\n * use：动态挂载和获取 Model 对象。用法与 useModel 相同，但可以在 React 组件外使用。\n * unmount：卸载 Model 对象，Model 的 State 会从 Store 中清除。\n * ReduxStore：Redux Store 对象具有的方法，详见。\n\n\n示例#\n\n","routePath":"/apis/app/runtime/model/create-store","lang":"zh","toc":[{"text":"函数签名","id":"函数签名","depth":2,"charIndex":301},{"text":"参数","id":"参数","depth":3,"charIndex":311},{"text":"返回值","id":"返回值","depth":3,"charIndex":557},{"text":"示例","id":"示例","depth":2,"charIndex":730}],"domain":"","frontmatter":{"sidebar_position":10,"title":"createStore"},"version":""},{"id":341,"title":"handleEffect","content":"#\n\n补充信息\n\n默认情况下，本节所有 API 的导出包名为：@modern-js/runtime/model。\n\n如果是在 Modern.js 以外单独集成 Reduck，导出包名为：@modern-js-reduck/react。\n\n一个异步函数类型的 Effect，通常有三种需要处理的状态: 请求中、请求成功、请求处理失败。这些状态处理的方式，就是编写对应的 Action\n函数(pending、fulfilled、rejected)。\n\n借助 handleEffect API，我们可以生成默认的 Action 函数来处理异步请求各个阶段的不同结果。handleEffect 生成的 Action\n返回的 State 的结构如下：\n\n\n\n\n函数签名#\n\n\n\n\n参数#\n\n * ns：默认返回的 State 结构扁平地挂载到 Model 的 State 上，通过设置该参数可以将返回的 State 挂载到 ns\n   值命名的字段下。例如，ns 设置为 data，返回的 State 结构为：\n\n\n\n * result：默认值为 \"result\"。该参数对应存储异步请求 fulfilled 状态结果的字段名称。例如，设置 result 为\n   \"items\"，返回的 State 结构为：\n\n\n\nresult 为 false，返回的 State 结构中不存在 result：\n\n\n\n * pending：默认值为 \"pending\"。改变返回 State 中的 pending 字段名。用法同上。\n\n * error： 默认值为 \"error\"。改变返回 State 中的 error 字段名。用法同上。\n\n * combineMode：默认值为 \"merge\"。获取 fulfilled 状态的返回数据后，对 result 的处理方式：merge（合并）和\n   replace（替换）。这里能自动处理的数据类型也仅限为简单的对象或者数组类型。\n   \n   * merge：前一次的数据与当前的数据合并。数据为数组类型，内部操作类似于 [].concat(lastData,\n     currentData)；数据为对象类型，内部操作类似于 {...lastData, ...curData}。\n   * replace：当前的数据直接替换之前的数据。\n\n * omitResultNamespace：默认值为 \"false\"。当异步请求的结果为对象类型，希望把该结果直接挂载到 Model 的 State\n   上，而不是挂载到 \"result\" 上，可以设置为 true。例如：\n\n\n\n\n返回值#\n\n分别处理 pending、fulfilled、rejected 三种状态的 Action 组成的对象。\n\n更多参考\n\n副作用管理","routePath":"/apis/app/runtime/model/handle-effect","lang":"zh","toc":[{"text":"函数签名","id":"函数签名","depth":2,"charIndex":324},{"text":"参数","id":"参数","depth":3,"charIndex":334},{"text":"返回值","id":"返回值","depth":3,"charIndex":1104}],"domain":"","frontmatter":{"sidebar_position":7,"title":"handleEffect"},"version":""},{"id":342,"title":"model","content":"#\n\n补充信息\n\n默认情况下，本节所有 API 的导出包名为：@modern-js/runtime/model。\n\n如果是在 Modern.js 以外单独集成 Reduck，导出包名为：@modern-js-reduck/react。\n\n提示\n\nReduck 原始类型较为复杂，以下涉及类型定义的地方，展示的是简化后的类型信息。原始类型见 model。\n\n\nmodel#\n\n用于创建管理应用状态的 Model。\n\nfunction model(name: string): { define: function }\n\n * name：string，创建的 Model 的唯一标识。\n\n\n\n\ndefine#\n\n用于定义 Model 的详细结构，支持传入一个对象类型或函数类型的参数。\n\n\n对象类型#\n\nfunction define(modelDesc: ModelDesc): Model;\n\n * modelDesc: ModelDesc，对 Model 结构的定义，包含 state、computed、actions、effects 等属性。\n\n\n\n\n函数类型#\n\nfunction define((context: Context, utils: Utils) => ModelDesc): Model;\n\n * context: Context，Reduck 上下文对象，可以获取底层的 store 对象。store 除支持 Redux Store 的所有 API\n   以外，还挂载了用于消费 Model 的 use 的方法，和用于卸载 Model 的 unmount 方法。\n * utils: Utils，定义 Model 时，常用的工具函数：use、onMount。use 作用同 store 对象上的 use，onMount 是\n   Model 挂载后的钩子函数。\n\n\n\n如通过 use，可以获取 Model 自身及其它 Model 的 state，actions。\n\n\n\n\n参数#\n\nModelDesc.state#\n\n定义 Model 的状态。技术上，支持任意类型的 State，但是实践中建议使用可进行 JSON 序列化的类型。\n\n\n\nModelDesc.actions#\n\n定义 Model 的 Actions。Actions 的函数类型为：\n\n\n\nReduck 内部集成了 immer，可以直接原始的 state，当 Action 没有显式返回值时，Reduck 内部会返回修改过的新的 State 对象。\n\nModelDesc.computed#\n\n定义 Model 的衍生状态。衍生状态的定义支持两种类型：\n\n 1. 只依赖 Model 自身的状态\n\n\n\n 2. 依赖其他 Model 的状态\n\n\n\n\n\nModelDesc.effects#\n\n定义 Model 的 Effects。Effects 中定义的函数类型为：\n\n\n\n\n\n更多参考\n\n创建 Model","routePath":"/apis/app/runtime/model/model_","lang":"zh","toc":[{"text":"model","id":"model-1","depth":2,"charIndex":-1},{"text":"define","id":"define","depth":2,"charIndex":294},{"text":"对象类型","id":"对象类型","depth":3,"charIndex":342},{"text":"函数类型","id":"函数类型","depth":3,"charIndex":477},{"text":"参数","id":"参数","depth":3,"charIndex":847},{"text":"ModelDesc.state","id":"modeldescstate","depth":4,"charIndex":852},{"text":"ModelDesc.actions","id":"modeldescactions","depth":4,"charIndex":930},{"text":"ModelDesc.computed","id":"modeldesccomputed","depth":4,"charIndex":1069},{"text":"ModelDesc.effects","id":"modeldesceffects","depth":4,"charIndex":1168}],"domain":"","frontmatter":{"sidebar_position":1,"title":"model"},"version":""},{"id":343,"title":"useLocalModel","content":"#\n\n补充信息\n\n默认情况下，本节所有 API 的导出包名为：@modern-js/runtime/model。\n\n如果是在 Modern.js 以外单独集成 Reduck，导出包名为：@modern-js-reduck/react。\n\n用于把 Model 中的 State 作为局部状态使用，效果类似 React 的 useState。useLocalModel API 形式上与\nuseModel 完全一致。具体使用请参考 useModel。\n\n示例#\n\n\n\n上面通过 useLocalModel 加载了两次 modelA，因为 useLocalModel 消费的是局部状态，所以 state 和 state1\n也是完全隔离的。\n\n更多参考\n\n使用 Model","routePath":"/apis/app/runtime/model/use-local-model","lang":"zh","toc":[{"text":"示例","id":"示例","depth":4,"charIndex":224}],"domain":"","frontmatter":{"sidebar_position":4,"title":"useLocalModel"},"version":""},{"id":344,"title":"useModel","content":"#\n\n补充信息\n\n默认情况下，本节所有 API 的导出包名为：@modern-js/runtime/model。\n\n如果是在 Modern.js 以外单独集成 Reduck，导出包名为：@modern-js-reduck/react。\n\n提示\n\nReduck 原始类型较为复杂，以下涉及类型定义的地方，展示的是简化后的类型信息。原始类型见 model。\n\n\n函数签名#\n\n\n\n\n参数#\n\n * models：Model 对象数组，可以作为一个数组类型的参数传入，也可以所有 Model 逐个作为参数传入。\n * stateSelector：可选参数，用于筛选 State 计算。前 n 个参数为 n 个 Model 对应的 State，返回的数据作为\n   useModel 返回值数组的第一个元素。\n * actionSelector：可选参数，用于筛选 Actions 计算。前 n 个参数为 n 个 Model 对应的 Actions，返回的数据作为\n   useModel 返回值数组的第二个元素。\n\n\n返回值#\n\n返回一个数组，每一项元素分别为：\n\n * state：stateSelector 的返回值。如果未传 stateSelector，会把传入的所有 Model 的 State\n   (包含衍生状态)合并后返回。如果不同 Model 的 State 中存在同名属性，后面的 State 会覆盖前面的 State。当 state\n   发生变化时，调用 useModel 的组件会重新渲染。\n * actions：第二个元素为 actionSelector 的返回值。如果未传 actionSelector，会把传入的所有 Model 的\n   Actions (包含 Effects) 合并后返回。如果不同 Model 的 Actions 中存在同名属性，后面的 Actions 会覆盖前面的\n   Actions。\n * subscribe：订阅 State 变化的函数。当传入的任意 Model 的 State 发生改变时，该函数会被调用。\n\n\n示例#\n\n\n基本用法#\n\n\n\n\nselector 用法#\n\n\n\n更多参考\n\n使用 Model","routePath":"/apis/app/runtime/model/use-model","lang":"zh","toc":[{"text":"函数签名","id":"函数签名","depth":2,"charIndex":178},{"text":"参数","id":"参数","depth":3,"charIndex":188},{"text":"返回值","id":"返回值","depth":3,"charIndex":455},{"text":"示例","id":"示例","depth":2,"charIndex":884},{"text":"基本用法","id":"基本用法","depth":3,"charIndex":890},{"text":"selector 用法","id":"selector-用法","depth":3,"charIndex":900}],"domain":"","frontmatter":{"sidebar_position":2,"title":"useModel"},"version":""},{"id":345,"title":"useStaticModel","content":"#\n\n补充信息\n\n默认情况下，本节所有 API 的导出包名为：@modern-js/runtime/model。\n\n如果是在 Modern.js 以外单独集成 Reduck，导出包名为：@modern-js-reduck/react。\n\n如果想在组件里以 React Hook 的形式消费某个 Model，并能随时获取到当前最新的状态，但又不希望 Model\n状态更新的时候，引起组件的重新渲染，可以使用 useStaticModel。useStaticModel API 形式上与 useModel\n完全一致。具体使用请参考 useModel。\n\n为了保证总是能获取到最新状态，注意不要对返回的 state 解构。\n\n\n\n示例#\n\n如下 App 组件消费了 userModel 的状态，但没有直接在 JSX 里使用。可以发现，userModel\n状态的改变没有必要引起组件重新渲染，这种情况可以使用 useStaticModel 进行优化。\n\n\n\n更多参考\n\n使用 Model","routePath":"/apis/app/runtime/model/use-static-model","lang":"zh","toc":[{"text":"示例","id":"示例","depth":4,"charIndex":311}],"domain":"","frontmatter":{"sidebar_position":3,"title":"useStaticModel"},"version":""},{"id":346,"title":"useStore","content":"#\n\n补充信息\n\n默认情况下，本节所有 API 的导出包名为：@modern-js/runtime/model。\n\n如果是在 Modern.js 以外单独集成 Reduck，导出包名为：@modern-js-reduck/react。\n\nuseStore 用于获取当前组件树共享的 Store。常用于在组件外访问 Model 的场景。注意，useStore 是一个 React\nHook，只能在组件内使用。\n\n\n函数签名#\n\n\n\n\n返回值#\n\n * ReduckStore：Reduck Store，类型参考 createStore 返回值。\n\n更多参考\n\n使用 Model","routePath":"/apis/app/runtime/model/use-store","lang":"zh","toc":[{"text":"函数签名","id":"函数签名","depth":2,"charIndex":205},{"text":"返回值","id":"返回值","depth":3,"charIndex":215}],"domain":"","frontmatter":{"sidebar_position":9,"title":"useStore"},"version":""},{"id":347,"title":"router","content":"#\n\n补充信息\n\n基于 react-router 的路由解决方案。\n\n\nhooks#\n\n\nuseNavigate#\n\n\n\nuseNavigate 返回一个可以用于执行导航操作的函数。\n\n\n\n\nuseLocation#\n\n\n\nuseLocation 返回当前 url 对应的 location 对象。每当路由更新的时候，都会拿到一个新的 location 对象。\n\n\n\n\nuseParams#\n\n\n\nuseParams 返回一个 key/value 的键值对，表示当前匹配的路由 中的参数信息。\n\n\n\n\nuseRouteError#\n\n\n\nuseRouteError 返回离 ErrorBoundary 定义最近的路由渲染错误信息。\n\n\n\n\n组件#\n\n\nLink#\n\n\n\n可以使用 Link 组件进行路由跳转。\n\n\n\n\nNavLink#\n\n\n\n是一种特殊的 ，当 对应的链接和当前 URL 匹配时，会给 所渲染的元素添加“激活”态样式。\n\n\nOutlet#\n\n\n\n用于嵌套路由场景。在父路由的元素中使用，代表待渲染的子路由的元素在父组件中的位置。\n\n\n\n\nRoute#\n\n\n\nRoute 用于定义路由。一个 Route 对象，将 URL 片段和组件、数据获取关联起来。\n\nRoute 可以作为普通对象，传给创建 router 的函数的参数：\n\n\n\nRoute 还可以作为组件使用，通过 createRoutesFromElements 转换后，再传给创建 router 的函数的参数：\n\n\n\n\n更多 API#\n\n若想要了解完整的路由 API 信息，可至 react-router 官网 查看。","routePath":"/apis/app/runtime/router/router","lang":"zh","toc":[{"text":"hooks","id":"hooks","depth":2,"charIndex":35},{"text":"useNavigate","id":"usenavigate","depth":3,"charIndex":44},{"text":"useLocation","id":"uselocation","depth":3,"charIndex":95},{"text":"useParams","id":"useparams","depth":3,"charIndex":184},{"text":"useRouteError","id":"userouteerror","depth":3,"charIndex":250},{"text":"组件","id":"组件","depth":2,"charIndex":319},{"text":"Link","id":"link","depth":3,"charIndex":325},{"text":"NavLink","id":"navlink","depth":3,"charIndex":358},{"text":"Outlet","id":"outlet","depth":3,"charIndex":419},{"text":"Route","id":"route","depth":3,"charIndex":476},{"text":"更多 API","id":"更多-api","depth":2,"charIndex":645}],"domain":"","frontmatter":{"title":"router","sidebar_position":1},"version":""},{"id":348,"title":"NoSSR","content":"#\n\n被 NoSSR 包裹的内容在服务端不会进行渲染，在客户端 hydrate 阶段也不会渲染，等到整个 App 渲染完成后便会立即渲染。\n\n\n使用姿势#\n\n\n\n\n示例#\n\n下列代码中，Time 组件用于展示当前的时间，由于服务端渲染和客户端 hydrate 时获取到的时间是不一致的，React 就会抛出异常。针对这种情况可以使用\nNoSSR 进行优化：\n\n\n\n\n使用场景#\n\n在 CSR 中，常常需要根据当前浏览器 UA，或是当前页面 URL 的某个参数的不同，来渲染不同的内容。如果此时应用直接切换到\nSSR，很有可能出现不符合预期的结果。\n\nModern.js 在 SSR 上下文中提供了完整的浏览器端信息，可以利用上下文信息来决定组件在服务端的渲染结果。\n\n即便如此，如果应用里有太多的判断，开发者希望以后再使用上下文，或者不希望某些内容在服务端被渲染，可以使用 NoSSR 组件将这一部分剔除在服务端渲染外。","routePath":"/apis/app/runtime/ssr/no-ssr","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":71},{"text":"示例","id":"示例","depth":2,"charIndex":81},{"text":"使用场景","id":"使用场景","depth":2,"charIndex":182}],"domain":"","frontmatter":{"title":"NoSSR"},"version":""},{"id":349,"title":"PreRender","content":"#\n\n无展示内容的高阶组件，通过类似 Helmet 的方式实现 SPA 路由级的缓存，无需额外配置。\n\n\n使用姿势#\n\n\n\n\n函数签名#\n\nPreRender 组件提供了一套常用的配置参数，用于控制缓存的规则、过期时间、缓存算法等。\n\n\n\n\n参数#\n\n * interval：设置缓存保持新鲜的时间，单位秒。在该时间内，将直接使用缓存，并且不做异步渲染。\n * staleLimit：设置缓存完全过期的时间，单位秒。在该时间内，缓存可以被返回，并且会做一步渲染，否则必须使用重新渲染的结果。\n * level：设置缓存标识的计算规则等级，通常配合 includes 与 matches 使用。默认值为 0。\n\n\n\n * includes：设置需要被纳入缓存标识的内容，在 level 非 0 时使用。默认值为 null。\n * matches：设置 query 或 header 的值在缓存标识计算中的重写规则，通常用在缓存分类时，支持正则表达式。默认值为 null。\n\n\n示例#\n\n\n\n下面例子展示了如何将 query、header 中指定的参数纳入缓存计算中：\n\n\n\n下面例子展示了如何不让测试频道影响线上缓存：\n\n","routePath":"/apis/app/runtime/ssr/pre-render","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":52},{"text":"函数签名","id":"函数签名","depth":2,"charIndex":62},{"text":"参数","id":"参数","depth":3,"charIndex":120},{"text":"示例","id":"示例","depth":2,"charIndex":436}],"domain":"","frontmatter":{"title":"PreRender"},"version":""},{"id":350,"title":"renderStreaming","content":"#\n\n用于 React v18+ Streaming SSR 渲染出可读流, 配合 createRequestHandler 使用\n\n\n使用#\n\n\n\n\n函数签名#\n\n\n\n\n示例#\n\n","routePath":"/apis/app/runtime/ssr/renderStreaming","lang":"zh","toc":[{"text":"使用","id":"使用","depth":2,"charIndex":67},{"text":"函数签名","id":"函数签名","depth":2,"charIndex":75},{"text":"示例","id":"示例","depth":2,"charIndex":85}],"domain":"","frontmatter":{"title":"renderStreaming"},"version":""},{"id":351,"title":"renderString","content":"#\n\n用于 React String SSR 渲染出字符串，配合 createRequestHandler 使用\n\n\n使用#\n\n\n\n\n函数签名#\n\n\n\n\n示例#\n\n","routePath":"/apis/app/runtime/ssr/renderString","lang":"zh","toc":[{"text":"使用","id":"使用","depth":2,"charIndex":58},{"text":"函数签名","id":"函数签名","depth":2,"charIndex":66},{"text":"示例","id":"示例","depth":2,"charIndex":76}],"domain":"","frontmatter":{"title":"renderString"},"version":""},{"id":352,"title":"createRequestHandler","content":"#\n\n用于自定义 Server-Side Rendering 入口返回 requestHandler\n\n\n使用#\n\n\n\n\n函数签名#\n\n","routePath":"/apis/app/runtime/ssr/requestHandler","lang":"zh","toc":[{"text":"使用","id":"使用","depth":2,"charIndex":52},{"text":"函数签名","id":"函数签名","depth":2,"charIndex":60}],"domain":"","frontmatter":{"title":"createRequestHandler"},"version":""},{"id":353,"title":"CSS-In-JS API","content":"#\n\n使用 Style Component 来编写组件 CSS。\n\n\n使用姿势#\n\n\n\n\n函数签名#\n\n请看 styled-component API。\n\n\n示例#\n\n","routePath":"/apis/app/runtime/utility/css-in-js","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":34},{"text":"函数签名","id":"函数签名","depth":2,"charIndex":44},{"text":"示例","id":"示例","depth":2,"charIndex":78}],"domain":"","frontmatter":{"title":"CSS-In-JS API"},"version":""},{"id":354,"title":"Head","content":"#\n\n用于给 元素内添加 html 元素（如 title、meta、script 等），支持 SSR。\n\n\n使用姿势#\n\n\n\n\n示例#\n\n\n\n\n更多用法#\n\n详见 react-helmet。","routePath":"/apis/app/runtime/utility/head","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":53},{"text":"示例","id":"示例","depth":2,"charIndex":63},{"text":"更多用法","id":"更多用法","depth":2,"charIndex":71}],"domain":"","frontmatter":{"title":"Head"},"version":""},{"id":355,"title":"loadable","content":"#\n\n用于创建 Loadable 的组件。\n\n\n使用姿势#\n\n\n\n\n函数签名#\n\n\n\n\n参数#\n\nloadFn#\n\n用于加载组件。\n\n\n\noptions.resolveComponent#\n\n类型：(module: Module, props: Props) => React.ComponentType\n\nmodule 为 loadFn 返回的组件，props 是 loadable 返回的组件接受的 props 参数。默认的话，我们认为 import\n的文件都是默认导出 react 组件，这时候直接渲染该组件即可。但当组件是具名导出的，或者我们需要根据具体的 props\n动态判断需要渲染哪个组件的时候，可以使用 resolveComponent 来实现。下面是一个示例：\n\n\n\n\n\noptions.fallback#\n\n是否在 loading 阶段显示 fallback 内容。\n\noptions.ssr#\n\n是否支持 SSR，默认值是 true。\n\n\n返回值#\n\nLoadableComponent#\n\n","routePath":"/apis/app/runtime/utility/loadable","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":23},{"text":"函数签名","id":"函数签名","depth":2,"charIndex":33},{"text":"参数","id":"参数","depth":3,"charIndex":43},{"text":"loadFn","id":"loadfn","depth":4,"charIndex":48},{"text":"options.resolveComponent","id":"optionsresolvecomponent","depth":4,"charIndex":68},{"text":"options.fallback","id":"optionsfallback","depth":4,"charIndex":344},{"text":"options.ssr","id":"optionsssr","depth":4,"charIndex":394},{"text":"返回值","id":"返回值","depth":3,"charIndex":430},{"text":"LoadableComponent","id":"loadablecomponent","depth":4,"charIndex":436}],"domain":"","frontmatter":{"title":"loadable"},"version":""},{"id":356,"title":"Hook","content":"#\n\n用于拓展 Modern.js 内置的 Web Server，所有的页面请求都会经过 Hook。\n\nNOTE\n\n更多内容可以查看自定义 Web Server。\n\n\n使用姿势#\n\n\n\n自定义 Web Server\n\n使用该 API 前，请先执行 pnpm run new 新建「自定义 Web Serve」源码目录。\n\n\n\n\n函数签名#\n\n\n\n另外，不同 Hook 额外提供了不同的上下文。目前 Modern.js 支持 AfterMatch 和 AfterRender 两个 Hook。\n\n\n\n\n参数#\n\n * context：提供当前 Hook 上下文。\n   * response：提供一系列处理响应的操作\n   * request：提供一系列获取请求信息的操作\n   * router：提供对响应路由的快捷操作\n   * template：提供对响应内容的快捷操作\n * next：执行当前 Hook 的下一个监听函数（不影响整体服务端流程）。\n\n\n示例#\n\n\nRedirect#\n\n将页面重定向到站点外的页面，例如跳转到统一登录页：\n\n\n\n\nRewrite#\n\n将页面重写到当前站点的其他页面，例如同一个路由根据 UA 返回适配不同端的页面：\n\n\n\n\nHTML 内容注入#\n\n为页面注入某些与渲染主体无关的 HTML 内容，如脚本、页面骨架等：\n\n","routePath":"/apis/app/runtime/web-server/hook","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":83},{"text":"函数签名","id":"函数签名","depth":2,"charIndex":163},{"text":"参数","id":"参数","depth":3,"charIndex":249},{"text":"示例","id":"示例","depth":2,"charIndex":429},{"text":"Redirect","id":"redirect","depth":3,"charIndex":435},{"text":"Rewrite","id":"rewrite","depth":3,"charIndex":476},{"text":"HTML 内容注入","id":"html-内容注入","depth":3,"charIndex":531}],"domain":"","frontmatter":{"title":"Hook"},"version":""},{"id":357,"title":"Middleware","content":"#\n\n用于拓展 Modern.js 内置的 Web Server，与 Hook 不同的是，Middleware 可以直接操作 Node\n原生的请求、响应对象，并且可以使用框架拓展。\n\nNOTE\n\n在下一个大版本，Modern.js 将会使用新 Middleware 来替代该写法。\n\n推荐使用 UnstableMiddleware 处理页面请求。\n\nNOTE\n\n更多内容可以查看自定义 Web Server。\n\n\n使用姿势#\n\n\n\n自定义 Web Server\n\n使用该 API 前，请先执行 pnpm run new 新建「自定义 Web Server」源码目录。\n\n\n\n\n函数签名#\n\n\n\n\n参数#\n\n * context：提供当前 Hook 上下文。\n   * response：提供一系列处理响应的操作\n   * request：提供一系列获取请求信息的操作\n   * source：提供 Node.js 原生的 req 与 res 对象。\n * next：执行当前 Hook 的下一个监听函数（不影响整体服务端流程）。\n\nWARNING\n\nnext 函数的执行不影响后续内置流程，只控制下一个中间件是否执行。只有当响应被写入时，后续渲染流程才会中断。\n\n\n示例#\n\n\n服务端耗时打点#\n\n\n\n\n注入服务端工具 & 数据#\n\nModern.js 提供了 response.locals 属性用来存放当前请求的局部变量。\n\n\n\n\n框架拓展#\n\nMiddleware 还可以和 BFF 一样，使用运行时框架拓展。Modern.js 约定，当使用框架运行时拓展时，类型信息从\n@modern-js/runtime/{namespace} 下导出，Middleware 可以使用框架语法，例如框架中间件写法，以下是伪代码：\n\n\n\n默认情况下，在安装框架拓展插件后，Web Server 的框架拓展能力是关闭的。如果希望使用框架拓展，可以通过\nserver.enableFrameworkExt 开启。\n\nINFO\n\n框架拓展导出的类型名不一定为 Middleware，命名由框架拓展插件。","routePath":"/apis/app/runtime/web-server/middleware","lang":"zh","toc":[{"text":"使用姿势","id":"使用姿势","depth":2,"charIndex":206},{"text":"函数签名","id":"函数签名","depth":2,"charIndex":287},{"text":"参数","id":"参数","depth":3,"charIndex":297},{"text":"示例","id":"示例","depth":2,"charIndex":532},{"text":"服务端耗时打点","id":"服务端耗时打点","depth":3,"charIndex":538},{"text":"注入服务端工具 & 数据","id":"注入服务端工具--数据","depth":3,"charIndex":551},{"text":"框架拓展","id":"框架拓展","depth":3,"charIndex":617}],"domain":"","frontmatter":{"title":"Middleware"},"version":""},{"id":358,"title":"Unstable Middleware","content":"#\n\n用于拓展 Modern.js 内置的 Web Server。 未来 UnstableMiddleware 将替代 Middleware\n\n\n使用#\n\n\n\n\n类型#\n\nUnstableMiddleware\n\n\n\nUnstableMiddlewareContext\n\n\n\nUnstableNext\n\n\n\n\n用例#\n\n\nweb server 耗时打点#\n\n\n\n\n注入服务端数据，供页面 dataLoader 消费#\n\n\n\n\n\n\n\n\n重定向#\n\n\n\n\n修改响应体#\n\n","routePath":"/apis/app/runtime/web-server/unstable_middleware","lang":"zh","toc":[{"text":"使用","id":"使用","depth":2,"charIndex":72},{"text":"类型","id":"类型","depth":2,"charIndex":80},{"text":"用例","id":"用例","depth":2,"charIndex":153},{"text":"web server 耗时打点","id":"web-server-耗时打点","depth":3,"charIndex":159},{"text":"注入服务端数据，供页面 dataLoader 消费","id":"注入服务端数据供页面-dataloader-消费","depth":3,"charIndex":180},{"text":"重定向","id":"重定向","depth":3,"charIndex":215},{"text":"修改响应体","id":"修改响应体","depth":3,"charIndex":224}],"domain":"","frontmatter":{"title":"Unstable Middleware"},"version":""},{"id":359,"title":"2022 年 7 ~ 8 月更新内容","content":"#\n\n> 发表于 2022.09.05\n\nModern.js 7 ~ 8 月的最新版本为 v1.17.0，本双月的主要更新有：\n\n * 支持 React 18：完成框架和插件对 React 18 的适配。\n * 包版本统一：Modern.js 所有组成包的版本号进行统一，提供升级命令。\n * Modern.js Module 支持 bundle 构建：Modern.js Module 项目，支持对产物做 bundle 构建。\n * Reduck v1.1：发布 Reduck v1.1，使用文档全面更新。\n\n\n支持 React 18#\n\nModern.js 框架和相关插件完成对 React 18 的适配。现在，只需要将项目中的 react、react-dom 两个包的版本，升级到最新的\nReact 18 大版本，就可以使用 React 18 的新功能。\n\n注意，使用 @modern-js/create 命令默认创建的项目，安装的依赖 react、react-dom 的版本仍然为 17，如果希望使用 React\n18，请手动升级这两个包的版本。\n\n另外，SSR 流式渲染功能，目前尚在开发中，暂不支持。\n\n\nModern.js 包版本统一#\n\n之前，组成 Modern.js 的各个包的版本号并不统一，Modern.js\n自身的版本和这些包的版本缺少明确的对应关系。这不仅增加了我们的维护成本，而且给用户的使用和升级带来了很多困扰。\n\n从 v1.15.0 版本开始，Modern.js 自身的版本号和所有组成包的版本号，进行了统一。例如，Modern.js\nv1.15.0，意味着所有组成包的版本号也是 v1.15.0。 每次发布新版本，Modern.js 所有包都会使用统一的版本号执行发布。 Github 上仓库的\ntag 编号和 Modern.js 所有组成包的版本号是一一对应的。\n\n我们提供了专门的升级工具： @modern-js/upgrade，可以自动升级 Modern.js 到当前的最新版本。使用方式为，在项目根路径下执行：\n\n\n\n\nModern.js Module 支持 bundle 构建#\n\nModern.js Module 对底层实现进行重构，新增 output.buildConfig 配置，用于提供更加丰富的构建功能。\n\n新的 Modern.js Module 项目，不仅支持对产物做 bundless 构建，也支持 bundle 构建。通过配置 buildConfig 下的\nbuildType ，即可进行 bundle 构建：\n\n\n\nbuildConfig 下还支持 bundleOptions 配置，可以对构建行为做更多的自定义：如设置产物文件名、是否进行代码分片、设置代码压缩方式等。\n\n\nReduck v1.1#\n\nReduck 作为 Modern.js 的第一方状态管理方案，发布 v1.1 版本，增加对 React 18 Concurrent Rendering\n的支持，并对开发体验和功能稳定性做了大量优化。\n\n新增 API：\n\n * useStore ：可以在组件内获取当前组件树共享的 Store，满足在组件外访问 Model 的场景需求。\n * handleEffect：一个工具函数，可以极大地简化异步数据获取的逻辑代码。\n * connect： HOC 风格的 API，用于访问 Model。\n\n开发体验方面，优化 Reduck 组成包的组织结构，减少用户侧依赖数量，现在只需要引入 @modern-js-reduck/react\n一个包（Modern.js 中 Reduck 功能已内置，无需手动引入包）；优化 API 的 TS 类型定义，改进类型信息的自动推导，整体达到 TS\n支持开箱即用。\n\n此外，对 Reduck 使用文档 和 API 文档 做了全面更新，提供了更加丰富和详尽的内容。\n\n\n其他更新#\n\n\n命令和配置#\n\n新增命令\n\n * upgrade：自动升级 Modern.js 版本。功能同执行 npx @modern-js/upgrade 命令。\n * inspect：通过该命令可以输出当前项目使用的完整 webpack 配置。\n * gen-release-note：自动根据当前仓库的 changesets 信息生成发布日志。此外，我们提供了包版本管理专题文档，方便大家更好的认识和使用\n   changesets 及相关功能。\n\n新增配置\n\n * source.preEntry：用于配置全局脚本，这段脚本会早于页面的代码执行。\n\n\nBFF#\n\n * 新增 afterLambdaRegisted hook。用于使用 Express 框架时，在 BFF\n   函数注册路由之后执行。可以用来添加错误处理逻辑，新增路由等。\n * 优化使用 Express 框架开发场景下的热更新性能。在比较大的项目中，BFF 函数更改，热更新也可以在几十毫秒内完成。\n\n\nSSR#\n\n * SSR 产物添加 Sourcemap，优化服务端调试 SSR 代码的体验。\n\n\nWeb Server#\n\n * 支持按入口设置响应头，使用方式请参考文档。","routePath":"/community/blog/2022-0708-updates","lang":"zh","toc":[{"text":"支持 React 18","id":"支持-react-18","depth":2,"charIndex":256},{"text":"Modern.js 包版本统一","id":"modernjs-包版本统一","depth":2,"charIndex":508},{"text":"Modern.js Module 支持 bundle 构建","id":"modernjs-module-支持-bundle-构建","depth":2,"charIndex":880},{"text":"Reduck v1.1","id":"reduck-v11","depth":2,"charIndex":1168},{"text":"其他更新","id":"其他更新","depth":2,"charIndex":1632},{"text":"命令和配置","id":"命令和配置","depth":3,"charIndex":1640},{"text":"BFF","id":"bff","depth":3,"charIndex":1913},{"text":"SSR","id":"ssr","depth":3,"charIndex":2073},{"text":"Web Server","id":"web-server","depth":3,"charIndex":2122}],"domain":"","frontmatter":{"sidebar_position":99},"version":""},{"id":360,"title":"2022 年 9 ~ 10 月更新内容","content":"#\n\n> 发表于 2022.11.01\n\nModern.js 9 ~ 10 月的最新版本为 v1.21.0，本双月的主要更新有：\n\n * 支持 pnpm v7：完成框架对 pnpm v7 的支持。\n * 服务端增加 Typescript 作为 ts 文件编译器。\n\n\n支持 pnpm v7#\n\nModern.js 框架完成了对 pnpm v7 的变更适配。\n\n使用 npx @modern-js/create@modern-1 创建项目时会根据用户当前环境的 pnpm 版本进行安装依赖操作，并且在初始化项目中会在\n.npmrc 中添加 strict-peer-dependencies=false 配置，避免安装时由于 peerDependencies\n缺失导致安装依赖失败问题。 同时适配 release、deploy 命令对 pnpm v7 的支持。\n\npnpm v7 在命令传参方面姿势发生了变化，需注意：\n\n在使用 pnpm 调用 package.json 中的命令时，如果需要传递参数至 pnpm，需要将参数放到命令前。\n\n例如使用 pnpm --filter 参数执行 prepare 命令：\n\n\n\n如果需要传递参数至命令，需要将参数放到命令后。\n\n例如，在如下 package.json 配置中：\n\n\n\n执行 command 命令时携带参数方式为：\n\n\n\n\n服务端增加 Typescript 作为 ts 文件编译器#\n\n在 Modernjs 之前的版本中，我们为了保证前后端编译器的统一，使用了 Babel\n作为前后端默认的编译器，并保持相同的编译逻辑，但随着使用的项目增多，我们发现在一些服务端常用的语法场景下，Babel 编译 ts 有一些问题。\n\n因此，我们将服务端编译 ts 的编译器由 Babel 改为了 Typescript，在别名解析逻辑上与 Babel 版本保持一致，同样支持使用\ntsconfig.json 或者插件设置别名。\n\n在执行 build 命令时，已默认使用 Typescript 编译，并默认开启了类型校验，很多项目在 9、10 双月已经在使用。\n\n执行 dev 命令时，如果希望使用 Typescript 编译，需要安装 ts-node，tsconfig-paths 到\ndevDependencies，否则默认仍然使用 Babel 编译。在 Modern.js 2.0 中，我们将使用 ts-node 作为默认的编译器。\n\n\n其他更新#\n\n\n配置更新#\n\n * 支持在 tools.webpackChain 中获取 HtmlWebpackPlugin 对象，使用方式请参考文档。\n\n\n底层依赖升级#\n\n * husky 升级至 v8\n\n使用 npx @modern-js/create@modern-1 创建项目时，husky 会默认安装 v8 版本，并移除 package.json 中\nhusky 的配置，使用 .husky 文件夹的形式管理 husky 配置。\n\n在初次安装依赖时需要执行 npx husky install 进行 husky 初始化，默认项目会在 prepare 命令中完成，如果 husky\n配置未生效，可通过手动执行完成 husky 配置。\n\n\n功能预告#\n\nModern.js 团队目前除了正常开发维护 Modern 1.0 外，正在全力打造 Modern.js 2.0。\n\nModern.js 2.0 将带来新的构建体系，除了支持使用稳定的 webpack 进行构建，还即将支持将底层构建工具切换为自研的 Rust\nbundler，提供更流畅的编译速度。\n\nModern.js 2.0 将基于 React-Router v6 推荐嵌套路由作为新的路由方式；将默认支持 React 18 并提供 Streaming\nSSR 的支持，使用户体验更加流畅。","routePath":"/community/blog/2022-0910-updates","lang":"zh","toc":[{"text":"支持 pnpm v7","id":"支持-pnpm-v7","depth":2,"charIndex":133},{"text":"服务端增加 Typescript 作为 ts 文件编译器","id":"服务端增加-typescript-作为-ts-文件编译器","depth":2,"charIndex":586},{"text":"其他更新","id":"其他更新","depth":2,"charIndex":1037},{"text":"配置更新","id":"配置更新","depth":3,"charIndex":1045},{"text":"底层依赖升级","id":"底层依赖升级","depth":3,"charIndex":1116},{"text":"功能预告","id":"功能预告","depth":2,"charIndex":1361}],"domain":"","frontmatter":{"sidebar_position":98},"version":""},{"id":361,"title":"总览","content":"#\n\n欢迎来到 Modern.js 博客频道！\n\n在这里，你可以了解到 Modern.js 的最新进展和技术分享。\n\n\nAIGC 如何影响下一代文档搜索方案？#\n\n> 发表于 2023.05.11\n\n对于一个文档站点来说，搜索是一个很重要的功能，它可以帮助用户在繁杂的文档中快速找到自己想要的内容。而随着\nAIGC(人工智能生成内容)技术的发展，文档搜索领域也正在悄然发生变化。借助 AI\n强大的自然语言处理能力和上下文理解能力，我们可以把文档搜索做得更加智能化。本文将会介绍 AIGC 在文档中应用的技术原理，并分析一些业界已有的 AI 搜索产品。\n\n了解更多 →\n\n\nModern.js v2 发布：支持 Rspack 构建#\n\n> 发表于 2023.03.16\n\n大家好，很高兴地向大家宣布，Modern.js v2 版本已经正式发布了！\n\nModern.js 是字节跳动 Web Infra 团队开源的一套 Web 工程体系。在开源以来的一年多时间里，Modern.js\n保持稳定的迭代节奏，数十位贡献者参与了开发，累计提交 2000+ 个 Pull Request，并支持了 Rspack 构建、嵌套路由、流式渲染等新特性。\n\n在这篇文章里，我们会和大家一起聊一聊 Modern.js 在过去一年多时间里的变化。\n\n了解更多 →\n\n\nReact Streaming SSR 原理解析#\n\n> 发表于 2022.12.16\n\nReact 18 提供了一种新的 SSR 渲染模式： Streaming SSR。通过 Streaming SSR，我们可以实现以下两个功能：\n\n * Streaming HTML：服务端可以分段传输 HTML 到浏览器，而不是像 React 18\n   以前一样，需要等待服务端渲染完成整个页面后才返回给浏览器。这样，浏览器可以更快的启动 HTML 的渲染，提高 FP、FCP 等性能指标。\n * Selective Hydration：在浏览器端 hydration 阶段，可以只对已经完成渲染的区域做\n   hydration，而不需要等待整个页面渲染完成、所有组件的 JS bundle 加载完成，才能开始\n   hydration。这样可以更早的对已经完成渲染的区域做事件绑定，从而让页面获得更好的可交互性。\n\n了解更多 →\n\n\nReact Server Component 介绍#\n\n> 发表于 2022.12.01\n\nReact 官方对 Server Component 是这样介绍的: zero-bundle-size React Server Components。\n\n这是一种实验性探索，但相信该探索是个未来 React 发展的方向，与 React Server Component 相关的周边生态正在积极的建设当中。\n\n了解更多 →\n\n\n2022 年 9 ~ 10 月更新内容#\n\n> 发表于 2022.11.01\n\nModern.js 9 ~ 10 月的最新版本为 v1.21.0，本双月的主要更新有：\n\n * 支持 pnpm v7：完成框架对 pnpm v7 的支持。\n * 服务端增加 Typescript 作为 ts 文件编译器。\n\n了解更多 →\n\n\n2022 年 7 ~ 8 月更新内容#\n\n> 发表于 2022.09.05\n\nModern.js 7 ~ 8 月的最新版本为 v1.17.0，本双月的主要更新有：\n\n * 支持 React 18：完成框架和插件对 React 18 的适配。\n * 包版本统一：Modern.js 所有组成包的版本号进行统一，提供升级命令。\n * Modern.js Module 支持 bundle 构建：Modern.js Module 项目，支持对产物做 bundle 构建。\n * Reduck v1.1：发布 Reduck v1.1，使用文档全面更新。\n\n了解更多 →","routePath":"/community/blog/overview","lang":"zh","toc":[{"text":"AIGC 如何影响下一代文档搜索方案？","id":"aigc-如何影响下一代文档搜索方案","depth":2,"charIndex":59},{"text":"Modern.js v2 发布：支持 Rspack 构建","id":"modernjs-v2-发布支持-rspack-构建","depth":2,"charIndex":285},{"text":"React Streaming SSR 原理解析","id":"react-streaming-ssr-原理解析","depth":2,"charIndex":571},{"text":"React Server Component 介绍","id":"react-server-component-介绍","depth":2,"charIndex":986},{"text":"2022 年 9 ~ 10 月更新内容","id":"2022-年-9--10-月更新内容","depth":2,"charIndex":1196},{"text":"2022 年 7 ~ 8 月更新内容","id":"2022-年-7--8-月更新内容","depth":2,"charIndex":1357}],"domain":"","frontmatter":{"sidebar_position":1},"version":""},{"id":362,"title":"Modern.js v2 发布：支持 Rspack 构建","content":"#\n\n> 发表于 2023.03.16\n\n大家好，很高兴地向大家宣布，Modern.js v2 版本已经正式发布了！\n\nModern.js 是字节跳动 Web Infra 团队开源的一套 Web 工程体系。在开源以来的一年多时间里，Modern.js\n保持稳定的迭代节奏，数十位贡献者参与了开发，累计提交 2000+ 个 Pull Request，并支持了 Rspack 构建、嵌套路由、流式渲染等新特性。\n\n在这篇文章里，我们会和大家一起聊一聊 Modern.js 在过去一年多时间里的变化。\n\n\n\n\n背景#\n\n首先介绍一下我们为什么要做 Modern.js v2 版本，主要有以下几个原因：\n\n 1. 下沉更多能力：在字节跳动内部，Web Infra 团队整合了多个 Web 开发框架和解决方案，收敛技术栈，将通用能力下沉到底层的 Modern.js\n    工程体系中。\n 2. 拥抱 Rust 生态：随着社区中更多的前端工具链基于 Rust 重写，Modern.js 正在积极拥抱这一变化，将底层工具逐步替换为 Rust 实现。\n 3. 底层依赖升级：为了对 Modern.js 的底层依赖进行大版本升级，包括 React v18、React Router v6\n    等，从而引入流式渲染、嵌套路由等新能力。\n 4. 定位调整：从 2021 年开源以来，社区中的伙伴们给予我们很多有价值的反馈，这帮助我们对 Modern.js 的定位和架构进行更多地思考（详见下文）。\n\n以上因素促使我们完成了 Modern.js v2 版本。\n\n\n定位#\n\n在 v2 版本中，我们重新明确了 Modern.js 的定位：Modern.js 是字节跳动 Web\n工程体系的开源版本，它提供多个解决方案，来帮助开发者解决不同研发场景下的问题。\n\n目前我们开源了三个解决方案，分别面向 Web 应用开发场景、npm 包开发场景和文档站开发场景：\n\n\n\n作为 Modern.js 工程体系的一部分，以上每个解决方案都可以被单独使用，并且各自部署了独立的文档站点。开发者可以按需选择其中的一个或多个解决方案来使用。\n\n在代码层面，这三个解决方案按照统一的研发规范迭代，并复用同一套插件机制，因此，它们提供的研发体验也较为一致。大家如果对内部实现感兴趣，可以在 GitHub 上的\nModern.js 仓库 中找到它们的源代码。\n\n下面让我们来了解一下这三个解决方案提供的最新能力。\n\n\nModern.js 框架#\n\nModern.js 框架是一个基于 React 的渐进式 Web 开发框架。在字节跳动内部，我们将 Modern.js 封装为上层框架，并支撑了数千个 Web\n应用的研发。\n\n> 由于 Modern.js 框架的使用最为广泛，在下文中，我们会省略「框架」，直接称其为 Modern.js。\n\n在 Modern.js\n落地的过程中，我们收到很多业务同学提出的诉求，包括构建性能、框架的灵活性和可扩展性、页面加载性能等方面，相信社区中的开发者也会面临相似的问题。\n\n为了更好地满足这些诉求，Modern.js v2 提供了以下特性：\n\n * 通过引入 Rust 构建工具 —— Rspack 来提升构建性能。\n * 通过渐进式设计来保证框架的灵活性。\n * 通过插件系统来提供更好的可扩展性。\n * 通过嵌套路由来改善开发效率、优化加载性能。\n\n\nRspack 构建模式#\n\nModern.js v2 提供开箱即用的双构建工具支持，开发者可以在成熟的 Webpack 和更快的 Rspack 之间进行切换。大家对 Rspack\n可能还不太了解，Rspack 是由字节跳动开源的 Web 构建工具，基于 Rust 语言开发，具有高性能、可定制、兼容 Webpack 生态等特性。\n\n\n\n相较于 webpack，Rspack 的构建性能有明显提升，除了 Rust 带来的语言优势，这也来自于它的并行架构和增量编译等特性。经过 benchmark\n验证，Rspack 可以给 Modern.js 项目带来 5 ～ 10 倍编译性能的提升。\n\n\n\nModern.js 已支持在 Rspack 模式下使用框架的 70% 功能和配置项，包括服务器端渲染（SSR），静态站点生成（SSG）、嵌套路由、CSS\nModules 和 Tailwind CSS 等功能。除了功能，Modern.js 在 Rspack 模式下的配置项也与 Webpack\n模式基本一致，在我们的实际验证中，一个小型项目花几分钟就可以平滑切换到 Rspack 模式。\n\n目前，Rspack 项目以及 Modern.js 的 Rspack 模式仍在快速迭代中。在未来几个月内，我们将逐步对齐 Webpack 模式和 Rspack\n模式的绝大多数功能和配置，使更多项目能从 Webpack 平滑地过渡到 Rspack。\n\n> Rspack 已于 2023.03.10 号正式开源，你也可以在非 Modern.js 的项目中直接使用 Rspack 进行构建。如果你对 Rspack\n> 感兴趣，请阅读 「Rspack 正式发布了」来了解更多。\n\n\n渐进式设计#\n\n大家对 Modern.js 框架的第一印象可能是「一个大而全的框架」，但事实上，为了避免变得臃肿，Modern.js\n采取了渐进式设计，将所有功能建立在灵活的插件系统之上，因此具备按需启用和可插拔的能力。\n\nModern.js 期望能支持不同规模的项目研发，考虑到中大型项目和小型项目对功能的诉求存在差异，Modern.js\n的大多数功能都是按需启用的。在创建项目时，Modern.js 默认只安装核心模块，使 npm 依赖保持轻量；当需要用到额外功能时，你可以通过 modern\nnew 命令一键开启，并自动安装相关依赖。\n\n\n\n比如：\n\n * 对于基础的开发场景，项目中只需安装 Modern.js 的 CLI 工具 @modern-js/app-tools，即具备了开发调试、生产构建的能力。\n * 当你需要在应用中增加一些 BFF 接口时，可以执行 modern new 命令来启用 BFF 功能。启用后，Modern.js 会自动安装所需的 BFF\n   插件，以及某个 Node.js 框架对应的插件（如 Koa / Express）：\n\n\n\n目前，你可以通过 modern new 命令来按需开启以下功能，未来我们也会将更多功能加入到 new 命令中，使其能够被便捷地集成。\n\n\n\n\n插件系统#\n\n开发者在实际项目中使用 Web 研发框架时，除了使用开箱即用的能力，也会有很强的定制化诉求。因此，Modern.js 设计了一套灵活的插件系统来满足这一点。\n\nModern.js 可以划分为三个核心部分：CLI 工具、服务端和运行时。其中，CLI 工具负责提供 CLI 命令和打包构建能力；服务端提供 SSR、BFF\n等能力；运行时提供状态管理、路由等能力。\n\n\n\n我们为这三者分别设计了插件：\n\n * CLI 插件：对应 CLI 工具，负责控制 CLI 命令、打包构建流程。\n * Server 插件：对应服务端，用于处理服务端的生命周期以及客户端请求。\n * Runtime 插件：对应运行时，用于处理 React 组件渲染逻辑。\n\n这三种插件使用统一的 Hook 模型，并提供丰富的插件 API。比如，你可以使用插件做到：\n\n * 注册自定义的 CLI 命令\n * 修改 Rspack、PostCSS、Less、Sass 等基础工具的配置\n * 修改运行时需要渲染的 React 组件\n * 自定义控制台日志\n * 自定义 Node.js 服务器框架\n * ...\n\n在字节跳动内部，我们借助这些插件 API，结合公司内的基建和平台，封装出内部的企业级框架。如果你需要对 Modern.js 框架进行深度定制，也可以借助这些插件\nAPI 来完成。\n\n> 如果你对 Modern.js 的插件系统感兴趣，请阅读 「Modern.js - 自定义插件」文档。\n\n\n嵌套路由#\n\nModern.js v2 基于 React Router v6 提供了新的路由方式 —— 嵌套路由（Nested Routes）。\n\n如果大家了解过 Remix 或 Next.js 13，应该对嵌套路由不陌生了。嵌套路由与 Modern.js v1\n提供的约定式路由相似，也是一种基于文件系统的路由。\n\n在 Modern.js v2 中，我们约定在 src/routes\n目录下的文件，在应用启动时会自动生成对应的路由结构，页面的路由与文件结构是相呼应的，并且可以为资源加载带来一些性能优化。\n\nModern.js 的嵌套路由包含以下功能：\n\n * 资源加载：基于路由结构，并行加载多级路由资源，子组件资源加载不再受父组件渲染影响。并且将路由资源进一步细分，保证路由跳转时的最小资源加载。\n * 共享布局：在路由之间轻松共享 UI，同时保持状态，并避免多余的重新渲染。\n * 数据获取：基于路由结构完成多级路由的数据并行获取。\n\n在 Modern.js v2 中，只需要配置 runtime.router，即可开启嵌套路由：\n\n\n\n> 如果你对嵌套路由的细节感兴趣，请阅读「Modern.js - 路由」文档。\n\n\n流式渲染#\n\nModern.js v2 基于 React v18 的全新 API 支持了流式渲染（Streaming SSR）。\n\n如果大家关注去年 React v18 的版本更新，可能会注意到它提供了新的 Server Side APIs，并对 Suspense 做了完整支持。在\nModern.js v2 中，我们通过 React Router v6 暴露的能力，在框架层面支持了流式渲染。\n\n\n\n流式渲染利用 HTTP 的能力，允许将页面的 HTML\n分割成较小的块，并逐步将这些块从服务器发送到客户端。页面无需等待所有数据加载完成，即可呈现完整用户界面，因此与数据无关的局部内容能够更早地显示出来。\n\n在 Modern.js v2 中，只需要配置 server.ssr.mode，即可开启流式渲染：\n\n\n\n> 如果你想在 Modern.js 中使用 SSR 和流式渲染，请阅读「 Modern.js 服务端渲染（SSR）」文档。\n\n\nModern.js Module#\n\nModern.js Module 是我们针对 npm 包开发场景提供的解决方案，它为开发者提供了专业的 npm 包开发工具，能够更轻松地构建、调试和发布一个\nnpm 包。\n\n\n\nModern.js Module 的核心能力包括：\n\n * 构建能力：基于 esbuild 实现的构建工具，提供类型生成能力，能够高度定制构建产物。\n * 调试能力：基于 Storybook 调试项目，可以测试代码功能、验证构建产物可用性。\n * 版本管理能力：基于 Changeset 提供版本管理命令，涵盖从开发到发布的过程。\n * 扩展能力：提供包含丰富 Hooks 的插件机制，支持扩展调试能力，或对流程进行自定义。\n\n\n基于 esbuild 构建#\n\n在 v2 版本中，我们以 esbuild 为核心，扩展其插件机制，并结合 SWC 实现了一个通用的模块构建工具，它的特性包括：\n\n * 支持 bundle 和 bundleless 两种模式的构建。你可以选择构建产物的形式 —— 是打包处理后的 bundle 产物，还是直接通过\n   transform 处理的 bundleless 产物。\n * 相较于 esbuild，提供更丰富的构建能力和插件 Hook。例如，在样式方面，默认支持 Less、Sass、PostCSS 和 CSS\n   Modules，并支持静态资源处理、SVGR 等常用能力。这些能力在 bundle 和 bundleless 模式下均可使用。\n\n在生成 TS 类型文件上，Modern.js Module v2 也支持新的方式：\n\n * 类型文件的 bundle 处理：对生成的类型文件进行打包处理，生成一个单独的类型文件。\n * 类型文件里的别名处理：对生成的类型文件里包含的别名路径进行转换。\n\n总的来说，相较于 v1 版本，Modern.js Module v2 提供了更完整的构建能力，同时构建效率也有明显提升。\n\n> 如果你对 Modern.js Module 感兴趣，请移步「Modern.js Module 文档」来了解更多。\n\n\nRspress#\n\nRspress 是一个面向文档站场景的框架，它的目标是给开发者提供一个简单、高效、可扩展的文档站解决方案。\n\n\n\n目前，Rspress 包含如下能力：\n\n * 基于 Rspack 构建：项目构建和 HMR 速度飞快，提供愉悦的开发和生产部署体验。\n * 支持 MDX 语法：在普通 Markdown 语法的基础上可以嵌入 React 组件和 JSX 语法。\n * 全文搜索：内置开箱即用的全文搜索能力，基于 FlexSearch 实现。\n * 支持国际化：提供多语言文档切换功能，且支持多语言内容搜索。\n * 自定义主题：内置一套默认主题，你可以基于这套主题进行扩展，也可以从零定制一套自定义主题。\n * 插件机制：提供丰富的插件钩子能力，让你能够充分自定义扩展框架功能。\n\n我们做 Rspress 的初心，是为了解决我们团队内的文档站搭建需求。随着 Rspress 的功能逐渐完整，我们也将它开放给社区使用，使它能发挥更大的价值。\n\n目前，Rspress 仍处于 beta 测试状态，相关源代码已经开放在 Rspress 仓库 中，并提供了基础的\n使用文档。在未来，我们将继续投入，使之成为一个完成度更高的文档解决方案。\n\n\n致谢#\n\nModern.js 中的部分代码实现参考了社区中的开源项目，我们对这些项目表示衷心的感谢：\n\n * @modern-js/bundle-require: 修改自 bundle-require。\n * @modern-js/plugin: hook API 的实现参考了 farrow-pipeline。\n * @modern-js/builder: moduleScope 和 fileSize 插件参考了\n   create-react-app，TsConfigPathsPlugin 参考了\n   tsconfig-paths-webpack-plugin，generateMetaTags 函数参考了 html-webpack-plugin。\n * @modern-js/plugin-testing: jest runner 参考了 jest-cli。\n * @modern-js/plugin-data-loader: 部分实现参考了 remix。\n\n\n最后#\n\n现阶段 Modern.js 仍是一个很年轻的开源项目，在未来，我们将继续拥抱长期主义，持续打磨功能和文档，并以更透明的方式与社区共同协作。\n\n如果你有兴趣尝试一下 Modern.js，欢迎试用并留下你的反馈意见~\n\n * 官网：modernjs.dev\n * GitHub 仓库：github.com/web-infra-dev/modern.js","routePath":"/community/blog/v2-release-note","lang":"zh","toc":[{"text":"背景","id":"背景","depth":2,"charIndex":251},{"text":"定位","id":"定位","depth":2,"charIndex":672},{"text":"Modern.js 框架","id":"modernjs-框架","depth":2,"charIndex":1036},{"text":"Rspack 构建模式","id":"rspack-构建模式","depth":3,"charIndex":1423},{"text":"渐进式设计","id":"渐进式设计","depth":3,"charIndex":2149},{"text":"插件系统","id":"插件系统","depth":3,"charIndex":2706},{"text":"嵌套路由","id":"嵌套路由","depth":3,"charIndex":3346},{"text":"流式渲染","id":"流式渲染","depth":3,"charIndex":3861},{"text":"Modern.js Module","id":"modernjs-module","depth":2,"charIndex":4282},{"text":"基于 esbuild 构建","id":"基于-esbuild-构建","depth":3,"charIndex":4605},{"text":"Rspress","id":"rspress","depth":2,"charIndex":5183},{"text":"致谢","id":"致谢","depth":2,"charIndex":5707},{"text":"最后","id":"最后","depth":2,"charIndex":6144}],"domain":"","frontmatter":{"sidebar_label":"Modern.js v2 发布","sidebar_position":97},"version":""},{"id":363,"title":"贡献指南","content":"#\n\n感谢你有兴趣为 Modern.js 做贡献！在开始你的贡献之前，请花几分钟时间阅读以下指南。\n\n\n设置开发环境#\n\n\nFork 仓库#\n\nFork Modern.js 仓库到你的 GitHub 账户，然后 clone 到你的本地。\n\n\n安装 Node.js#\n\n我们推荐使用 Node.js 18。你可以通过以下命令查看当前使用的 Node.js 版本：\n\n\n\n如果你当前环境没有安装 Node.js，可以使用 nvm或者 fnm 来安装它。\n\n以下是如何通过 nvm 安装 Node.js 18 LTS 版本的示例：\n\n\n\n\n安装 pnpm#\n\n\n\n\n安装依赖#\n\n\n\n这将完成：\n\n * 安装所有依赖项\n * 在 monorepo 中的 packages 之间创建 symlinks\n * 运行 prepare 脚本来构建所有包（这将需要一些时间，但可以保证所有包都被正确构建）\n\n> 在此之后，你通常不需要一次性构建所有 packages。如果你正在开发的新功能依赖另一个 package 的最新代码，通常只构建指定的 package\n> 就足够了。\n\n\n设置 Git 邮箱#\n\n请确保在 中设置了电子邮件，当你提交 Pull Request 时将需要它。\n\n检查你的 git 客户端是否已配置邮箱：\n\n\n\n全局设置邮箱：\n\n\n\n针对本地仓库设置邮箱：\n\n\n\n\n代码变更和构建#\n\n当你在 fork 的仓库中设置完本地开发环境后，我们就可以开始开发了。\n\n\n创建一个新分支#\n\n建议在一个新的分支上开发，这样便于后续提交 pull request：\n\n\n\n\n构建 Package#\n\n要构建你要更改的 package，首先打开 package 目录，然后执行 build 命令：\n\n\n\n此外，你可以使用 --filter 选项从仓库根目录来构建指定的 package：\n\n\n\n构建所有包：\n\n\n\n如果你需要清理项目中的所有 node_modules/*，执行 reset 命令：\n\n\n\n\n测试#\n\n\n添加新测试#\n\n如果你进行了 bugfix，或者添加了需要测试的代码，请添加一些测试代码。\n\n你可以在 /tests 文件夹中添加单元测试用例。测试语法基于 Jest 和 Vitest。\n\n\n运行单元测试#\n\n在提交 pull request 之前，为了确保本次变更没有引入缺陷，你可以通过执行以下命令运行单元测试：\n\n\n\n你也可以使用 --filter 选项运行单个包的单元测试：\n\n\n\n\n运行 E2E 测试#\n\n除了单元测试之外，Modern.js 仓库还包括端到端 (E2E) 测试，用于检查整个应用程序的功能。\n\n你可以执行 test:e2e 命令来运行 E2E 测试：\n\n\n\n如果需要运行指定的测试，可以添加关键字进行过滤：\n\n\n\n\nLinting#\n\n为了帮助保持代码风格的一致性和可读性，我们使用 ESLint 对代码进行校验。\n\n你可以执行以下命令来运行 Linter：\n\n\n\n\nBenchmarking#\n\n你可以在 PR 的评论区中输入 !bench-framework 或 !bench-module 分别对 @modern-js/app-tools 和\n@modern-js/module-tools 做性能测试（这需要你具有 Collaborator 及以上的权限）。\n\n你可以根据评论输出的对比表格，重点关注构建时间和产物体积相关的指标，辅助进行相关性能判断与决策。\n\n依赖安装相关指标由于需要前置的发包流程，因此数据相对有滞后性，仅供参考。\n\n\n文档#\n\n目前 Modern.js 提供英文和中文文档。如果你熟悉中文，请同时更新中英文文档。否则，只需更新英文文档即可。\n\n你可以在 packages/document 文件夹中找到所有文档：\n\n\n\n文档站使用 Rspress 构建，文档内容可以使用 markdown 或 mdx 语法编写。详细使用方法可以参考 Rspress 文档。\n\nRspress 的源代码可以在 这个仓库 中找到。\n\n\n提交变更#\n\n\n添加 Changeset#\n\nModern.js 使用 Changesets 来管理版本和 Changelog。\n\n如果你修改了一些包，则需要为本次变更添加一个新的变更集。请运行 change 命令来选择更改的包并添加 changeset 信息。\n\n\n\n\n提交你的变更#\n\n提交变更到 fork 后的仓库，并 创建 pull request。\n\n\nPR 标题格式#\n\nPR 标题的格式遵循 Conventional Commits。\n\n一个例子：\n\n\n\n\n发布#\n\nModern.js 使用 Changesets 来管理版本和 changelog。\n\n仓库的维护者可以将所有包的新版本发布到 npm。\n\n以下是发布的步骤（我们通常使用 CI 进行发布，并避免在本地发布 npm 包）：\n\n 1. 拉取 main 分支的最新代码。\n 2. 安装依赖：\n\n\n\n 3. 构建 packages：\n\n\n\n 4. 升级版本：\n\n\n\n 5. 提交版本变更。\n\n","routePath":"/community/contributing-guide","lang":"zh","toc":[{"text":"设置开发环境","id":"设置开发环境","depth":2,"charIndex":51},{"text":"Fork 仓库","id":"fork-仓库","depth":3,"charIndex":61},{"text":"安装 Node.js","id":"安装-nodejs","depth":3,"charIndex":120},{"text":"安装 pnpm","id":"安装-pnpm","depth":3,"charIndex":266},{"text":"安装依赖","id":"安装依赖","depth":3,"charIndex":279},{"text":"设置 Git 邮箱","id":"设置-git-邮箱","depth":3,"charIndex":483},{"text":"代码变更和构建","id":"代码变更和构建","depth":2,"charIndex":586},{"text":"创建一个新分支","id":"创建一个新分支","depth":3,"charIndex":634},{"text":"构建 Package","id":"构建-package","depth":3,"charIndex":684},{"text":"测试","id":"测试","depth":2,"charIndex":849},{"text":"添加新测试","id":"添加新测试","depth":3,"charIndex":855},{"text":"运行单元测试","id":"运行单元测试","depth":3,"charIndex":951},{"text":"运行 E2E 测试","id":"运行-e2e-测试","depth":3,"charIndex":1051},{"text":"Linting","id":"linting","depth":2,"charIndex":1177},{"text":"Benchmarking","id":"benchmarking","depth":2,"charIndex":1253},{"text":"文档","id":"文档","depth":2,"charIndex":1493},{"text":"提交变更","id":"提交变更","depth":2,"charIndex":1692},{"text":"添加 Changeset","id":"添加-changeset","depth":3,"charIndex":1700},{"text":"提交你的变更","id":"提交你的变更","depth":3,"charIndex":1828},{"text":"PR 标题格式","id":"pr-标题格式","depth":3,"charIndex":1874},{"text":"发布","id":"发布","depth":2,"charIndex":1928}],"domain":"","frontmatter":{"sidebar_position":3},"version":""},{"id":364,"title":"版本发布","content":"#\n\n\n更新日志#\n\n请访问 GitHub - Release 来了解 Modern.js 每个版本的变更内容。\n\n\n版本规范#\n\nModern.js 遵循 Semantic Versioning 语义化版本规范。\n\n * 主版本号：包含不兼容的 API 变更。\n * 次版本号：包含向下兼容的功能性变更。\n * 修订号：包含向下兼容的问题修正。\n\n\n发版周期#\n\n * Modern.js 通常在每周四发布一个正式版本。\n * 当出现较为严重的问题时，我们会在当天发布修订版本。\n * 我们期望保持 Modern.js v2 的稳定和兼容，目前没有发布下一个 Major 版本的计划。\n\n\n版本升级#\n\n当你需要升级项目中的 Modern.js 版本时，可以使用 modern upgrade 命令，参考 版本升级。\n\n","routePath":"/community/releases","lang":"zh","toc":[{"text":"更新日志","id":"更新日志","depth":2,"charIndex":3},{"text":"版本规范","id":"版本规范","depth":2,"charIndex":58},{"text":"发版周期","id":"发版周期","depth":2,"charIndex":175},{"text":"版本升级","id":"版本升级","depth":2,"charIndex":295}],"domain":"","frontmatter":{"sidebar_position":2},"version":""},{"id":365,"title":"案例展示","content":"#\n\n欢迎来到 Modern.js 的案例展示页面！在这里，我们展示了一些基于 Modern.js 所实现的网站。\n\n如果你使用 Modern.js 构建了一个网站，欢迎你与社区分享它。只需回复 GitHub 讨论贴\n并附上你网站的链接即可。我们会定期收集内容，并将它们展示在当前页面。\n\n\n案例#","routePath":"/community/showcase","lang":"zh","toc":[{"text":"案例","id":"案例","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"sidebar_position":0},"version":""},{"id":366,"title":"开发团队","content":"#\n\nModern.js 的开发由字节跳动的 Modern.js 团队和社区贡献者驱动。\n\n\n核心团队成员#\n\n以下是 Modern.js 团队的核心成员：\n\n\n所有贡献者#\n\n感谢以下伙伴们为 Modern.js 做出的贡献：","routePath":"/community/team","lang":"zh","toc":[{"text":"核心团队成员","id":"核心团队成员","depth":2,"charIndex":46},{"text":"所有贡献者","id":"所有贡献者","depth":2,"charIndex":80}],"domain":"","frontmatter":{"sidebar_position":1},"version":""},{"id":367,"title":"autoLoadPlugins 自动注册插件","content":"#\n\n * 类型： boolean\n * 默认值： false\n\n用于配置 Modern.js 是否开启自动注册插件。\n\n\n手动注册插件#\n\n默认情况下，安装插件后，你需要在 modern.config.ts 文件中手动注册插件。\n\n\n\n\n自动注册插件#\n\n除了手段注册，Modern.js 还提供自动注册插件的方式: 将 autoLoadPlugin 配置项置为 true。\n\n\n\nModern.js 将通过以下几个步骤帮你自动注册插件\n\n 1. Modern.js 在内部维护一份官方插件列表。\n\n\n\n 2. Modern.js 将读取你的 package.json 文件，收集依赖信息。\n\n\n\n 3. Modern.js 观察到你安装了 @modern-js/plugin-tailwindcss 和 @modern-js/app-tools\n    等依赖后，将会引入插件自动注册。\n\n可以注意到这种方式相对黑盒，你甚至对加载插件的过程是无感知的。我们希望更多的细节暴露给开发者，能让开发者去控制这一过程。\n\n因此我们更加推荐你手动注册插件。","routePath":"/configure/app/auto-load-plugin","lang":"zh","toc":[{"text":"手动注册插件","id":"手动注册插件","depth":3,"charIndex":61},{"text":"自动注册插件","id":"自动注册插件","depth":3,"charIndex":119}],"domain":"","frontmatter":{"sidebar_position":22},"version":""},{"id":368,"title":"enableHandleWeb","content":"#\n\n * 类型： boolean\n\n * 默认值： false\n\nTIP\n\n请先在当前项目的根目录使用 new 命令 启用 BFF 功能。\n\n默认情况下，BFF 服务只能处理 BFF API 的请求。\n\n当该值设置为 true 时，页面请求流量也会经过 BFF，并且 Modern.js 内置的页面渲染的逻辑默认会作为 BFF 服务的最后一个中间件运行。\n\n","routePath":"/configure/app/bff/enable-handle-web","lang":"zh","toc":[],"domain":"","frontmatter":{"title":"enableHandleWeb"},"version":""},{"id":369,"title":"bff.prefix","content":"#\n\n * 类型： string\n\n * 默认值： /api\n\nTIP\n\n请先在当前项目的根目录使用 new 命令 启用 BFF 功能。\n\n默认情况下，BFF API 目录下的路由访问前缀是 /api, 如下目录结构：\n\n\n\napi/hello.ts 访问时对应的路由为 localhost:8080/api/hello。\n\n该配置选项可以修改默认的路由前缀：\n\n\n\n对应的 api/hello.ts 访问路由为 localhost:8080/api-demo/hello。","routePath":"/configure/app/bff/prefix","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_label":"prefix"},"version":""},{"id":370,"title":"builderPlugins 构建插件","content":"#\n\n * 类型： RsbuildPlugin[]\n * 默认值： []\n\n用于配置 Rsbuild 构建插件。\n\nRsbuild 是 Modern.js 底层的构建工具，请阅读 构建能力 了解相关背景。\n\n如果你想了解 Rsbuild 插件的编写方式，可以参考 Rsbuild - 插件系统。\n\n\n注意事项#\n\n该选项用于配置 Rsbuild 构建插件，如果你需要配置其他类型的插件，请选择对应的配置方式：\n\n * 配置 Modern.js 框架插件，请使用 plugins 配置项。\n * 配置 Rspack 或 webpack 插件，请使用 tools.bundlerChain 配置项。\n * 配置 Babel 插件，请使用 tools.babel 配置项。\n\n\n何时使用#\n\n大部分场景下，我们推荐你使用 Modern.js 框架插件，框架插件可以通过 plugins 字段进行注册。因为框架插件提供的 API 更丰富、能力更强，而\nRsbuild 插件提供的 API 只能用于构建场景。\n\n当你需要引用一些现有的 Rsbuild 插件（并且在 Modern.js 中没有相关能力），或是在不同的框架之间复用 Rsbuild 插件时，你可以使用\nbuilderPlugins 字段进行注册。\n\n\n示例#\n\n下面是 Rsbuild 插件的使用示例。\n\n\n使用 npm 上的插件#\n\n使用 npm 上的插件，需要通过包管理器安装插件，并通过 import 引入。\n\n\n\n\n使用本地插件#\n\n使用本地代码仓库中的插件，直接通过相对路径 import 引入即可。\n\n\n\n\n插件配置项#\n\n如果插件提供了一些自定义的配置项，可以通过插件函数的参数传入配置。\n\n","routePath":"/configure/app/builder-plugins","lang":"zh","toc":[{"text":"注意事项","id":"注意事项","depth":2,"charIndex":149},{"text":"何时使用","id":"何时使用","depth":2,"charIndex":335},{"text":"示例","id":"示例","depth":2,"charIndex":552},{"text":"使用 npm 上的插件","id":"使用-npm-上的插件","depth":3,"charIndex":580},{"text":"使用本地插件","id":"使用本地插件","depth":3,"charIndex":638},{"text":"插件配置项","id":"插件配置项","depth":3,"charIndex":686}],"domain":"","frontmatter":{"sidebar_position":21},"version":""},{"id":371,"title":"deploy.microFrontend","content":"#\n\n * 类型： object\n * 默认值： { enableHtmlEntry: true, externalBasicLibrary: false }\n\n\n\n开发者可使用 deploy.microFrontend 属性来配置微前端子应用的信息。\n\n注意\n\n需要先通过 pnpm run new 启用「微前端」 功能。\n\n\n示例#\n\n\n\n\n配置项#\n\n\nenableHtmlEntry#\n\n * 类型： boolean\n\n * 默认值： true\n\n是否启用 html 入口的功能，默认为 true，将子应用构建成 HTML 模式，Garfish 支持了 html 入口，可以开启开选项，体验对应功能，为\nHTML 入口时直接将子应用 entry 指向子应用的 html 即可。\n\n可以通过设置为 false, 表明子应用构建为 js，构建为 js 后子应用无法独立运行，为 JS 入口时将子应用的入口文件指向子应用的 JS\n\n\nexternalBasicLibrary#\n\n * 类型： boolean\n\n * 默认值： false\n\n是否 external 基础库，当设置为 true 时，当前子应用将会 external：react、react-dom，Modern.js 主应用会自动\nsetExternal 这两个基础库，如果其他类型的框架请通过 Garfish.setExternal 增加 react、react-dom 依赖","routePath":"/configure/app/deploy/microFrontend","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":164},{"text":"配置项","id":"配置项","depth":2,"charIndex":172},{"text":"enableHtmlEntry","id":"enablehtmlentry","depth":3,"charIndex":179},{"text":"externalBasicLibrary","id":"externalbasiclibrary","depth":3,"charIndex":417}],"domain":"","frontmatter":{"sidebar_label":"microFrontend"},"version":""},{"id":372,"title":"dev.assetPrefix","content":"#\n\n * 类型： boolean | string\n * 默认值： '/'\n\n设置开发环境下的静态资源 URL 前缀。\n\nassetPrefix 会影响构建产物中绝大部分静态资源的 URL，包括 JavaScript 文件、CSS\n文件、图片、视频等。如果指定了一个错误的值，则在加载这些资源时可能会出现 404 错误。\n\n该配置项仅用于开发环境。在生产环境下，请使用 output.assetPrefix 配置项进行设置。\n\n\nBoolean 类型#\n\n如果设置 assetPrefix 为 true，Builder 会使用 http://localhost:port/ 作为 URL 前缀：\n\n\n\n对应 JS 文件在浏览器中加载的地址如下：\n\n\n\n如果设置 assetPrefix 为 false 或不设置，则默认使用 / 作为访问前缀。\n\n\nString 类型#\n\n当 assetPrefix 的值为 string 类型时，字符串会作为前缀，自动拼接到静态资源访问 URL 上：\n\n\n\n对应 JS 文件在浏览器中加载的地址如下：\n\n\n\n\n与原生配置的区别#\n\ndev.assetPrefix 对应以下原生配置：\n\n * webpack 的 output.publicPath 配置。\n * Rspack 的 output.publicPath 配置。\n\n它与原生配置的区别在于：\n\n * dev.assetPrefix 仅在开发环境下生效。\n * dev.assetPrefix 默认会自动补全尾部的 /。\n * dev.assetPrefix 的值会写入 process.env.ASSET_PREFIX 环境变量。","routePath":"/configure/app/dev/asset-prefix","lang":"zh","toc":[{"text":"Boolean 类型","id":"boolean-类型","depth":3,"charIndex":215},{"text":"String 类型","id":"string-类型","depth":3,"charIndex":374},{"text":"与原生配置的区别","id":"与原生配置的区别","depth":3,"charIndex":472}],"domain":"","frontmatter":{"sidebar_label":"assetPrefix"},"version":""},{"id":373,"title":"dev.beforeStartUrl","content":"#\n\n * 类型： () => Promise | void\n * 默认值： undefined\n\ndev.beforeStartUrl 用于在打开 startUrl 前执行一段回调函数，该配置项需要与 dev.startUrl 一同使用。\n\n","routePath":"/configure/app/dev/before-start-url","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_label":"beforeStartUrl"},"version":""},{"id":374,"title":"dev.client","content":"#\n\n配置 Modern.js 在开发过程中注入的 client 代码，可以用于设置热更新对应的 WebSocket URL。\n\n * 类型：\n\n\n\n * 默认值：\n\n\n\n详细用法可参考 Rsbuild - dev.client。","routePath":"/configure/app/dev/client","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_label":"client"},"version":""},{"id":375,"title":"dev.hmr","content":"#\n\n * 类型： boolean\n * 默认值： true\n\n是否开启 Hot Module Replacement 热更新能力。\n\n当 hmr 设置为 false 时，将不再提供热更新和 react-refresh 功能。\n\n","routePath":"/configure/app/dev/hmr","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_label":"hmr"},"version":""},{"id":376,"title":"dev.host","content":"#\n\n * 类型： string\n * 默认值： 0.0.0.0\n\n指定 dev server 启动时监听的 host。\n\n默认情况下，dev server 会监听 0.0.0.0，这代表监听所有的网络接口，包括 localhost 和公网地址。\n\n如果你希望 dev server 只监听 localhost，可以设置为：\n\n","routePath":"/configure/app/dev/host","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_label":"host"},"version":""},{"id":377,"title":"dev.https","content":"#\n\n * 类型： boolean | { key: string; cert: string }\n * 默认值： false\n\n配置该选项后，可以开启 Dev Server 对 HTTPS 的支持，同时会禁用 HTTP 服务器。\n\n开启前：\n\n\n\n开启后：\n\n\n\n自动生成证书#\n\n你可以直接将 https 设置为 true，Builder 会基于 devcert 来自动生成 Dev Server 所需的 HTTPS 证书。\n\n使用这种方式时，你需要在当前项目中手动安装 devcert 依赖：\n\n\n\n然后配置 dev.https 为 true 即可：\n\n\n\n该方式有一定局限性，由于 devcert 目前不支持 IP addresses，因此访问 Network 域名时，会遇到「您的连接不是私密连接」的问题。\n\n此问题的解决方法为：点击 Chrome 浏览器问题页面的「高级」->「继续前往 192.168.0.1（不安全）」。\n\nTIP\n\nhttps 代理自动安装证书需要获取 root 权限, 请根据提示输入密码即可。 密码仅在信任证书时使用，不会泄漏或者用于其他环节。\n\n手动设置证书#\n\n你也可以在 dev.https 选项中手动传入 HTTPS 服务器所需要的证书和对应的私钥，这个参数将直接传递给 Node.js 中 https 模块的\ncreateServer。\n\n具体可以参考 https.createServer。\n\n","routePath":"/configure/app/dev/https","lang":"zh","toc":[{"text":"自动生成证书","id":"自动生成证书","depth":4,"charIndex":132},{"text":"手动设置证书","id":"手动设置证书","depth":4,"charIndex":492}],"domain":"","frontmatter":{"sidebar_label":"https"},"version":""},{"id":378,"title":"dev.liveReload","content":"#\n\n * 类型： boolean\n * 默认值： true\n\n是否在源文件变更时自动刷新页面。\n\n默认情况下，Modern.js 会优先使用 HMR 来更新模块。当 HMR 功能被禁用，或者某些场景 HMR 无法生效时，会自动降级到 liveReload。\n\n请查看 模块热更新 来了解更多内容。\n\n\n禁用 liveReload#\n\n如果你需要禁用 liveReload，可以将 dev.hmr 和 dev.liveReload 同时设置为 false，此时页面上不会发起 Web Socket\n请求到 dev server，也不会在文件变更时自动刷新页面。\n\n","routePath":"/configure/app/dev/live-reload","lang":"zh","toc":[{"text":"禁用 liveReload","id":"禁用-livereload","depth":2,"charIndex":151}],"domain":"","frontmatter":{"sidebar_label":"liveReload"},"version":""},{"id":379,"title":"dev.port","content":"#\n\n * 类型： number\n * 默认值： 8080\n\n设置 Dev Server 监听的端口号。\n\n默认情况下，Dev Server 会监听 8080 端口，并在端口被占用时自动递增端口号。\n\n\n示例#\n\n将端口设置为 3000：\n\n","routePath":"/configure/app/dev/port","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":101}],"domain":"","frontmatter":{"sidebar_label":"port"},"version":""},{"id":380,"title":"dev.progressBar","content":"#\n\n * 类型：\n\n\n\n * 默认值： true\n\n是否在编译过程中展示进度条。\n\n\n\n如果需要修改进度条左侧显示的文本内容，可以设置 id 选项：\n\n","routePath":"/configure/app/dev/progress-bar","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_label":"progressBar"},"version":""},{"id":381,"title":"dev.proxy","content":"#\n\n * 类型： string | Object\n * 默认值： null\n\n该选项用于在开发环境下启用基于 whistle 的全局代理，可以用来查看、修改 HTTP/HTTPS 请求、响应、也可以用作代理服务器。\n\n\n注册插件#\n\n使用该选项前，你需要提前安装和注册 @modern-js/plugin-proxy 插件：\n\n安装完成后，在 modern.config.ts 文件中注册插件：\n\n\n\n\nObject 类型#\n\ndev.proxy 的值为 Object 时，对象的 key 对应匹配的 pattern，对象的 value 对应匹配的 target。\n\n例如：\n\n\n\n请参考 whistle - 匹配模式 来了解详细用法。\n\n\nString 类型#\n\ndev.proxy 的值为 string 时， 可以用来指定单独的代理文件，例如：\n\n\n\n\n\n\n启动代理#\n\n执行 dev, 提示如下时，即代理服务器启动成功：\n\n\n\n访问 localhost:8899, 可以在 UI 界面上查看 Network 以及配置代理规则：\n\n\n\nINFO\n\nhttps 代理自动安装证书需要获取 root 权限, 请根据提示输入密码即可。密码仅在信任证书时使用，不会泄漏或者用于其他环节。","routePath":"/configure/app/dev/proxy","lang":"zh","toc":[{"text":"注册插件","id":"注册插件","depth":3,"charIndex":110},{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":202},{"text":"String 类型","id":"string-类型","depth":3,"charIndex":321},{"text":"启动代理","id":"启动代理","depth":3,"charIndex":381}],"domain":"","frontmatter":{"sidebar_label":"proxy"},"version":""},{"id":382,"title":"dev.setupMiddlewares","content":"#\n\n * 类型：\n\n\n\n * 默认值： undefined\n\n提供执行自定义函数和应用自定义中间件的能力。\n\n中间件的执行顺序是: unshift => 内置中间件 => push。\n\n\n\n一些特殊场景需求可能需要使用服务器 API：\n\n * sockWrite。允许向 HMR 客户端传递一些消息，HMR 客户端将根据接收到的消息类型进行不同的处理。如果你发送一个\n   \"content-changed \" 的消息，页面将会重新加载。\n\n","routePath":"/configure/app/dev/setup-middlewares","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_label":"setupMiddlewares"},"version":""},{"id":383,"title":"dev.startUrl","content":"#\n\n * 类型： boolean | string | string[] | undefined\n * 默认值： undefined\n\ndev.startUrl 用于设置 Dev Server 启动时自动在浏览器中打开的页面 URL。\n\n默认情况下，Dev Server 启动时不会打开任何页面。\n\n你可以设置为如下的值：\n\n\n\n\n端口号占位符#\n\n由于端口号可能会发生变动，你可以使用 占位符来指代当前端口号，Builder 会自动将占位符替换为实际监听的端口号。\n\n\n\n\n打开指定浏览器#\n\n在 MacOS 上，通过设置环境变量 BROWSER，你可以指定 Dev Server 在启动时打开的浏览器，支持如下的值：\n\n * Google Chrome Canary\n * Google Chrome Dev\n * Google Chrome Beta\n * Google Chrome\n * Microsoft Edge\n * Brave Browser\n * Vivaldi\n * Chromium\n\n建议设置在.env.local文件中。","routePath":"/configure/app/dev/start-url","lang":"zh","toc":[{"text":"端口号占位符","id":"端口号占位符","depth":3,"charIndex":166},{"text":"打开指定浏览器","id":"打开指定浏览器","depth":3,"charIndex":238}],"domain":"","frontmatter":{"sidebar_label":"startUrl"},"version":""},{"id":384,"title":"dev.watchFiles","content":"#\n\n * 类型：\n\n\n\n * 默认值： undefined\n\n监视指定文件和目录的变化。当文件发生变化时，页面将重新加载。\n\n如果 dev.hmr 和 dev.liveReload 都设置为 false，则 watchFiles 将被忽略。\n\nTIP\n\nWatchFiles 中文件发生变化时，不会触发配置文件的重新加载及重新编译。\n\n\n示例#\n\n你可以配置一个 glob 模式 / 目录 / 文件的列表，用于监视文件变化。\n\n\n\n你也可以通过传入一个包含 paths 和 options 属性的对象，来指定 chokidar 选项。\n\n","routePath":"/configure/app/dev/watch-files","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":169}],"domain":"","frontmatter":{"sidebar_label":"watchFiles"},"version":""},{"id":385,"title":"dev.writeToDisk","content":"#\n\n * 类型： boolean | ((filename: string) => boolean)\n * 默认值： (file: string) => !file.includes('.hot-update.')\n\n用于控制是否将开发环境的构建产物写入到磁盘上。\n\n\n写入内存#\n\n你可以选择将构建产物构建产物保存在 dev server 的内存中，从而减少文件操作产生的开销。\n\n只需要将 dev.writeToDisk 配置项设置为 false 即可：\n\n\n\n\n匹配部分文件#\n\n你也可以将 dev.writeToDisk 设置为函数来匹配一部分文件，函数返回 false 时不会写入文件，返回值 true 时会将文件写入磁盘。\n\n例如，Modern.js 会默认将文件写入磁盘，并排除热更新临时文件：\n\n","routePath":"/configure/app/dev/write-to-disk","lang":"zh","toc":[{"text":"写入内存","id":"写入内存","depth":2,"charIndex":135},{"text":"匹配部分文件","id":"匹配部分文件","depth":2,"charIndex":234}],"domain":"","frontmatter":{"sidebar_label":"writeToDisk"},"version":""},{"id":386,"title":"experiments.lazyCompilation","content":"#\n\n * 类型：\n\n\n\n * 默认值： false\n\n用于开启延迟编译（即按需编译）的能力。当开启此配置项时，Builder 会进行延迟编译，提升项目的编译启动速度。\n\n延迟编译只在开发环境下生效。\n\n\n延迟编译异步模块#\n\n延迟编译 dynamic import 引入的异步模块：\n\n\n\n开启 imports 选项后，所有的异步模块只有在被请求时才触发编译。如果你的项目是一个单页应用（SPA），并通过 dynamic import\n进行了路由拆分，那么会有明显的编译提速效果。\n\n\n延迟编译入口模块#\n\n除了延迟编译异步模块，你也可以选择同时延迟编译入口模块和异步模块。\n\n\n\n以上配置也可以简化为：\n\n\n\n开启 entries 选项后，当启动编译时，不会编译所有的页面，而是仅在路由跳转到对应的页面时，才对该页面进行编译。\n\n使用延迟编译入口模块时，有以下注意事项：\n\n * 只适用于多页应用（MPA），对单页应用（SPA）没有优化效果。\n * 当你访问一个页面时，由于要等待页面编译完成，会有一段时间的白屏。\n\n\n局限性#\n\n禁用拆包规则#\n\n当你开启延迟编译时，为了保证编译结果正常，Builder\n会在开发环境下禁用拆包规则。这不会影响生产环境的打包产物，但会导致开发环境和生产环境的打包产物有一定差异。\n\n使用代理#\n\nLazy Compilation 依赖 webpack 在本地启动的开发服务器，当你将某个域名代理到 localhost 进行开发时，Lazy\nCompilation 将无法正常工作。因此，如果你需要使用代理时，请禁用 Lazy Compilation。\n\n其他潜在的问题#\n\n考虑到 Lazy Compilation 仍然是 webpack\n的实验性功能，因此你在使用过程中，可能会遇到一些潜在的问题，比如编译产物的行为变化，或是编译出现异常。\n\n当你遇到这些问题时，可以参考 webpack 的 Issues 寻找解决方案，也可以关闭 lazyCompilation 配置项。","routePath":"/configure/app/experiments/lazy-compilation","lang":"zh","toc":[{"text":"延迟编译异步模块","id":"延迟编译异步模块","depth":3,"charIndex":102},{"text":"延迟编译入口模块","id":"延迟编译入口模块","depth":3,"charIndex":243},{"text":"局限性","id":"局限性","depth":3,"charIndex":461},{"text":"禁用拆包规则","id":"禁用拆包规则","depth":4,"charIndex":467},{"text":"使用代理","id":"使用代理","depth":4,"charIndex":560},{"text":"其他潜在的问题","id":"其他潜在的问题","depth":4,"charIndex":696}],"domain":"","frontmatter":{"sidebar_label":"lazyCompilation"},"version":""},{"id":387,"title":"experiments.sourceBuild","content":"#\n\n * 类型： boolean | PluginSourceBuildOptions\n * 默认值： false\n * 版本： MAJOR_VERSION.46.0\n\n用于开启源码构建的能力。当开启此配置项时，Builder 会读取子项目 package.json 的 source 字段对应的源码文件，并进行编译。\n\n\n\n更多信息可参考「源码构建模式」。\n\n\n选项#\n\nexperiments.sourceBuild 底层基于 Rsbuild 的 Source Build 插件 实现，你可以传入插件选项，比如：\n\n","routePath":"/configure/app/experiments/source-build","lang":"zh","toc":[{"text":"选项","id":"选项","depth":3,"charIndex":182}],"domain":"","frontmatter":{"sidebar_label":"sourceBuild"},"version":""},{"id":388,"title":"html.appIcon","content":"#\n\n * 类型： string\n * 默认值： undefined\n\n设置 iOS 系统下的 apple-touch-icon 图标的文件路径，可以设置为相对于项目根目录的相对路径，也可以设置为文件的绝对路径。暂不支持设置为\nCDN URL。\n\n配置该选项后，在编译过程中会自动将图标拷贝至 dist 目录下，并在 HTML 中添加相应的 link 标签。\n\n\n示例#\n\n设置为相对路径：\n\n\n\n设置为绝对路径：\n\n\n\n重新编译后，HTML 中自动生成了以下标签：\n\n","routePath":"/configure/app/html/app-icon","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":181}],"domain":"","frontmatter":{"sidebar_label":"appIcon"},"version":""},{"id":389,"title":"html.crossorigin","content":"#\n\n * 类型： boolean | 'anonymous' | 'use-credentials'\n * 默认值： false\n\n用于设置\n\n","routePath":"/configure/app/html/crossorigin","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":-1},{"text":"可选值","id":"可选值","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"sidebar_label":"crossorigin"},"version":""},{"id":390,"title":"html.disableHtmlFolder","content":"#\n\n * 类型： boolean\n * 默认值： false\n\n移除 HTML 产物对应的文件夹。开启该选项后，生成的 HTML 文件目录会从 [name]/index.html 变为 [name].html。\n\n\n示例#\n\n默认情况下，HTML 产物在 dist 目录下的结构为：\n\n\n\n开启 html.disableHtmlFolder 配置:\n\n\n\n重新编译后，HTML 产物在 dist 中的目录结构如下：\n\n\n\n> 如果需要设置 HTML 文件在 dist 目录中的路径，请使用 output.distPath.html 配置。","routePath":"/configure/app/html/disable-html-folder","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":108}],"domain":"","frontmatter":{"sidebar_label":"disableHtmlFolder"},"version":""},{"id":391,"title":"html.faviconByEntries","content":"#\n\n * 类型： Record\n * 默认值： undefined\n\n用于在多页面的场景下，为不同的页面设置不同的 favicon。\n\n整体用法与 favicon 一致，并且可以使用「入口名称」作为 key ，对各个页面进行单独设置。\n\nfaviconByEntries 的优先级高于 favicon，因此会覆盖 favicon 中设置的值。\n\nWARNING\n\nDeprecated：该配置已废弃，请使用 favicon 的函数用法代替。\n\n\n示例#\n\n\n\n重新编译后，可以看到:\n\n * 页面 foo 的 favicon 为 ./src/assets/foo.png。\n * 其他页面的 favicon 为 ./src/assets/default.png。","routePath":"/configure/app/html/favicon-by-entries","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":223}],"domain":"","frontmatter":{"sidebar_label":"faviconByEntries"},"version":""},{"id":392,"title":"html.favicon","content":"#\n\n * 类型： string ｜ Function\n * 默认值： undefined\n\n设置页面的 favicon 图标，可以设置为：\n\n * URL 地址。\n * 文件的绝对路径。\n * 相对于项目根目录的相对路径。\n\n配置该选项后，在编译过程中会自动将图标拷贝至 dist 目录下，并在 HTML 中添加相应的 link 标签。\n\n\n示例#\n\n设置为相对路径：\n\n\n\n设置为绝对路径：\n\n\n\n设置为 URL：\n\n\n\n重新编译后，HTML 中自动生成了以下标签：\n\n\n\n详细用法可参考 Rsbuild - html.favicon。","routePath":"/configure/app/html/favicon","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":171}],"domain":"","frontmatter":{"sidebar_label":"favicon"},"version":""},{"id":393,"title":"html.injectByEntries","content":"#\n\n * 类型： Record\n * 默认值： undefined\n\n用于在多页面的场景下，为不同的页面设置不同的 script 标签插入位置。\n\n整体用法与 inject 一致，并且可以使用「入口名称」作为 key ，对各个页面进行单独设置。\n\ninjectByEntries 的优先级高于 inject，因此会覆盖 inject 中设置的值。\n\nWARNING\n\nDeprecated：该配置已废弃，请使用 inject 的函数用法代替。\n\n\n示例#\n\n\n\n重新编译后，可以看到:\n\n * 页面 foo 的 script 标签会插入到 body 标签内。\n * 其他页面的 script 标签会插入到 head 标签内。","routePath":"/configure/app/html/inject-by-entries","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":224}],"domain":"","frontmatter":{"sidebar_label":"injectByEntries"},"version":""},{"id":394,"title":"html.inject","content":"","routePath":"/configure/app/html/inject","lang":"zh","toc":[{"text":"默认插入位置","id":"默认插入位置","depth":4,"charIndex":-1},{"text":"插入至 body 标签","id":"插入至-body-标签","depth":4,"charIndex":-1}],"domain":"","frontmatter":{"sidebar_label":"inject"},"version":""},{"id":395,"title":"html.metaByEntries","content":"#\n\n * 类型： Record\n * 默认值： undefined\n\n用于在多页面的场景下，为不同的页面设置不同的 meta 标签。\n\n整体用法与 meta 一致，并且可以使用「入口名称」作为 key ，对各个页面进行单独设置。\n\nmetaByEntries 的优先级高于 meta，因此会覆盖 meta 中设置的值。\n\nWARNING\n\nDeprecated：该配置已废弃，请使用 meta 的函数用法代替。\n\n\n示例#\n\n\n\n编译后，可以看到页面 foo 的 meta 为：\n\n\n\n其他页面的 meta 为：\n\n","routePath":"/configure/app/html/meta-by-entries","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":208}],"domain":"","frontmatter":{"sidebar_label":"metaByEntries"},"version":""},{"id":396,"title":"html.meta","content":"#\n\n * 类型： Object | Function\n * 默认值： undefined\n\n配置 HTML 页面的 标签。\n\n\n示例#\n\n当 meta 对象的 value 为字符串时，会自动将对象的 key 映射为 name，value 映射为 content。\n\n比如设置 description：\n\n\n\n最终在 HTML 中生成的 meta 标签为：\n\n\n\n详细用法可参考 Rsbuild - html.meta。","routePath":"/configure/app/html/meta","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":64}],"domain":"","frontmatter":{"sidebar_label":"meta"},"version":""},{"id":397,"title":"html.mountId","content":"","routePath":"/configure/app/html/mount-id","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":-1},{"text":"注意事项","id":"注意事项","depth":3,"charIndex":-1},{"text":"更新相关代码","id":"更新相关代码","depth":4,"charIndex":-1},{"text":"自定义模板","id":"自定义模板","depth":4,"charIndex":-1}],"domain":"","frontmatter":{"sidebar_label":"mountId"},"version":""},{"id":398,"title":"html.scriptLoading","content":"","routePath":"/configure/app/html/script-loading","lang":"zh","toc":[{"text":"defer","id":"defer","depth":3,"charIndex":-1},{"text":"blocking","id":"blocking","depth":3,"charIndex":-1},{"text":"module","id":"module","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"sidebar_label":"scriptLoading"},"version":""},{"id":399,"title":"html.tagsByEntries","content":"#\n\n * 类型： Record>\n * 默认值： undefined\n\n用于在多页面的场景下，为不同的页面注入不同的标签。\n\n整体用法与 tags 一致，并且可以使用「入口名称」作为 key ，对各个页面进行单独设置。\n\ntagsByEntries 的优先级高于 tags，因此会覆盖 tags 中设置的值。\n\nWARNING\n\nDeprecated：该配置已废弃，请使用 tags 的函数用法代替。\n\n\n示例#\n\n\n\n编译后，可以看到页面 foo 注入标签：\n\n\n\n其他页面则注入了：\n\n","routePath":"/configure/app/html/tags-by-entries","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":203}],"domain":"","frontmatter":{"sidebar_label":"tagsByEntries"},"version":""},{"id":400,"title":"html.tags","content":"","routePath":"/configure/app/html/tags","lang":"zh","toc":[{"text":"对象形式","id":"对象形式","depth":4,"charIndex":-1},{"text":"函数形式","id":"函数形式","depth":4,"charIndex":-1},{"text":"限制","id":"限制","depth":4,"charIndex":-1}],"domain":"","frontmatter":{"sidebar_label":"tags"},"version":""},{"id":401,"title":"html.templateByEntries","content":"#\n\n * 类型： Object\n * 默认值： undefined\n\n用于在多页面的场景下，为不同的页面设置不同的 HTML 模板。\n\n整体用法与 template 一致，并且可以使用「入口名称」作为 key ，对各个页面进行单独设置。\n\ntemplateByEntries 的优先级高于 template，因此会覆盖 template 设置的值。\n\nWARNING\n\nDeprecated：该配置已废弃，请使用 template 的函数用法代替。\n\n\n示例#\n\n","routePath":"/configure/app/html/template-by-entries","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":227}],"domain":"","frontmatter":{"sidebar_label":"templateByEntries"},"version":""},{"id":402,"title":"html.templateParametersByEntries","content":"#\n\n * 类型： Object\n * 默认值： undefined\n\n用于在多页面的场景下，为不同的页面设置不同的模板参数。\n\n整体用法与 templateParameters 一致，并且可以使用「入口名称」作为 key ，对各个页面进行单独设置。\n\ntemplateParametersByEntries 的优先级高于 templateParameters，因此会覆盖 templateParameters\n中设置的值。\n\nWARNING\n\nDeprecated：该配置已废弃，请使用 templateParameters 的函数用法代替。\n\n\n示例#\n\n","routePath":"/configure/app/html/template-parameters-by-entries","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":274}],"domain":"","frontmatter":{"sidebar_label":"templateParametersByEntries"},"version":""},{"id":403,"title":"html.templateParameters","content":"#\n\n * 类型： Object | Function\n * 默认值：\n\n\n\n定义 HTML 模板中的参数，对应 html-webpack-plugin 的 templateParameters 配置项。你可以使用配置为对象或者函数。\n\n如果是对象，会和默认参数合并。比如：\n\n\n\n如果是函数，会传入默认参数，你可以返回一个对象，用于覆盖默认参数。比如：\n\n\n\n详细用法可参考 Rsbuild - html.templateParameters。","routePath":"/configure/app/html/template-parameters","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_label":"templateParameters"},"version":""},{"id":404,"title":"html.template","content":"#\n\n * 类型： string | Function\n * 默认值：\n\n定义 HTML 模板的文件路径，对应 html-webpack-plugin 的 template 配置项。\n\n\n示例#\n\n使用自定义的 HTML 模板文件替代默认模板，可以添加如下设置：\n\n\n\n详细用法可参考 Rsbuild - html.template。","routePath":"/configure/app/html/template","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":93}],"domain":"","frontmatter":{"sidebar_label":"template"},"version":""},{"id":405,"title":"html.titleByEntries","content":"#\n\n * 类型： Record\n * 默认值： undefined\n\n用于在多页面的场景下，为不同的页面设置不同的 title。\n\n整体用法与 title 一致，并且可以使用「入口名称」作为 key ，对各个页面进行单独设置。\n\ntitleByEntries 的优先级高于 title，因此会覆盖 title 中设置的值。\n\nWARNING\n\nDeprecated：该配置已废弃，请使用 title 的函数用法代替。\n\n\n示例#\n\n\n\n重新编译后，可以看到:\n\n * 页面 foo 的 title 为 TikTok。\n * 其他页面的 title 为 ByteDance。","routePath":"/configure/app/html/title-by-entries","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":211}],"domain":"","frontmatter":{"sidebar_label":"titleByEntries"},"version":""},{"id":406,"title":"html.title","content":"#\n\n * 类型： string | Function\n * 默认值： undefined\n\n配置 HTML 页面的 title 标签，例如：\n\n\n\n详细用法可参考 Rsbuild - html.title。","routePath":"/configure/app/html/title","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_label":"title"},"version":""},{"id":407,"title":"output.assetPrefix","content":"#\n\n * 类型： string\n * 默认值： '/'\n\n在生产环境使用 CDN 部署时，可使用该选项设置静态资源的 URL 前缀。\n\nassetPrefix 会影响构建产物中绝大部分静态资源的 URL，包括 JavaScript 文件、CSS\n文件、图片、视频等。如果指定了一个错误的值，则在加载这些资源时可能会出现 404 错误。\n\n该配置项仅用于生产环境。在开发环境下，请使用 dev.assetPrefix 配置项进行设置。\n\n设置后，项目的 JavaScript、CSS、图片等静态资源的 URL 都会加上 output.assetPrefix 作为前缀：\n\n\n示例#\n\n\n\n构建之后，可以看到 JS 文件从以下地址加载：\n\n\n\n\n与原生配置的区别#\n\noutput.assetPrefix 对应以下原生配置：\n\n * webpack 的 output.publicPath 配置。\n * Rspack 的 output.publicPath 配置。\n\n它与原生配置的区别在于：\n\n * output.assetPrefix 仅在生产环境下生效。\n * output.assetPrefix 默认会自动补全尾部的 /。\n * output.assetPrefix 的值会写入 process.env.ASSET_PREFIX 环境变量。","routePath":"/configure/app/output/asset-prefix","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":286},{"text":"与原生配置的区别","id":"与原生配置的区别","depth":3,"charIndex":321}],"domain":"","frontmatter":{"sidebar_label":"assetPrefix"},"version":""},{"id":408,"title":"output.assetsRetry","content":"#\n\n * 类型： Object\n\noutput.assetsRetry 用于配置资源加载失败时的重试逻辑。配置类型如下:\n\n\n\n * 默认值： undefined\n\n由于该能力会往 HTML 中注入额外的一些运行时代码，因此我们默认关闭了该能力，如果需要开启该能力，你可以添加以下配置：\n\n\n\n当你开启该能力后，assetsRetry 的默认配置如下：\n\n\n\n\n示例#\n\n你可以通过 assetsRetry 配置项，来定制你的重试逻辑。\n\n如，通过 assetsRetry.domain 指定资源加载失败时的重试域名列表：\n\n\n\n添加以上配置后，当 cdn1.com 域名的资源加载失败时，请求域名会自动降级到 cdn2.com。\n\n如果 cdn2.com 的资源也请求失败，则会继续请求 cdn3.com。\n\nassetsRetry 是基于 Rsbuild 的 Assets Retry 插件实现的，并提供相同的配置项。你可以参考 Rsbuild - Assets\nRetry 插件 来了解所有可用的配置项。","routePath":"/configure/app/output/assets-retry","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":181}],"domain":"","frontmatter":{"sidebar_label":"assetsRetry"},"version":""},{"id":409,"title":"output.charset","content":"#\n\n * 类型： 'ascii' | 'utf8'\n * 默认值： 'ascii'\n\n默认情况下，Builder 的产物内容是纯 ASCII 的，并且会转义所有非 ASCII 字符。\n\n如果不希望进行转义，而是输出所有原始字符，可以将 output.charset 设置为 utf8。\n\n\n\n当 output.charset 为 utf8 时，Builder 会自动将 添加到生成的 HTML 文件中。","routePath":"/configure/app/output/charset","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_label":"charset"},"version":""},{"id":410,"title":"output.cleanDistPath","content":"#\n\n * 类型： boolean\n * 默认值： true\n\n是否在构建开始前清理 dist 目录下的所有文件。\n\n默认情况下，Builder 会自动清理 dist 目录下的文件，你可以把 cleanDistPath 设置为 false 来禁用该行为。\n\n","routePath":"/configure/app/output/clean-dist-path","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_label":"cleanDistPath"},"version":""},{"id":411,"title":"output.convertToRem","content":"#\n\n * 类型： boolean | object\n * 默认值： false\n\n通过设置 output.convertToRem，Builder 可进行如下处理：\n\n * 将 CSS 中的 px 转成 rem\n * 在 HTML 模版中插入运行时代码，对根元素 fontSize 进行设置\n\n\nBoolean 类型#\n\n当设置 output.convertToRem 为 true，将开启 rem 处理能力。\n\n\n\n此时，rem 配置默认如下：\n\n\n\n\nObject 类型#\n\n当 output.convertToRem 的值为 object 类型时，Builder 会根据当前配置进行 rem 处理。\n\n选项：\n\n名称                         类型         默认值     描述\nenableRuntime              boolean    true    是否自动生成 runtime 代码来动态计算根元素字体大小\ninlineRuntime              boolean    true    是否将 runtime 代码内联到 HTML 文件中。如果设置为 false，运行时代码会被抽取为一个独立的\n                                              convert-rem.[version].js 文件，并输出到产物目录下\nrootFontSize               number     50      根元素字体值\nmaxRootFontSize            number     64      最大根元素字体值\nwidthQueryKey              string     ''      根据 widthQueryKey 的值去 url query 中取 client width\nscreenWidth                number     375     UI 设计图宽度\nexcludeEntries             string[]   []      设置不注入 runtime 代码的页面入口，通常需要配合 pxtorem.exclude 使用\nsupportLandscape           boolean    false   横屏时使用 height 计算 rem\nuseRootFontSizeBeyondMax   boolean    false   超过 maxRootFontSize 时，是否使用 rootFontSize\npxtorem                    object             postcss-pxtorem 插件属性\n\n\n示例#\n\n","routePath":"/configure/app/output/convert-to-rem","lang":"zh","toc":[{"text":"Boolean 类型","id":"boolean-类型","depth":3,"charIndex":148},{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":228},{"text":"示例","id":"示例","depth":3,"charIndex":1189}],"domain":"","frontmatter":{"sidebar_label":"convertToRem"},"version":""},{"id":412,"title":"output.copy","content":"#\n\n * 类型： CopyPluginOptions | CopyPluginOptions['patterns']\n * 默认值： undefined\n\n将指定的文件或目录拷贝到构建输出目录中。\n\n例如，将 src/assets 下的文件直接拷贝到 dist 目录：\n\n\n\n更详细的配置项请参考：copy-webpack-plugin 文档。","routePath":"/configure/app/output/copy","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_label":"copy"},"version":""},{"id":413,"title":"output.cssModuleLocalIdentName","content":"#\n\n * 类型： string\n * 默认值：\n\n\n\n设置 CSS Modules 编译后生成的 className 格式。\n\n\n默认值#\n\ncssModuleLocalIdentName 在开发环境和生产环境有不同的默认值。\n\n在生产环境，Builder 会生成更简短的类名，从而减少构建产物的体积。\n\n\n\n\n模板字符串#\n\n在 cssModuleLocalIdentName 中，你可以使用以下模板字符串：\n\n * [name] - 源文件名称。\n * [local] - 原始类名。\n * [hash] - 字符串的哈希值。\n * [folder] - 文件夹的相对路径。\n * [path] - 源文件的相对路径。\n * [file] - 文件名和路径。\n * [ext] - 文件后缀名，包含点号。\n * [hash::] - 带有哈希设置的哈希。\n\nTIP\n\n在使用 Rspack 作为打包工具时, 暂不支持配置 。\n\n\n示例#\n\n将 cssModuleLocalIdentName 设置为其他值：\n\n","routePath":"/configure/app/output/css-module-local-ident-name","lang":"zh","toc":[{"text":"默认值","id":"默认值","depth":3,"charIndex":65},{"text":"模板字符串","id":"模板字符串","depth":3,"charIndex":156},{"text":"示例","id":"示例","depth":3,"charIndex":417}],"domain":"","frontmatter":{"sidebar_label":"cssModuleLocalIdentName"},"version":""},{"id":414,"title":"output.cssModules","content":"#\n\n * 类型：\n\n\n\n * 默认值：\n\n\n\n自定义 CSS 模块配置。\n\n\ncssModules.auto#\n\nauto 配置项允许基于文件名自动启用 CSS 模块。\n\n * 类型： boolean | RegExp | ((resourcePath: string) => boolean)\n\n * 默认值： undefined\n\n类型说明：\n\n * undefined: 根据 output.disableCssModuleExtension 配置项决定为哪些样式文件启用 CSS 模块。\n * true: 为所有匹配 /\\.module\\.\\w+$/i.test(filename) 正则表达式的文件启用 CSS 模块。\n * false: 禁用 CSS 模块。\n * RegExp: 为所有匹配 /RegExp/i.test(filename) 正则表达式的文件禁用 CSS 模块。\n * function: 为所有通过基于文件名的过滤函数校验的文件启用 CSS 模块。\n\n\n\n\ncssModules.exportLocalsConvention#\n\n导出的类名称的样式。\n\n * 类型： 'asIs' | 'camelCase' | 'camelCaseOnly' | 'dashes' | 'dashesOnly'\n\n * 默认值： 'camelCase'\n\n类型说明：\n\n * asIs 类名将按原样导出。\n * camelCase 类名将被驼峰化，原始类名仍然可用。\n * camelCaseOnly 类名将被驼峰化，原始类名不可用。\n * dashes 只有类名中的破折号会被驼峰化，原始类名仍然可用。\n * dashesOnly 只有类名中的破折号会被驼峰化，原始类名不可用。\n\n","routePath":"/configure/app/output/css-modules","lang":"zh","toc":[{"text":"cssModules.auto","id":"cssmodulesauto","depth":3,"charIndex":39},{"text":"cssModules.exportLocalsConvention","id":"cssmodulesexportlocalsconvention","depth":3,"charIndex":445}],"domain":"","frontmatter":{"sidebar_label":"cssModules"},"version":""},{"id":415,"title":"output.dataUriLimit","content":"#\n\n * 类型：\n\n\n\n * 默认值：\n\n\n\n设置图片、字体、媒体等静态资源被自动内联为 base64 的体积阈值。\n\n默认情况下，体积小于 10KB 的图片、字体、媒体等文件，会自动经过 Base64 编码，内联到页面中，不再会发送独立的 HTTP 请求。\n\n你可以通过修改 dataUriLimit 参数来调整这个阈值。\n\n其中：\n\n * svg：表示 SVG 图片的体积阈值。\n * font：表示字体文件的体积阈值。\n * image：表示非 SVG 图片的体积阈值。\n * media：表示视频等媒体资源的体积阈值。\n\n\n示例#\n\n修改图片资源的阈值为 5000 Bytes，设置视频资源不内联：\n\n","routePath":"/configure/app/output/data-uri-limit","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":266}],"domain":"","frontmatter":{"sidebar_label":"dataUriLimit"},"version":""},{"id":416,"title":"output.disableCssExtract","content":"#\n\n * 类型： boolean\n * 默认值： false\n\n是否禁用 CSS 提取逻辑，并将 CSS 文件内联到 JS 文件中。\n\n默认情况下，Builder 会把 CSS 提取为独立的 .css 文件，并输出到构建产物目录。设置该选项为 true 后，CSS 文件会被内联到 JS\n文件中，并在运行时通过","routePath":"/configure/app/output/disable-css-extract","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"sidebar_label":"disableCssExtract"},"version":""},{"id":417,"title":"output.disableCssModuleExtension","content":"#\n\n * 类型： boolean\n * 默认值： false\n\n是否将源码目录下的所有样式文件当做 CSS Modules 模块进行处理。\n\n在默认情况下，只有 *.module.css 结尾的文件才被视为 CSS Modules 模块。开启该配置项之后，会将源码目录下的所有 *.css 样式文件当做\nCSS Modules 模块。\n\n.sass、.scss 和 .less 文件的处理规则与 .css 文件一致，也会受到 disableCssModuleExtension 的影响。\n\nTIP\n\n我们不推荐开启此配置项，因为开启 disableCssModuleExtension 后，CSS Modules 文件和普通 CSS\n文件无法得到明确的区分，不利于长期维护。\n\n\n示例#\n\n\n\n\n规则#\n\n以下是对 CSS Modules 判断规则的详细解释：\n\n未开启 disableCssModuleExtension（默认）#\n\n以下文件会视为 CSS Modules：\n\n * 所有 *.module.css 文件\n\n以下文件会视为普通 CSS：\n\n * 所有 *.css 文件（不含 .module）\n * 所有 *.global.css 文件\n\n开启 disableCssModuleExtension#\n\n以下文件会视为 CSS Modules：\n\n * 源码目录下的 *.css 和 *.module.css 文件\n * node_modules 下的 *.module.css 文件\n\n以下文件会视为普通 CSS：\n\n * 所有 *.global.css 文件\n * node_modules 下的 *.css 文件（不含 .module）\n\nTIP\n\n对于 node_modules 中的 CSS Modules 文件，请始终使用 *.module.css 后缀。","routePath":"/configure/app/output/disable-css-module-extension","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":340},{"text":"规则","id":"规则","depth":3,"charIndex":348},{"text":"未开启 disableCssModuleExtension（默认）","id":"未开启-disablecssmoduleextension默认","depth":4,"charIndex":382},{"text":"开启 disableCssModuleExtension","id":"开启-disablecssmoduleextension","depth":4,"charIndex":529}],"domain":"","frontmatter":{"sidebar_label":"disableCssModuleExtension"},"version":""},{"id":418,"title":"output.disableFilenameHash","content":"#\n\n * 类型： boolean\n * 默认值： false\n\n移除生产环境的构建产物名称中的 hash 值。\n\n在生产环境构建后，会自动在文件名中间添加 hash 值，如果不需要添加，可以通过 output.disableFilenameHash 配置来禁用该行为。\n\nWARNING\n\nDeprecated：该配置已废弃，请使用 output.filenameHash 的布尔用法代替。\n\n\n示例#\n\n默认情况下，构建后的产物名称为：\n\n\n\n添加 output.disableFilenameHash 配置：\n\n\n\n重新构建，产物的名称变为：\n\n","routePath":"/configure/app/output/disable-filename-hash","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":198}],"domain":"","frontmatter":{"sidebar_label":"disableFilenameHash"},"version":""},{"id":419,"title":"output.disableInlineRuntimeChunk","content":"#\n\n * 类型： boolean\n * 默认值： false\n\n用于控制是否将打包工具的 runtime 代码内联到 HTML 中。\n\n什么是 runtimeChunk\n\n当 Builder 构建完成后，会在 dist 目录生成 builder-runtime.js 文件，该文件为 webpack 或 Rspack 的\nruntime 代码，即 runtimeChunk。\n\nruntimeChunk 是一段运行时代码，它由 webpack 或 Rspack 提供，包含必要的模块处理逻辑，比如模块加载、模块解析等，具体可参考\nRuntime。\n\n在生产环境下，Builder 默认会将 runtimeChunk 文件内联到 HTML 文件中，而不是写到产物目录中，这样做是为了减少文件请求的数量。\n\n\n禁用内联#\n\n如果你不希望 runtimeChunk 文件被内联到 HTML 文件里，可以把 disableInlineRuntimeChunk 设置为\ntrue，此时会生成一个独立的 builder-runtime.js 文件。\n\n\n\n\n合并到页面文件中#\n\n如果你不希望生成独立的 runtimeChunk 文件，而是想让 runtimeChunk 代码被打包到页面的 JS 文件里，可以这样设置：\n\n","routePath":"/configure/app/output/disable-inline-runtime-chunk","lang":"zh","toc":[{"text":"禁用内联","id":"禁用内联","depth":3,"charIndex":353},{"text":"合并到页面文件中","id":"合并到页面文件中","depth":3,"charIndex":473}],"domain":"","frontmatter":{"sidebar_label":"disableInlineRuntimeChunk"},"version":""},{"id":420,"title":"output.disableMinimize","content":"#\n\n * 类型： boolean\n * 默认值： false\n\n是否禁用生产环境下的代码压缩。\n\n默认情况下，JS 代码和 CSS 代码会在生产环境构建时被自动压缩，从而提升页面性能。如果你不希望执行代码压缩，可以将 disableMinimize 设置为\ntrue。\n\n\n\nTIP\n\n该配置项通常用于代码调试和问题排查，不建议在生产环境禁用代码压缩，否则会导致页面性能显著下降。","routePath":"/configure/app/output/disable-minimize","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_label":"disableMinimize"},"version":""},{"id":421,"title":"output.disableNodePolyfill","content":"#\n\n * 类型： boolean\n * 默认值： true\n\n该配置项用于控制是否在代码中注入 Node 模块的 Polyfill。\n\n默认情况下，我们不会将 Node Polyfill 注入到代码中，以避免造成代码体积增大。如果你需要注入 Node Polyfill，可以将\noutput.disableNodePolyfill 设置为 false：\n\n\n\n该配置项基于 Rsbuild 的 Node Polyfill 插件实现，你可以阅读 Rsbuild - Node Polyfill 插件 文档来了解详细信息。","routePath":"/configure/app/output/disable-node-polyfill","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_label":"disableNodePolyfill"},"version":""},{"id":422,"title":"output.disableSourceMap","content":"#\n\n * 类型：\n\n\n\n * 默认值：\n\n\n\n是否禁用 Source Map 生成。\n\n什么是 Source Map\n\nSource Map 是保存源代码映射关系的信息文件，它记录了编译后的代码的每一个位置，以及所对应的编译前的位置。通过 Source\nMap，可以在调试编译后的代码时，直接查看对应的源代码。\n\n默认情况下，Builder 的 Source Map 生成规则如下：\n\n * 在开发环境构建时，会生成 JS 文件和 CSS 文件的 SourceMap，便于进行开发调试。\n * 在生产环境构建时，会生成 JS 文件的 Source Map，用于调试和排查线上问题；不会生成 CSS 文件的 Source Map。\n\n如果项目不需要 Source Map，可以关闭该功能，从而提升构建的速度。\n\n\n\n如果需要开启开发环境的 Source Map，并在生产环境禁用，可以设置为：\n\n\n\n如果需要单独控制 JS 文件或 CSS 文件的 Source Map，可以参考下方设置：\n\n","routePath":"/configure/app/output/disable-source-map","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_label":"disableSourceMap"},"version":""},{"id":423,"title":"output.disableSvgr","content":"#\n\n * 类型： boolean\n * 默认值： false\n\n是否调用 SVGR 将 SVG 转化为 React 组件。如果设置为 true，将把所有的.svg 文件视为资源处理。\n\n默认情况下，在 JS 文件中引用 SVG 资源时，Builder 会调用 SVGR，将 SVG 图片转换为一个 React 组件。 如果你确定项目内的所有\nSVG 资源都没有当成 React 组件使用时，可以通过将 disableSvgr 设置为 true 来关闭此项转换，以提升构建性能。\n\n","routePath":"/configure/app/output/disable-svgr","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_label":"disableSvgr"},"version":""},{"id":424,"title":"output.disableTsChecker","content":"#\n\n * 类型： boolean\n * 默认值： false\n\n是否禁用编译过程中的 TypeScript 类型检查。\n\n默认情况下，Builder 执行构建的过程中，会在一个独立的进程里运行 TypeScript 类型检查工具，它的检查逻辑与 TypeScript 原生的 tsc\n命令一致，你可以通过 tsconfig.json 或是 Builder 的 tools.tsChecker 配置项来自定义检查行为。\n\n\n阻塞编译#\n\n * 在开发环境构建时，类型错误不会阻塞编译流程。\n * 在生产环境构建时，类型错误会导致构建失败，以保证生产环境代码的稳定性。\n\n\n示例#\n\n禁用 TypeScript 类型检查：\n\n\n\n禁用开发环境构建时的类型检查：\n\n\n\n禁用生产环境构建时的类型检查：\n\n\n\nTIP\n\n不建议在生产环境构建时禁用类型检查，这会导致线上代码的稳定性下降，请谨慎使用。","routePath":"/configure/app/output/disable-ts-checker","lang":"zh","toc":[{"text":"阻塞编译","id":"阻塞编译","depth":3,"charIndex":211},{"text":"示例","id":"示例","depth":3,"charIndex":285}],"domain":"","frontmatter":{"sidebar_label":"disableTsChecker"},"version":""},{"id":425,"title":"output.distPath","content":"#\n\n * 类型：\n\n\n\n * 默认值：\n\n\n\n设置构建产物的输出目录，Builder 会根据产物的类型输出到对应的子目录下。\n\n其中：\n\n * root: 表示所有构建产物输出的根目录。\n * html：表示 HTML 文件的输出目录。\n * js：表示 JavaScript 文件的输出目录。\n * css：表示 CSS 样式文件的输出目录。\n * svg：表示 SVG 图片的输出目录。\n * font：表示字体文件的输出目录。\n * wasm：表示 WebAssembly 文件的输出目录。\n * image：表示非 SVG 图片的输出目录。\n * media：表示视频等媒体资源的输出目录。\n * server: 表示服务端产物的输出目录，仅在 target 为 node 时有效。\n * worker: 表示 worker 产物的输出目录，仅在 target 为 service-worker 时有效。\n\n\n根目录#\n\nroot 是构建产物的根目录，可以为相对路径或绝对路径。如果 root 的值为相对路径，则会基于当前项目的根目录拼接为绝对路径。\n\n其他目录只能为相对路径，并且会相对于 root 进行输出。\n\n\n示例#\n\n以 JavaScript 文件为例，会输出到 distPath.root + distPath.js 目录，即为 dist/static/js。\n\n如果需要将 JavaScript 文件输出到 build/resource/js 目录，可以这样设置：\n\n","routePath":"/configure/app/output/dist-path","lang":"zh","toc":[{"text":"根目录","id":"根目录","depth":3,"charIndex":409},{"text":"示例","id":"示例","depth":3,"charIndex":513}],"domain":"","frontmatter":{"sidebar_label":"distPath"},"version":""},{"id":426,"title":"output.enableAssetFallback","content":"#\n\n * 类型： boolean\n * 默认值： false\n\n开启该选项后，当编译过程中遇到无法识别的文件类型时，会直接将该文件直接输出到产物目录；否则会抛出一个异常。\n\n\n示例#\n\n开启配置项：\n\n\n\n在代码中引用一个未知类型的模块：\n\n\n\n编译后，foo.xxx 会被自动输出到 dist/static/media 目录下。\n\n你可以通过 output.distPath.media 和 output.filename.media 配置项来控制 fallback 后的输出路径和文件名称。\n\nTIP\n\n开启该配置会导致 webpack 配置中的 rules 结构变化，增加一层额外的 oneOf 嵌套结构。大多数情况下，我们不推荐你使用此配置。","routePath":"/configure/app/output/enable-asset-fallback","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":88}],"domain":"","frontmatter":{"sidebar_label":"enableAssetFallback"},"version":""},{"id":427,"title":"output.enableAssetManifest","content":"#\n\n * 类型： boolean\n * 默认值： false\n\n是否生成 manifest 文件，该文件包含所有构建产物的信息。\n\n\n示例#\n\n添加以下配置来开启：\n\n\n\n开启后，当编译完成时，会自动生成 dist/asset-manifest.json 文件：\n\n\n\n如果当前项目有多种类型构建产物，比如包含了 SSR 构建产物，那么会生成多份 manifest.json 文件。\n\n * web 产物：asset-manifest.json\n * node 产物：asset-manifest-node.json","routePath":"/configure/app/output/enable-asset-manifest","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":67}],"domain":"","frontmatter":{"sidebar_label":"enableAssetManifest"},"version":""},{"id":428,"title":"output.enableCssModuleTSDeclaration","content":"#\n\n * 类型： boolean\n * 默认值： false\n\n是否生成 CSS Modules 的 TypeScript 声明文件。\n\n\nExample#\n\n启用 CSS Module TypeScript 声明，比如：\n\n\n\n项目构建完成后，每个 CSS Module 文件都会生成一个 .d.ts 文件。例如：\n\n","routePath":"/configure/app/output/enable-css-module-tsdeclaration","lang":"zh","toc":[{"text":"Example","id":"example","depth":3,"charIndex":70}],"domain":"","frontmatter":{"sidebar_label":"enableCssModuleTSDeclaration"},"version":""},{"id":429,"title":"output.disableInlineRouteManifests","content":"#\n\n * 类型: boolean\n * 默认值: false\n\n当使用约定式路由时，框架为了做一些优化，会向客户端中注入路由信息，默认情况下路由信息会注入到 html 中， 当该配置为 true\n时，路由信息会注入到一个单独的 JS 文件中。\n\nExample:\n\n","routePath":"/configure/app/output/enable-inline-route-manifests","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_label":"disableInlineRouteManifests"},"version":""},{"id":430,"title":"output.enableInlineScripts","content":"#\n\n * 类型：\n\n\n\n * 默认值： false\n\n用来控制生产环境中是否用\n\n\n通过正则匹配#\n\n当你需要内联产物中的一部分 JS 文件时，你可以将 enableInlineScripts 设置为一个正则表达式，匹配需要内联的 JS 文件的 URL。\n\n比如，将产物中的 main.js 内联到 HTML 中，你可以添加如下配置：\n\n\n\nTIP\n\n生产环境的文件名中默认包含了一个 hash 值，比如 static/js/main.18a568e5.js。因此，在正则表达式中需要通过 \\w+ 来匹配\nhash。\n\n\n通过函数匹配#\n\n你也可以将 output.enableInlineScripts 设置为一个函数，函数接收以下参数：\n\n * name：文件名，比如 static/js/main.18a568e5.js。\n * size：文件大小，单位为 byte。\n\n比如，我们希望内联小于 10KB 的资源，可以添加如下配置：\n\n","routePath":"/configure/app/output/enable-inline-scripts","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":-1},{"text":"通过正则匹配","id":"通过正则匹配","depth":3,"charIndex":42},{"text":"通过函数匹配","id":"通过函数匹配","depth":3,"charIndex":261}],"domain":"","frontmatter":{"sidebar_label":"enableInlineScripts"},"version":""},{"id":431,"title":"output.enableInlineStyles","content":"","routePath":"/configure/app/output/enable-inline-styles","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":-1},{"text":"通过正则匹配","id":"通过正则匹配","depth":3,"charIndex":-1},{"text":"通过函数匹配","id":"通过函数匹配","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"sidebar_label":"enableInlineStyles"},"version":""},{"id":432,"title":"output.enableLatestDecorators","content":"#\n\n * 类型： boolean\n * 默认值： false\n\n是否要使用 新版 decorator 提案 进行编译。\n\n默认情况下，Builder 在编译装饰器时采用 旧版 decorator 提案。\n\n将 output.enableLatestDecorators 设置为 true 时，Builder 会采用新版 decorator 提案 (2018-09\n版本) 进行编译。\n\nWARNING\n\nDeprecated：该配置已废弃，请使用 source.decorators 配置项代替。\n\n","routePath":"/configure/app/output/enable-latest-decorators","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_label":"enableLatestDecorators"},"version":""},{"id":433,"title":"output.externals","content":"#\n\n * 类型： string | object | function | RegExp\n * 默认值： undefined\n\n在构建时，防止将代码中某些 import 的依赖包打包到 bundle 中，而是在运行时再去从外部获取这些依赖。\n\n详情请见: webpack 外部扩展 (Externals)\n\n\n示例#\n\n将 react-dom 依赖从构建产物中剔除。为了在运行时获取这个模块, react-dom 的值将全局检索 ReactDOM 变量。\n\n\n\nTIP\n\n当构建 Web Worker 产物时，externals 将不会生效。这是因为 Worker 环境不支持通过访问全局变量。","routePath":"/configure/app/output/externals","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":155}],"domain":"","frontmatter":{"sidebar_label":"externals"},"version":""},{"id":434,"title":"output.filenameHash","content":"#\n\n * 类型： boolean | string\n * 默认值： true\n\n在生产环境构建后，是否在产物的文件名中添加 hash 值。\n\n\n示例#\n\n默认情况下，构建后的产物名称会包含 hash 值：\n\n\n\n你可以将 output.filenameHash 设置为 false 来禁用这个行为：\n\n\n\n重新构建，产物的名称变为：\n\n\n\n详细用法可参考 Rsbuild - output.filenameHash。","routePath":"/configure/app/output/filename-hash","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":72}],"domain":"","frontmatter":{"sidebar_label":"filenameHash"},"version":""},{"id":435,"title":"output.filename","content":"#\n\n * 类型：\n\n\n\n * 默认值：\n\n\n\n设置构建产物的名称。\n\n在生产环境构建后，会自动在文件名中间添加 hash 值，如果不需要添加，可以通过 output.disableFilenameHash 配置来禁用该行为。\n\n下面是各个文件类型的说明：\n\n * js：表示 JavaScript 文件的名称。\n * css：表示 CSS 样式文件的名称。\n * svg：表示 SVG 图片的名称。\n * font：表示字体文件的名称。\n * image：表示非 SVG 图片的名称。\n * media：表示视频等媒体资源的名称。\n\n\n示例#\n\n修改 JavaScript 文件的名称为 [name]_script.js：\n\n\n\n文件名中的 hash 值\n\n通常来说，我们只会在生产环境下设置文件名的 hash 值（即 process.env.NODE_ENV === 'production' 时）。\n\n如果你在开发环境下设置了文件名的 hash，那么可能会导致热更新不生效（尤其是 CSS 文件）。这是因为每次文件内容变化时，都会引起 hash 变化，导致\nmini-css-extract-plugin 等工具无法读取到最新的文件内容。\n\n\n异步模块的文件名#\n\n当你在代码中通过 dynamic import 的方式引入模块时，该模块会被单独打包成一个文件，它默认的命名规则如下：\n\n * 在开发环境下会基于模块路径生成名称，比如 dist/static/js/async/src_add_ts.js。\n * 在生产环境下会是一个随机的数字 id，比如\n   dist/static/js/async/798.27e3083e.js，这是为了避免在生产环境中泄露源代码的路径，同时字符数也更少。\n\n\n\n如果你希望为异步模块指定一个固定的名称，可以通过打包工具提供的 magic comments 来实现，通过 webpackChunkName 指定模块名称：\n\n\n\n通过以上写法指定模块名称后，生成的文件会是 dist/static/js/async/my-chunk-name.js。","routePath":"/configure/app/output/filename","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":268},{"text":"异步模块的文件名","id":"异步模块的文件名","depth":3,"charIndex":524}],"domain":"","frontmatter":{"sidebar_label":"filename"},"version":""},{"id":436,"title":"output.legalComments","content":"#\n\n * 类型： 'linked' | 'inline' | 'none'\n * 默认值： 'linked'\n\n配置 legal comment 的处理方式。\n\nlegal comment 是 JS 或 CSS 文件中的一些特殊注释，这些注释包含 @license 或 @preserve，或是以 //!\n开头。默认情况下，这些注释保留在输出文件中，因为这遵循了代码原作者的意图。\n\n你可以通过 legalComments 来配置相关行为：\n\n * linked：将所有 legal comments 移至 .LEGAL.txt 文件并通过注释链接到它们。\n * inline：保留所有 legal comments。\n * none：移除所有 legal comments。\n\n\n示例#\n\n移除所有 legal comments。\n\n","routePath":"/configure/app/output/legal-comments","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":341}],"domain":"","frontmatter":{"sidebar_label":"legalComments"},"version":""},{"id":437,"title":"output.overrideBrowserslist","content":"#\n\n * 类型： string[] | Record\n * 默认值： undefined\n\n指定项目兼容的目标浏览器范围。该值会被 @babel/preset-env 和 autoprefixer 用来确定需要转换的 JavaScript\n语法特性和需要添加的 CSS 浏览器前缀。\n\n优先级#\n\noverrideBrowserslist 配置的优先级高于项目中的 .browserslistrc 配置文件和 package.json 中的\nbrowserslist 字段。\n\n大多数场景下，推荐优先使用 .browserslistrc 文件，而不是使用 overrideBrowserslist 配置。因为\n.browserslistrc 文件是官方定义的配置文件，通用性更强，可以被社区中的其他库识别。\n\n默认值#\n\n如果项目中没有定义任何 browserslist 相关的配置，也没有定义 overrideBrowserslist，那么 Builder 会设置默认值为：\n\n\n\n\n示例#\n\n下面是兼容移动端 H5 场景的示例：\n\n\n\n可以查看 browserslist 文档 来了解如何自定义浏览器范围。\n\n根据产物类型设置#\n\n当你同时构建多种类型的产物时，你可以为不同的产物类型设置不同的目标浏览器范围。此时，你需要把 overrideBrowserslist 设置为一个对象，对象的\nkey 为对应的产物类型。\n\n比如为 web 和 node 设置不同的范围：\n\n","routePath":"/configure/app/output/override-browserslist","lang":"zh","toc":[{"text":"优先级","id":"优先级","depth":4,"charIndex":143},{"text":"默认值","id":"默认值","depth":4,"charIndex":355},{"text":"示例","id":"示例","depth":3,"charIndex":443},{"text":"根据产物类型设置","id":"根据产物类型设置","depth":4,"charIndex":507}],"domain":"","frontmatter":{"sidebar_label":"overrideBrowserslist"},"version":""},{"id":438,"title":"output.polyfill","content":"#\n\n * 类型： 'entry' | 'usage' | 'ua' | 'off'\n * 默认值： 'entry'\n\n通过 output.polyfill 你可以配置 Polyfill 的注入方式。\n\n\n配置项#\n\nentry#\n\n当 output.polyfill 配置为 'entry' 时，会在每个入口文件中注入 Polyfill。\n\n等价于 @babel/preset-env 的 useBuiltIns: 'entry' 配置。\n\nusage#\n\n当 output.polyfill 配置为 'usage' 时，会在每个文件中根据代码中使用的 API 注入 Polyfill。\n\n等价于 @babel/preset-env 的 useBuiltIns: 'usage' 配置。\n\nua#\n\n根据当前请求的 UA 信息，动态下发 Polyfill 代码。\n\n动态下发能力需要与上层框架结合使用，详情可参考 Modern.js - 运行时按需 Polyfill。\n\noff#\n\n不注入 Polyfill。使用此选项时，需要自行保证代码的兼容性。","routePath":"/configure/app/output/polyfill","lang":"zh","toc":[{"text":"配置项","id":"配置项","depth":3,"charIndex":102},{"text":"entry","id":"entry","depth":4,"charIndex":108},{"text":"usage","id":"usage","depth":4,"charIndex":221},{"text":"ua","id":"ua","depth":4,"charIndex":345},{"text":"off","id":"off","depth":4,"charIndex":436}],"domain":"","frontmatter":{"sidebar_label":"polyfill"},"version":""},{"id":439,"title":"output.splitRouteChunks","content":"#\n\n * 类型： boolean\n * 默认值： true\n\n当使用约定式路由时，框架会根据路由对 js 和 css 进行拆分，以实现按需加载。如果你的项目不希望根据路由对 js 和 css 进行拆分，可以将该选项设置为\nfalse。\n\n示例\n\n","routePath":"/configure/app/output/splitRouteChunks","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_label":"splitRouteChunks"},"version":""},{"id":440,"title":"output.ssg","content":"#\n\n * 类型： boolean | object | function\n * 默认值： undefined\n\n开启自控式路由或约定式路由 SSG 功能的配置。\n\n开启 SSG 功能\n\n此配置需要在开启 SSG 功能情况下才会生效。请阅读 静态站点生成 文档了解如何开启 SSG 功能。\n\n客户端路由\n\n相关内容可以查看路由方案。\n\n\n示例#\n\n\n单入口#\n\n当该配置设置为 true 时，将会默认开启所有入口的 SSG 功能。\n\n对自控式路由而言，将会渲染入口的根路由。对约定式路由而言，将会渲染入口中每一条路由。\n\n例如 src/ 目录下有以下满足约定式路由的文件结构：\n\n\n\n在 modern.config.js 中做以下设置：\n\n\n\n执行 pnpm build 构建应用后。dist/ 目录将会生成三张 HTML 分别对应三条路由（不开启 SSG 时只有一张 HTML），并且所有 HTML\n都已经渲染。\n\n而例如下面的自控式路由：\n\n\n\n同样使用上面的配置，在执行 pnpm run build 后，只有入口路由 / 会生成渲染后的 HTML。\n\n\n多入口#\n\noutput.ssg 也可以按照入口配置，配置生效的规则同样由入口路由方式决定。\n\n例如以下目录结构：\n\n\n\n默认情况下，所有约定式路由的入口，在设置 output.ssg 配置为 true 后都会在构建阶段渲染。可以配置 false\n来取消指定入口的的默认行为，例如取消上述 entryA 入口在构建时的渲染：\n\n\n\n\n配置路由#\n\n上述内容中提到，自控式路由默认只会开启入口路由的 SSG 配置。\n\n可以在 output.ssg 中设置具体的路由，告知 Modern.js 开启这些客户端路由的 SSG 功能。例如上述 src/App.tsx 的文件内容为：\n\n\n\n在 modern.config.js 中这样设置后，/about 路由也会开启 SSG 功能：\n\n\n\nModern.js 将会自动根据入口拼接完整的 URL 并交给 SSG 插件完成渲染。\n\n也可以为具体入口或路由配置请求头，例如：\n\n\n\nINFO\n\n路由中设置的 headers 会覆盖入口中设置的 headers。\n\n\n阻止默认行为#\n\n默认情况下，约定式路由的路由会全部开启 SSG。Modern.js 提供了另一个字段，用来阻止默认的 SSG 行为。\n\n例如以下目录结构，/、/user、/user/profle 三条路由都开启 SSG：\n\n\n\n可以这样设置，禁用某一条客户端路由的默认行为：\n\n\n\n\n添加动态路由参数#\n\n部分路由可能是动态的，例如自控式路由中的 /user/:id 或是约定式路由中 user/[id]/page.tsx 文件生成的路由。\n\n可以在 output.ssg 中配置具体的参数，渲染指定参数的路由，例如：\n\n\n\n动态路由和 SSG 的组合，在根据 CMS 系统数据变更，实时生成静态页面时非常有用。","routePath":"/configure/app/output/ssg","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":168},{"text":"单入口","id":"单入口","depth":3,"charIndex":174},{"text":"多入口","id":"多入口","depth":3,"charIndex":480},{"text":"配置路由","id":"配置路由","depth":3,"charIndex":647},{"text":"阻止默认行为","id":"阻止默认行为","depth":3,"charIndex":933},{"text":"添加动态路由参数","id":"添加动态路由参数","depth":3,"charIndex":1076}],"domain":"","frontmatter":{"sidebar_label":"ssg"},"version":""},{"id":441,"title":"output.svgDefaultExport","content":"#\n\n * 类型： 'url' | 'component'\n * 默认值： 'url'\n\noutput.svgDefaultExport 可以用来配置 SVG 文件的默认导出。\n\n当 output.svgDefaultExport 配置为 url 时，SVG 文件的默认导出是文件的 URL。例如：\n\n\n\n当 output.svgDefaultExport 配置为 component 时，SVG 文件的默认导出是文件的 React 组件。例如：\n\n\n\n此时，你也可以通过指定 ?url 的 query 来导入 url，比如：\n\n","routePath":"/configure/app/output/svg-default-export","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_label":"svgDefaultExport"},"version":""},{"id":442,"title":"output.tempDir","content":"#\n\n * 类型： string\n * 默认值： ''\n\n项目开发或构建时，Modern.js 会生成真实的 Webpack 入口和 HTML 模板，并放在临时目录下。\n\n如果希望由多个配置同时启动某项目，可以通过该配置，将文件生成到不同的临时目录下，避免相互干扰。配置可以是相对路径或绝对路径，但应避免项目外的路径。\n\n示例\n\n","routePath":"/configure/app/output/temp-dir","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_label":"tempDir"},"version":""},{"id":443,"title":"performance.buildCache","content":"#\n\n * 类型：\n\n\n\n * 默认值：\n\n\n\n * 打包工具： 仅支持 webpack\n\n控制 Builder 在构建过程中的缓存行为。\n\nBuilder 默认会开启构建缓存来提升二次构建的速度，并默认把生成的缓存文件写到 ./node_modules/.cache/webpack 目录下。\n\n你可以通过 buildCache 配置缓存路径，比如：\n\n\n\n如果不希望缓存，你也可以将 buildCache 置为 false 将其禁用掉：\n\n\n\n\ncacheDigest#\n\ncacheDigest 用来添加一些会对构建结果产生影响的环境变量。Builder 将根据 cacheDigest\n内容和当前构建模式来设置缓存名称，来确保不同的 cacheDigest 可以命中不同的缓存。\n\n示例#\n\n当前项目需要根据不同的 APP_ID 来设置不同的 extensions。默认情况下，由于当前项目的代码 & 配置 & 依赖未发生变化，会命中之前的缓存。\n通过将 APP_ID 添加到 cacheDigest 中，在 APP_ID 变化时会去查找不同的缓存结果，从而避免命中不符合预期的缓存结果。\n\n","routePath":"/configure/app/performance/build-cache","lang":"zh","toc":[{"text":"cacheDigest","id":"cachedigest","depth":3,"charIndex":224},{"text":"示例","id":"示例","depth":4,"charIndex":344}],"domain":"","frontmatter":{"sidebar_label":"buildCache"},"version":""},{"id":444,"title":"performance.bundleAnalyze","content":"#\n\n * 类型： Object | undefined\n\n用于开启 webpack-bundle-analyzer 插件来分析产物体积。\n\n默认情况下，Builder 不会开启 webpack-bundle-analyzer。当开启该功能后，内部的默认配置如下:\n\n\n\n\n启用 Bundle Analyze#\n\n你有两种方式开启 webpack-bundle-analyzer 来分析构建产物的体积:\n\n * 添加环境变量 BUNDLE_ANALYZE=true，比如：\n\n\n\n * 配置 performance.bundleAnalyze 来固定开启：\n\n\n\n在启用后，Builder 会生成一个分析构建产物体积的 HTML 文件，并在 Terminal 中打印以下日志：\n\n\n\n手动在浏览器中打开该文件，可以看到打包产物的瓦片图；区块的面积越大，说明该模块的体积越大。\n\n\n\n\n覆盖默认配置#\n\n你可以通过 performance.bundleAnalyze 来覆盖默认配置，比如开启 server 模式：\n\n\n\n\nSize 类型#\n\n在 webpack-bundle-analyzer 的面板中，你可以在左上角控制 Size 类型（默认为 Parsed）：\n\n * Stat：从打包工具的 stats 对象中获取的体积，它反映了代码在压缩之前的体积。\n * Parsed：磁盘上的文件体积，它反映了代码在压缩之后的体积。\n * Gzipped：浏览器里请求的文件体积，它反映了代码在压缩和 gzip 后的体积。\n\n\n生成 stats.json#\n\ngenerateStatsFile 设置为 true 时，将会生成 stats JSON 文件。\n\n\n\n\n注意事项#\n\n 1. 开启 Server 模式会导致 build 进程不能正常退出。\n 2. 开启 bundleAnalyzer 会降低构建性能。因此，在日常开发过程中不应该开启此配置项，建议通过 BUNDLE_ANALYZE\n    环境变量来按需开启。\n 3. 由于 dev 阶段不会进行代码压缩等优化，无法反映真实的产物体积，因此建议在 build 阶段分析产物体积。","routePath":"/configure/app/performance/bundle-analyze","lang":"zh","toc":[{"text":"启用 Bundle Analyze","id":"启用-bundle-analyze","depth":3,"charIndex":136},{"text":"覆盖默认配置","id":"覆盖默认配置","depth":3,"charIndex":391},{"text":"Size 类型","id":"size-类型","depth":3,"charIndex":460},{"text":"生成 stats.json","id":"生成-statsjson","depth":3,"charIndex":661},{"text":"注意事项","id":"注意事项","depth":3,"charIndex":730}],"domain":"","frontmatter":{"sidebar_label":"bundleAnalyze"},"version":""},{"id":445,"title":"performance.chunkSplit","content":"#\n\n * 类型： Object\n * 默认值： { strategy: 'split-by-experience' }\n\nperformance.chunkSplit 用于配置 Builder 的拆包策略。配置项的类型 ChunkSplit 如下:\n\n\n\n\nchunkSplit.strategy#\n\nBuilder 支持设置以下几种拆包策略：\n\n * split-by-experience: 根据经验制定的拆分策略，自动将一些常用的 npm 包拆分为体积适中的 chunk。\n * split-by-module: 按 NPM 包的粒度拆分，每个 NPM 包对应一个 chunk。\n * split-by-size：根据模块大小自动进行拆分。\n * all-in-one: 将所有代码全部打包到一个 chunk 中。\n * single-vendor: 将所有 NPM 包的代码打包到一个单独的 chunk 中。\n * custom: 自定义拆包配置。\n\n\n默认拆包策略#\n\nBuilder 默认采用 split-by-experience 策略，这是我们根据经验制定的策略。具体来说，当你的项目中引用了以下 npm\n包时，它们会自动被拆分为单独的 chunk：\n\n * lib-polyfill.js：包含 core-js，@babel/runtime，@swc/helpers，tslib。\n * lib-react.js：包含 react，react-dom。\n * lib-router.js：包含 react-router，react-router-dom，history，@remix-run/router。\n * lib-lodash.js：包含 lodash，lodash-es。\n * lib-antd.js：包含 antd。\n * lib-arco.js：包含 @arco-design/web-react。\n * lib-semi.js：包含 @douyinfe/semi-ui。\n\nTIP\n\n如果项目中没有安装或引用以上 npm 包，则不会生成相应的 chunk。\n\n如果你想使用其他拆包策略，可以通过 performance.chunkSplit.strategy 配置项来指定。\n\n\nchunkSplit.minSize#\n\n * 类型： number\n * 默认值： 10000\n\n当 performance.chunkSplit.strategy 为 split-by-size 时，可以通过\nperformance.chunkSplit.minSize 配置项来指定 chunk 的最小大小，单位为字节。默认值为 10000。比如:\n\n\n\n\nchunkSplit.maxSize#\n\n * 类型： number\n * 默认值： Infinity\n\n当 performance.chunkSplit.strategy 为 split-by-size 时，可以通过\nperformance.chunkSplit.maxSize 配置项来指定 chunk 的最大大小，单位为字节。默认值为 Infinity。比如:\n\n\n\n\nchunkSplit.forceSplitting#\n\n * 类型： RegExp[] | Record\n * 默认值： []\n\n通过 performance.chunkSplit.forceSplitting 配置项可以将指定的模块强制拆分为一个独立的 chunk。\n\n比如将 node_modules 下的 axios 库拆分到 axios.js 中：\n\n\n\n相比直接配置 webpack 的 splitChunks，这是一个更加简便的方式。\n\nTIP\n\n注意，通过 forceSplitting 配置拆分的 chunk 会通过","routePath":"/configure/app/performance/chunk-split","lang":"zh","toc":[{"text":"chunkSplit.strategy","id":"chunksplitstrategy","depth":3,"charIndex":129},{"text":"默认拆包策略","id":"默认拆包策略","depth":3,"charIndex":431},{"text":"chunkSplit.minSize","id":"chunksplitminsize","depth":3,"charIndex":958},{"text":"chunkSplit.maxSize","id":"chunksplitmaxsize","depth":3,"charIndex":1140},{"text":"chunkSplit.forceSplitting","id":"chunksplitforcesplitting","depth":3,"charIndex":1328},{"text":"chunkSplit.splitChunks","id":"chunksplitsplitchunks","depth":3,"charIndex":-1},{"text":"chunkSplit.override","id":"chunksplitoverride","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"sidebar_label":"chunkSplit"},"version":""},{"id":446,"title":"performance.dnsPrefetch","content":"#\n\n * 类型： undefined | string[]\n\n * 默认值： undefined\n\n为哪些资源配置 dns-prefetch 属性。\n\n配置该属性可以在请求资源之前解析域名，降低请求延迟，提升加载性能。\n\n更多信息可参考：Using dns-prefetch\n\n\n示例#\n\n","routePath":"/configure/app/performance/dns-prefetch","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":140}],"domain":"","frontmatter":{"sidebar_label":"dnsPrefetch"},"version":""},{"id":447,"title":"performance.preconnect","content":"#\n\n * 类型： undefined | Array\n\n\n\n * 默认值： undefined\n\n为哪些资源配置 preconnect 属性。\n\n配置该属性会预先建立与服务器的连接，如果站点是 HTTPS 的，则此过程包括 DNS 解析，建立 TCP 连接以及执行 TLS 握手。将 Preconnect\n和 DnsPrefetch 结合使用可进一步减少跨域请求的延迟。\n\n\n示例#\n\n","routePath":"/configure/app/performance/preconnect","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":188}],"domain":"","frontmatter":{"sidebar_label":"preconnect"},"version":""},{"id":448,"title":"performance.prefetch","content":"#\n\n * 类型： undefined | true | PrefetchOption\n\n\n\n * 默认值： undefined\n\n为哪些资源配置 prefetch 属性。\n\n该属性用于配置在将来某些导航下可能需要的资源，此时，浏览器通常在空闲状态时获取此资源。\n\n\nBoolean 类型#\n\n当设置 performance.prefetch 为 true，将根据如下配置对资源进行预获取:\n\n\n\n\nObject 类型#\n\n当 performance.prefetch 的值为 object 类型时，Builder 会根据当前配置对指定资源开启 prefetch 能力。\n\nprefetch.type#\n\ntype 字段控制了哪些资源会被预获取，同时支持通过 include 和 exclude 对指定资源进行二次过滤。\n\n目前支持的资源类型如下：\n\n * async-chunks: 预获取所有异步资源(当前页面)，包含异步 js 及其关联的 css、image、font 等资源。\n * initial: 预获取所有非异步资源(当前页面)。需要注意的是，如果当前脚本已经被添加到 html 模版中，则不会进行额外的预获取。\n * all-chunks: 预获取所有资源(当前页面)，包含所有异步和非异步资源。\n * all-assets: 预获取所有资源，MPA 场景下会包含其他页面的资源。\n\n示例#\n\n当你希望对当前页面中所有 png 格式的图片资源进行预获取时，可以配置如下：\n\n","routePath":"/configure/app/performance/prefetch","lang":"zh","toc":[{"text":"Boolean 类型","id":"boolean-类型","depth":3,"charIndex":133},{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":199},{"text":"prefetch.type","id":"prefetchtype","depth":4,"charIndex":286},{"text":"示例","id":"示例","depth":4,"charIndex":599}],"domain":"","frontmatter":{"sidebar_label":"prefetch"},"version":""},{"id":449,"title":"performance.preload","content":"#\n\n * 类型： undefined | true | PreloadOption\n\n\n\n * 默认值： undefined\n\n为哪些资源配置 preload 属性。\n\n该属性通常用于配置当前导航下可能需要的资源，此时，浏览器通常以中等优先级（不是布局阻塞）获取此资源。\n\n\nBoolean 类型#\n\n当设置 performance.preload 为 true，将根据如下配置对资源进行预加载:\n\n\n\n\nObject 类型#\n\n当 performance.preload 的值为 object 类型时，Builder 会根据当前配置对指定资源开启 preload 能力。\n\npreload.type#\n\ntype 字段控制了哪些资源会被预加载，同时支持通过 include 和 exclude 对指定资源进行二次过滤。\n\n目前支持的资源类型如下：\n\n * async-chunks: 预加载所有异步资源(当前页面)，包含异步 js 及其关联的 css、image、font 等资源。\n * initial: 预加载所有非异步资源(当前页面)。需要注意的是，如果当前脚本已经被添加到 html 模版中，则不会进行额外的预加载。\n * all-chunks: 预加载所有资源(当前页面)，包含所有异步和非异步资源。\n * all-assets: 预加载所有资源，MPA 场景下会包含其他页面的资源。\n\n示例#\n\n当你希望对当前页面中所有 png 格式的图片资源进行预加载时，可以配置如下：\n\n","routePath":"/configure/app/performance/preload","lang":"zh","toc":[{"text":"Boolean 类型","id":"boolean-类型","depth":3,"charIndex":138},{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":203},{"text":"preload.type","id":"preloadtype","depth":4,"charIndex":288},{"text":"示例","id":"示例","depth":4,"charIndex":600}],"domain":"","frontmatter":{"sidebar_label":"preload"},"version":""},{"id":450,"title":"performance.printFileSize","content":"#\n\n * 类型： boolean\n * 默认值： true\n\n是否在生产环境构建后输出所有静态资源文件的体积。\n\n\n\n\n示例#\n\n禁用相关日志：\n\n","routePath":"/configure/app/performance/print-file-size","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":60}],"domain":"","frontmatter":{"sidebar_label":"printFileSize"},"version":""},{"id":451,"title":"performance.profile","content":"#\n\n * 类型： boolean\n * 默认值： false\n\n是否捕获每个模块的耗时信息，对应 webpack / Rspack 的 profile 配置。\n\n\n示例#\n\n\n\n开启后，Webpack / Rspack 生成一些有关模块的统计数据的 JSON 文件会将模块构建的耗时信息也包含进去。","routePath":"/configure/app/performance/profile","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":82}],"domain":"","frontmatter":{"sidebar_label":"profile"},"version":""},{"id":452,"title":"performance.removeConsole","content":"#\n\n * 类型： boolean | ConsoleType[]\n * 默认值： false\n\n在生产环境构建时，是否自动移除代码中的 console.xx。\n\n移除所有 console#\n\n当 removeConsole 被设置为 true 时，会移除所有类型的 console.xx：\n\n\n\n移除特定的 console#\n\n你也可以指定仅移除特定类型的 console.xx，比如移除 console.log 和 console.warn：\n\n\n\n目前支持配置以下类型的 console：\n\n","routePath":"/configure/app/performance/remove-console","lang":"zh","toc":[{"text":"移除所有 console","id":"移除所有-console","depth":4,"charIndex":81},{"text":"移除特定的 console","id":"移除特定的-console","depth":4,"charIndex":148}],"domain":"","frontmatter":{"sidebar_label":"removeConsole"},"version":""},{"id":453,"title":"performance.removeMomentLocale","content":"#\n\n * 类型： boolean\n * 默认值： false\n\n是否移除 moment.js 的语言包文件。\n\nmoment.js 默认包含了大量的语言包文件，会导致打包后的包体积增大。\n\n当项目中使用了 moment.js 时，推荐开启此选项，自动排除所有的语言包文件：\n\n\n\n开启后，可以通过以下方式来加载语言包文件：\n\n","routePath":"/configure/app/performance/remove-moment-locale","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_label":"removeMomentLocale"},"version":""},{"id":454,"title":"performance.transformLodash","content":"#\n\n * 类型： boolean\n * 默认值： true\n * 打包工具： 仅支持 webpack\n\n是否模块化 lodash 的导入，删除未使用的 lodash 模块，从而减少 lodash 代码体积。\n\n这项优化基于 babel-plugin-lodash 和 swc-plugin-lodash 实现。\n\n\n示例#\n\n该选项默认开启，Builder 会自动将 lodash 的代码引用指向子路径。\n\n比如：\n\n\n\n转换后的代码为：\n\n\n\n\n关闭转换#\n\n在个别情况下，lodash 的 import 转换可能会生成不符合预期的代码，此时你可以手动关闭这项优化：\n\n","routePath":"/configure/app/performance/transform-lodash","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":158},{"text":"关闭转换","id":"关闭转换","depth":3,"charIndex":224}],"domain":"","frontmatter":{"sidebar_label":"transformLodash"},"version":""},{"id":455,"title":"plugins 插件","content":"#\n\n * 类型： CliPlugin[]\n * 默认值： []\n\n用于配置自定义的 Modern.js 框架插件。\n\n自定义插件的编写方式请参考 如何编写插件。\n\n\n注意事项#\n\n该选项用于配置框架插件，如果你需要配置其他类型的插件，请选择对应的配置方式：\n\n * 配置 Modern.js Builder 插件，请使用 builderPlugins 配置项。\n * 配置 Rspack 或 webpack 插件，请使用 tools.bundlerChain 配置项。\n * 配置 Babel 插件，请使用 tools.babel 配置项。\n\n\n插件类型#\n\nModern.js 中内置了三种不同的框架插件：\n\n * CLI 插件，适用于本地开发、编译构建阶段，可以在命令行和编译阶段扩展各种能力。\n * Server 插件，适用于服务端。\n * Runtime 插件，适用于前端运行时。\n\n目前 Modern.js 开放了自定义 CLI 插件的能力，Server 插件和 Runtime 插件会在后续开放。\n\n\n插件执行顺序#\n\n默认情况下，自定义插件会按照 plugins 数组的顺序依次执行，Modern.js 内置插件的执行时机早于自定义插件。\n\n当插件内部使用了控制顺序的相关字段，比如 pre、post 时，会基于声明的字段对执行顺序进行调整，详见 插件之间的关系。\n\n\n示例#\n\n下面是 CLI 插件的使用示例。\n\n\n使用 npm 上的插件#\n\n使用 npm 上的插件，需要通过包管理器安装插件，并通过 import 引入。\n\n\n\n\n使用本地插件#\n\n使用本地代码仓库中的插件，直接通过相对路径 import 引入即可。\n\n\n\n\n插件配置项#\n\n如果插件提供了一些自定义的配置项，可以通过插件函数的参数传入配置。\n\n","routePath":"/configure/app/plugins","lang":"zh","toc":[{"text":"注意事项","id":"注意事项","depth":2,"charIndex":83},{"text":"插件类型","id":"插件类型","depth":2,"charIndex":273},{"text":"插件执行顺序","id":"插件执行顺序","depth":2,"charIndex":457},{"text":"示例","id":"示例","depth":2,"charIndex":592},{"text":"使用 npm 上的插件","id":"使用-npm-上的插件","depth":3,"charIndex":616},{"text":"使用本地插件","id":"使用本地插件","depth":3,"charIndex":674},{"text":"插件配置项","id":"插件配置项","depth":3,"charIndex":722}],"domain":"","frontmatter":{"sidebar_position":9},"version":""},{"id":456,"title":"总览","content":"#\n\n此节将介绍 Runtime 插件的配置。\n\n\n配置方式#\n\n\nruntime#\n\n * 类型： Object\n\nruntime 配置方式如下：\n\n基本用法#\n\n在 modern.config.ts 中配置\n\n\n\n运行时配置#\n\n通过 defineConfig API 配置：\n\nINFO\n\n当 runtime 配置中存在函数时，只能使用该方式进行配置。\n\nINFO\n\n使用运行时配置，可以解决 Runtime 插件配置需要在运行时才能获取到具体内容问题。\n\nRuntime 插件运行时配置和直接在 modern.config.ts 中的配置默认会进行合并，且运行时配置优先级更高。\n\nWARNING\n\ndefineConfig 中只能定义 Runtime 插件的具体配置内容，确认是否开启插件还需要通过 modern.config.ts 中的配置决定。\n\n\nruntimeByEntries#\n\n * 类型： Object\n * **默认值：**无\n\n说明#\n\n按入口添加 runtime 配置，选项属性同 runtime 一致，指定值会和 runtime 属性内容做替换合并操作。\n\n","routePath":"/configure/app/runtime/intro","lang":"zh","toc":[{"text":"配置方式","id":"配置方式","depth":2,"charIndex":25},{"text":"runtime","id":"runtime","depth":3,"charIndex":33},{"text":"基本用法","id":"基本用法","depth":4,"charIndex":75},{"text":"运行时配置","id":"运行时配置","depth":4,"charIndex":108},{"text":"runtimeByEntries","id":"runtimebyentries","depth":3,"charIndex":381},{"text":"说明","id":"说明","depth":4,"charIndex":428}],"domain":"","frontmatter":{"sidebar_label":"总览","sidebar_position":1},"version":""},{"id":457,"title":"runtime.masterApp","content":"#\n\n * 类型： Object\n\nINFO\n\n需要先通过 pnpm run new 启用「微前端」 功能。\n\n\n示例#\n\n\n\n\nmanifest#\n\n\n\n\ngetAppList?#\n\n通过 getAppList 配置，可以自定义如何获取远程列表数据\n\n\n\n\napps#\n\n当 apps 为对象类型的时候，表示子应用模块的信息 Array\n\n\n\n * name: 子应用的名称。\n * entry: 子应用的入口。\n * activeWhen?: 子应用激活路径。\n\n\n其他配置项#\n\n在 masterApp 配置下，开发者可以透传 Garfish 的配置项。\n\n所有支持的配置项点此查看。","routePath":"/configure/app/runtime/master-app","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":56},{"text":"manifest","id":"manifest","depth":2,"charIndex":64},{"text":"getAppList?","id":"getapplist","depth":3,"charIndex":78},{"text":"apps","id":"apps","depth":3,"charIndex":129},{"text":"其他配置项","id":"其他配置项","depth":3,"charIndex":234}],"domain":"","frontmatter":{"sidebar_label":"masterApp"},"version":""},{"id":458,"title":"runtime.router","content":"#\n\n * 类型： boolean | Object\n * 默认值： false\n\n开启 router 之后，支持使用 Modern.js 默认提供的约定式路由进行路由管理。Modern.js 的路由模块基于 React Router 6\n实现。\n\n具体配置如下：\n\n\nbasename#\n\n * 类型： string\n * 默认值： /\n\n设置客户端路由的 basename，通常用于应用需要部署在域名非根路径下的场景。\n\n\nsupportHtml5History#\n\n * 类型： boolean\n * 默认值： true\n\n值为 true，使用 BrowserRouter；否则使用 HashRouter。推荐使用 BrowserRouter。\n\nWARNING\n\n当开启 SSR 时，不支持设置 supportHtml5History。","routePath":"/configure/app/runtime/router","lang":"zh","toc":[{"text":"basename","id":"basename","depth":2,"charIndex":134},{"text":"supportHtml5History","id":"supporthtml5history","depth":2,"charIndex":213}],"domain":"","frontmatter":{"sidebar_label":"router"},"version":""},{"id":459,"title":"runtime.state","content":"#\n\n * 类型： boolean | object\n * 默认值： false\n\n开启 state 后就可以使用 Model 来做状态管理。\n\n具体配置项如下：\n\n\nmodels#\n\n * 类型： Array\n * 默认值： []\n\n注册提前挂载的 model 对象，这些 model 会在 Reduck store 创建完成后立即执行挂载。一般使用无需提前挂载。\n\n\ninitialState#\n\n * 类型： Object\n * 默认值： {}\n\n用于设置全局 store 的初始状态。一般用于 SSR 在 hydration 阶段初始化数据。\n\n\nimmer#\n\n * 类型： boolean\n * 默认值： true\n\n是否启用以 mutable 更新 state 的方式，默认启用，若想禁用则设置为 false。\n\n\neffects#\n\n * 类型： boolean\n * 默认值： true\n\n是否启用副作用管理特性，默认启用，若想禁用则设置为 false。\n\n\nautoActions#\n\n * 类型： boolean\n * 默认值： true\n\n是否启用自动生成 actions 特性，默认启用，若想禁用则设置为 false。\n\n\ndevtools#\n\n * 类型： boolean | EnhancerOptions\n * 默认值： true\n\n是否启用 devtools，默认启用，同时支持 redux-devtools-extension 的所有参数，若想禁用则设置为 false。","routePath":"/configure/app/runtime/state","lang":"zh","toc":[{"text":"models","id":"models","depth":2,"charIndex":83},{"text":"initialState","id":"initialstate","depth":2,"charIndex":185},{"text":"immer","id":"immer","depth":2,"charIndex":277},{"text":"effects","id":"effects","depth":2,"charIndex":364},{"text":"autoActions","id":"autoactions","depth":2,"charIndex":438},{"text":"devtools","id":"devtools","depth":2,"charIndex":524}],"domain":"","frontmatter":{"sidebar_label":"state"},"version":""},{"id":460,"title":"security.checkSyntax","content":"#\n\n * 类型：\n\n\n\n * 默认值： false\n\n用于分析构建产物中是否存在当前浏览器范围下不兼容的高级语法。如果存在，会将详细信息打印在终端。\n\n\n启用检测#\n\n你可以将 checkSyntax 设置为 true 来启用语法检测。\n\n\n\n当你开启 checkSyntax 后，Builder\n会在生产环境构建时进行检测，当在构建产物中检测到不兼容的高级语法后，会将错误日志打印在终端，并退出当前构建流程。\n\n\n错误日志#\n\n错误日志的格式如下所示，包含代码来源文件、产物位置、错误原因、源代码等信息：\n\n\n\nTIP\n\n目前语法检测是基于 AST parser\n来实现的，每次检测时，只能找出文件中的第一个不兼容语法。如果一个文件中存在多个不兼容语法，你需要修复已发现的语法，并重新执行检测。output.disableM\ninimize 设置为 true 后再重新构建。\n\n如果日志中没有显示对应的源码位置，可以尝试将\n\n\n解决方法#\n\n当检测到语法错误后，你可以通过以下方式来处理：\n\n * 如果你希望降级该语法，以保证代码具备良好的兼容性，可以通过 source.include 配置来编译相应的模块。\n * 如果你不希望降级该语法，可以调整项目的 browserslist 范围，调整至与该语法相匹配的范围。\n * 如果你不希望对某些产物进行语法检查，可用 checkSyntax.exclude 配置排除要检查的文件。\n\n\n配置项#\n\ncheckSyntax.targets#\n\n * 类型： string[]\n * 默认值： 当前项目的 browserslist 配置\n\ntargets 表示项目的目标浏览器范围，它的值为标准的 browserslist 数组，如果你不了解 browserslist 的用法，请参考\n「设置浏览器范围」。\n\nBuilder 会读取 targets 的值，并自动推导出构建产物中可以使用的最低 ECMAScript 语法版本，比如 ES5 或 ES6。\n\n * 示例：\n\n比如，项目中需要兼容的浏览器为 Chrome 53 以上版本，可以添加以下设置：\n\n\n\nBuilder 会推导出 chrome >= 53 可以使用的 ECMAScript 语法版本为 ES6，当构建产物中包含 es2016\n或更高的语法时，就会触发语法错误提示。\n\nTIP\n\n请留意，Builder 不支持基于 targets 来自动分析 ES6 以上的语法版本，如果你的构建产物兼容的语法版本超过 ES6，请通过\ncheckSyntax.ecmaVersion 进行设置。\n\ncheckSyntax.ecmaVersion#\n\n * 类型： 3 | 5 | 6 | 2015 | 2016 | 2017 | 2018 | 2019 | 2020 | 2021 | 2022 |\n   'latest'\n * 默认值： 基于 targets 自动分析\n\necmaVersion 表示构建产物中可以使用的最低 ECMAScript 语法版本，ecmaVersion 的优先级高于 targets。\n\n * 示例：\n\n比如，构建产物中可以使用的最低 ECMAScript 语法版本为 ES2020，可以添加以下设置：\n\n\n\n此时，构建产物中可以包含 ES2020 支持的所有语法，比如 optional chaining。\n\ncheckSyntax.exclude#\n\n * 类型： RegExp | RegExp[]\n * 默认值： undefined\n\nexclude 用于在检测时排除一部分文件，你可以传入一个或多个正则表达式来匹配源文件的路径，符合正则的文件将会被忽略，不会触发语法检测。\n\n * 示例：\n\n比如，忽略 node_modules/foo 目录下的文件：\n\n","routePath":"/configure/app/security/check-syntax","lang":"zh","toc":[{"text":"启用检测","id":"启用检测","depth":3,"charIndex":77},{"text":"错误日志","id":"错误日志","depth":3,"charIndex":208},{"text":"解决方法","id":"解决方法","depth":3,"charIndex":415},{"text":"配置项","id":"配置项","depth":3,"charIndex":619},{"text":"checkSyntax.targets","id":"checksyntaxtargets","depth":4,"charIndex":625},{"text":"checkSyntax.ecmaVersion","id":"checksyntaxecmaversion","depth":4,"charIndex":1100},{"text":"checkSyntax.exclude","id":"checksyntaxexclude","depth":4,"charIndex":1422}],"domain":"","frontmatter":{"sidebar_label":"checkSyntax"},"version":""},{"id":461,"title":"security.nonce","content":"#\n\n * 类型：\n\n\n\n * 默认值： undefined\n\n为 HTML 所引入的脚本资源添加随机属性值 nonce，使浏览器在解析到带有匹配 nonce 值的内联脚本时，能判断该脚本是否能执行。\n\nnonce 介绍#\n\nnonce 机制在 Content Security Policy（CSP，内容安全策略）中起到关键作用，用于提升网页安全性。其允许开发者在 CSP 中为内联","routePath":"/configure/app/security/nonce","lang":"zh","toc":[{"text":"nonce 介绍","id":"nonce-介绍","depth":4,"charIndex":101},{"text":"示例","id":"示例","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"sidebar_label":"nonce"},"version":""},{"id":462,"title":"security.sri","content":"#\n\n * 类型：\n\n\n\n * 默认值： undefined\n * 打包工具： 仅支持 webpack\n\n为 HTML 所引入的子资源添加完整性属性 —— integrity，使浏览器能够验证引入资源的完整性，以此防止下载的资源被篡改。\n\n启动该选项后会将 webpack 的 output.crossOriginLoading 配置项设置为 anonymous。\n\nSRI 介绍#\n\n子资源完整性 Subresource Integrity（SRI）是专门用来校验资源的一种方案，它读取资源标签中的 integrity\n属性，将其中的信息摘要值，和资源实际的信息摘要值进行对比，如果发现无法匹配，那么浏览器就会拒绝执行资源。\n\n对于 script 标签来说，结果为拒绝执行其中的代码；对于 CSS link 来说，结果为不加载其中的样式。\n\n关于 SRI 的更多内容，可以查看 Subresource Integrity - MDN。\n\n\n示例#\n\n默认情况下，不会开启 SRI，当开启之后它的默认配置如下：\n\n\n\n你可以按照你自己的需求自定义配置项:\n\n","routePath":"/configure/app/security/sri","lang":"zh","toc":[{"text":"SRI 介绍","id":"sri-介绍","depth":4,"charIndex":183},{"text":"示例","id":"示例","depth":3,"charIndex":420}],"domain":"","frontmatter":{"sidebar_label":"sri"},"version":""},{"id":463,"title":"server.baseUrl","content":"#\n\n * 类型： string | string[]\n * 默认值： undefined\n\n统一设置服务端路由前缀（常用于多个应用共享同一域名的情况，区分流量)。\n\n\n\ndev 之后可以看到路由访问会加上对应前缀:\n\n","routePath":"/configure/app/server/base-url","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_label":"baseUrl"},"version":""},{"id":464,"title":"server.enableFrameworkExt","content":"#\n\n * 类型： boolean\n * 默认值： false\n\n默认情况下，开启自定义 Web Server 功能后，Middleware 会使用 Modern.js 本身的语法。\n\n开启 server.enableFrameworkExt 可以使用其他框架扩展的语法。\n\n\n\n\n示例#\n\n默认的使用方式：\n\n\n\n开启后，Middleware 类型将从其他命名空间下导出，并且可以使用框架拓展的语法：\n\n\n\nNOTE\n\n上述代码为伪代码，具体使用方式需要参考对应的框架拓展。","routePath":"/configure/app/server/enable-framework-ext","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":140}],"domain":"","frontmatter":{"sidebar_label":"enableFrameworkExt"},"version":""},{"id":465,"title":"server.port","content":"#\n\n * 类型： number\n * 默认值： 8080\n\nModern.js 在执行 dev, start 和 serve 命令时，会以 8080\n为默认端口启动，并会在端口被占用时自动递增端口号。你可以通过该配置来修改 Server 启动的端口号：\n\n\n\n\n与 dev.port 的区别#\n\n大多数情况下，我们推荐使用 server.port 而不是 dev.port 来设置端口号，他们之间的区别如下：\n\n * dev.port 仅在开发环境下生效，server.port 在开发环境和生产环境下均能生效。\n * 在开发环境下，dev.port 的优先级高于 server.port。\n\n当你同时设置 dev.port 和 server.port 时，dev.port 会在开发环境下生效，server.port\n会在生产环境下生效。比如以下例子，在开发环境下监听的端口号为 3001，在生产环境下监听的端口号为 3002。\n\n","routePath":"/configure/app/server/port","lang":"zh","toc":[{"text":"与 dev.port 的区别","id":"与-devport-的区别","depth":3,"charIndex":131}],"domain":"","frontmatter":{"sidebar_label":"port"},"version":""},{"id":466,"title":"server.publicRoutes","content":"#\n\n * 类型： Object\n * 默认值： 根据文件约定自动生成的服务端路由规则，每个文件生成一条路由规则。\n\n该配置选项只作用于服务端路由，可以自定义 config/public/ 下资源的访问路由。\n\n对象的 key 为 config/public/ 的相对文件路径（不使用 ./）, 值可以是 string。\n\n","routePath":"/configure/app/server/public-routes","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_label":"publicRoutes"},"version":""},{"id":467,"title":"server.routes","content":"#\n\n * 类型： Object\n * 默认值： 根据文件约定自动生成的服务端路由规则，每个入口生成一条路由规则，入口名称等于路由路径。\n\n该配置选项只作用于服务端路由，可以自定义应用入口的访问路由。\n\n\n自定义访问路由#\n\n对象的 key 为当前应用的入口名, 值可以是 string | Array。\n\n当值类型为 string 时，当前值即表示访问该入口的路由名称。\n\n\n\n也可以通过 Array 为入口设置多个访问路由:\n\n\n\n此时，通过 /a、/b 两个路由都可以访问到 page-a 入口。\n\n执行 dev 命令后，可以在 dist/route.json 中查看入口 page-a 存在两条路由记录:\n\n\n\n\n自定义响应头#\n\n可以通过配置入口的 resHeaders 设置响应头：\n\n\n\nNOTE\n\n这一配置在生产环境与开发环境都生效，可以根据 NODE_ENV 区分环境设置不同的响应头。但如果你只需要在开发环境设置响应头，推荐使用\ntools.devServer.headers。","routePath":"/configure/app/server/routes","lang":"zh","toc":[{"text":"自定义访问路由","id":"自定义访问路由","depth":2,"charIndex":102},{"text":"自定义响应头","id":"自定义响应头","depth":2,"charIndex":310}],"domain":"","frontmatter":{"sidebar_label":"routes"},"version":""},{"id":468,"title":"server.ssrByEntries","content":"#\n\n * 类型： Object\n * 默认值： undefined\n\n按入口设置 SSR 选项，选项内的属性同 ssr，指定值会和 SSR 属性内容做替换合并操作，例如：\n\nINFO\n\n「 入口名 」默认为目录名，少数情况下通过 source.entries 自定义入口时，入口名为 source.entries 对象的 key。\n\n\n\n如上配置，项目整体启用了 SSR, 但是针对入口 page-a 关闭了 SSR 渲染能力。","routePath":"/configure/app/server/ssr-by-entries","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_label":"ssrByEntries"},"version":""},{"id":469,"title":"server.ssr","content":"#\n\n * 类型： boolean | Object\n * 默认值： false\n\nSSR 开关以及相关设置。\n\n\nBoolean 类型#\n\n当值类型为 boolean 时，表示是否开启 SSR 部署模式，默认 false 不开启。\n\n\n\n\nObject 类型#\n\n当值类型为 Object 时，可以配置如下属性：\n\n * mode：string = 'string'，默认为使用 renderToString 渲染。配置为 stream 开启流式渲染。\n * forceCSR：boolean = false，默认关闭强制 CSR 渲染。配置为 true 后，在页面访问时添加 ?csr=true 或添加请求头\n   x-modern-ssr-fallback 即可强制 CSR。\n * inlineScript：boolean = true，默认情况下，SSR 的数据会以内联脚本的方式注入到 HTML 中，并且直接赋值给全局变量。配置为\n   false 后，会下发 JSON，而不是赋值给全局变量，Streaming SSR 下，该配置不会生效。\n * disablePrerender: boolean = fasle, 为了兼容旧数据请求方式 - useLoader, 默认情况下 Modern.js\n   会对组件进行一次预渲染即有两次渲染。 开发者在保证项目中没有使用 useLoader Api 情况下, 可通过配置\n   disablePrerender=true来减少一次渲染。\n * unsafeHeaders: string[] = [], 为了安全考虑，Modern.js 不会往 SSR_DATA\n   添加过多的内容。开发者可以通过该配置，对需要注入的 headers 进行配置。\n * scriptLoading: 'defer' | 'blocking' | 'module' | 'async', 配置同\n   html.scriptLoading，支持 ssr 注入的 script 设置为 async 加载方式。优先级为 ssr.scriptLoading >\n   html.scriptLoading\n * loaderFailureMode: 'clientRender' | 'errorBoundary', 默认配置为 'errorBoundary'，当\n   data loader 中出错时，默认会渲染路由 Error 组件， 配置为 'clientRender' 时，有一个 data loader\n   抛错，就降级到客户端渲染，可以与 Client Loader 配合使用。\n\n\n\n\n主动降级#\n\n在生产环境，有时需要将 SSR 项目主动降级到 CSR，例如：\n\n 1. SSR 出现故障，需要降级到 CSR，保证产品可用性。\n\n 2. SSR 正常数据获取时页面渲染正常，但出错降级后渲染失败，需要进行调试。\n\n 3. SSR 服务压力过大，需要部分流量直接降级为 CSR，避免服务宕机。\n\n在项目中配置 server.ssr.forceCSR 为 true 后，我们可以通过请求的查询字符串，或是请求头来控制这一行为。\n\n例如在自定义 Web Server 的中间件中，检测到流量大于某一阈值时，主动降级：\n\n","routePath":"/configure/app/server/ssr","lang":"zh","toc":[{"text":"Boolean 类型","id":"boolean-类型","depth":3,"charIndex":57},{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":120},{"text":"主动降级","id":"主动降级","depth":3,"charIndex":1122}],"domain":"","frontmatter":{"sidebar_label":"ssr"},"version":""},{"id":470,"title":"source.aliasStrategy","content":"#\n\n * 类型： 'prefer-tsconfig' | 'prefer-alias'\n * 默认值： 'prefer-tsconfig'\n\nsource.aliasStrategy 用于控制 tsconfig.json 中的 paths 选项与打包工具的 alias 选项的优先级。\n\n\nprefer-tsconfig#\n\nsource.aliasStrategy 默认为 'prefer-tsconfig'，此时 tsconfig.json 中的 paths 选项和打包工具的\nalias 选项都会生效，但 tsconfig paths 选项的优先级更高。\n\n比如同时配置以下内容：\n\n * tsconfig paths:\n\n\n\n * source.alias:\n\n\n\n由于 tsconfig paths 的优先级更高，所以：\n\n * @common 会使用 tsconfig paths 定义的值，指向 ./src/common-1\n * @utils 会使用 source.alias 定义的值，指向 ./src/utils\n\n\nprefer-alias#\n\n当 source.aliasStrategy 的值为 prefer-alias 时，tsconfig.json 中的 paths 选项只用于提供\nTypeScript 类型定义，而不会对打包结果产生任何影响。此时，构建工具只会读取 alias 选项作为路径别名。\n\n\n\n比如同时配置以下内容：\n\n * tsconfig paths:\n\n\n\n * source.alias:\n\n\n\n由于 tsconfig paths 只用于提供类型，所以最终只有 @common 别名生效，并指向 ./src/common-2 目录。\n\n大部分情况下你不需要使用 prefer-alias，但当你需要动态生成一些别名配置时，可以考虑使用它。比如，基于环境变量来生成 alias 选项：\n\n","routePath":"/configure/app/source/alias-strategy","lang":"zh","toc":[{"text":"prefer-tsconfig","id":"prefer-tsconfig","depth":3,"charIndex":145},{"text":"prefer-alias","id":"prefer-alias","depth":3,"charIndex":469}],"domain":"","frontmatter":{"sidebar_label":"aliasStrategy"},"version":""},{"id":471,"title":"source.alias","content":"#\n\n * 类型： Record | Function\n * 默认值： undefined\n\n设置文件引用的别名，对应 webpack 和 Rspack 的 resolve.alias 配置。\n\nTIP\n\n对于 TypeScript 项目，你只需要在 tsconfig.json 中配置 compilerOptions.paths 即可，Builder\n会自动识别它，不需要额外配置 source.alias 字段，详见 「路径别名」。\n\n\nObject 类型#\n\nalias 的值可以定义为 Object 类型，其中的相对路径会自动被 Builder 转换为绝对路径。\n\n\n\n以上配置完成后，如果你在代码中引用 @common/Foo.tsx, 则会映射到 /src/common/Foo.tsx 路径上。\n\n\nFunction 类型#\n\nalias 的值定义为函数时，可以接受预设的 alias 对象，并对其进行修改。\n\n\n\n也可以在函数中返回一个新对象作为最终结果，新对象会覆盖预设的 alias 对象。\n\n\n\n\n精确匹配#\n\n默认情况，source.alias 会自动匹配子路径，比如以下配置：\n\n\n\n它的匹配结果如下：\n\n\n\n你可以添加 $ 符号来开启精确匹配，开启后将不会自动匹配子路径。\n\n\n\n它的匹配结果如下：\n\n\n\n\n处理 npm 包#\n\n你可以使用 alias 将某个 npm 包指向统一的目录。\n\n比如项目中安装了多份 react，你可以将 react 统一指向根目录的 node_modules 中安装的版本，避免出现打包多份 React 代码的问题。\n\n\n\n当你在使用 alias 处理 npm 包时，请留意项目中是否使用了这个包不同的 major 版本。\n\n比如你的项目中某个模块或 npm 依赖使用了 React 18 的 API，如果你将 React alias 到 17 版本，就会导致该模块无法引用到\nReact 18 的 API，导致代码异常。","routePath":"/configure/app/source/alias","lang":"zh","toc":[{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":220},{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":356},{"text":"精确匹配","id":"精确匹配","depth":3,"charIndex":459},{"text":"处理 npm 包","id":"处理-npm-包","depth":3,"charIndex":567}],"domain":"","frontmatter":{"sidebar_label":"alias"},"version":""},{"id":472,"title":"source.configDir","content":"#\n\n * 类型： string\n * 默认值： ./config\n\nModern.js 支持在 ./config 文件夹下放置一些文件自定义 HTML 模板、图标、静态资源等，具体可参考文件约定。\n\n通过该选项可以自定义配置文件的目录。\n\n例如，将资源文件目录调整为 resources 目录：\n\n","routePath":"/configure/app/source/config-dir","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_label":"configDir"},"version":""},{"id":473,"title":"source.decorators","content":"#\n\n * 类型：\n\n\n\n * 默认值：\n\n\n\n用于配置装饰器语法。\n\n\n示例#\n\nModern.js 默认使用 legacy 语法（Stage 1 提案），等价于 TypeScript 的 experimentalDecorators:\ntrue。\n\n如果希望将装饰器语法调整成 Stage 3 提案，可以将 decorators.version 设置成 2022-03：\n\n\n\n详细用法可参考 Rsbuild - source.decorators。","routePath":"/configure/app/source/decorators","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":36}],"domain":"","frontmatter":{"sidebar_label":"decorators"},"version":""},{"id":474,"title":"source.define","content":"#\n\n * 类型： Record\n * 默认值： {}\n\n构建时将代码中的变量替换成其它值或者表达式，可以用于在代码逻辑中区分开发环境与生产环境等场景。\n\n传入的配置对象的键名是需要替换变量的名称，或者是用 . 连接的多个标识符，配置项的值则根据类型进行不同的处理：\n\n * 字符串会被当作代码片段。\n * 包括函数在内的其他类型会被转换成字符串。\n * 嵌套对象的父子键名之间会用 . 连接作为需要替换的变量名。\n * 以 typeof 开头的键名会用来替换 typeof 调用。\n\n更多细节参考 webpack - DefinePlugin。\n\nTIP\n\n在使用 Rspack 作为打包工具时，支持的类型可参考 Rspack.builtins.define\n\n\n示例#\n\n\n\n表达式会被替换为对应的代码段：\n\n","routePath":"/configure/app/source/define","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":332}],"domain":"","frontmatter":{"sidebar_label":"define"},"version":""},{"id":475,"title":"source.disableDefaultEntries","content":"#\n\n * 类型： boolean\n * 默认值： false\n\n用于关闭基于目录结构来自动识别页面入口的功能。\n\nINFO\n\n默认情况下，Modern.js 会基于目录约定来自动确定页面的入口，具体可参考入口。\n\n设置如下，即可关闭默认的行为：\n\n\n\n关闭默认行为后，你需要使用 source.entries 配置自定义的入口。\n\nWARNING\n\n我们推荐使用 Modern.js 提供的目录规范来组织代码，从而更好地使用框架功能，避免一些冗余的配置。","routePath":"/configure/app/source/disable-default-entries","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_label":"disableDefaultEntries"},"version":""},{"id":476,"title":"source.disableEntryDirs","content":"#\n\n * 类型： string[]\n * 默认值： []\n\nModern.js 默认会根据 src 目录识别应用入口，你可以通过该选项禁止某些目录被识别为应用入口。\n\n例如，当配置与目录结构如下时：\n\n\n\n\n\n在未设置该配置项时，Modern.js 会根据项目目录产出两个 entry:\n\n * one\n * two\n\n当设置该配置项后，src/one 不会作为 entry 目录被识别。\n\n常见的用法是，将 src/common、src/components 目录配置到该选项中，避免这些目录被识别为应用入口。","routePath":"/configure/app/source/disable-entry-dirs","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_label":"disableEntryDirs"},"version":""},{"id":477,"title":"source.enableAsyncEntry","content":"#\n\n * 类型： boolean\n * 默认值： false\n\n该选项用于 webpack 模块联邦（Module Federation）场景。\n\n开启此选项后，Modern.js 会通过 dynamic import 来包裹自动生成的入口文件（Asynchronous\nBoundaries），使页面代码可以消费模块联邦生成的远程模块。\n\n\n背景知识#\n\n模块联邦（Module Federation，简称 MF）是 Webpack 的一个特性。它允许 JavaScript\n应用从另一个应用动态加载代码，并在此过程中共享依赖关系。如果使用联邦模块的应用缺少联邦代码所需的依赖项，Webpack 将从该联邦的构建源下载缺失的依赖项。\n\n这使得可以创建微前端风格的应用程序，多个系统可以共享代码，并在不需要重新构建整个应用程序的情况下进行动态更新。\n\nModern.js 提供了一个 Module Federation 的示例项目，请参考 module-federation-examples -\nmodernjs。\n\n你也可以阅读 webpack Module Federation 文档 来了解更多概念。\n\n\n示例#\n\n首先，在配置文件中开启此选项：\n\n\n\n然后执行 dev 或 build 命令，可以看到 Modern.js 自动生成的文件变为以下结构：\n\n\n\n其中 bootstrap.js 的内容如下：\n\n\n\n此时，就可以在当前页面中消费任意的远程模块了。\n\nINFO\n\nModern.js 未对 ModuleFederationPlugin 进行封装，请通过 tools.bundlerChain 自行配置\nModuleFederationPlugin。","routePath":"/configure/app/source/enable-async-entry","lang":"zh","toc":[{"text":"背景知识","id":"背景知识","depth":2,"charIndex":172},{"text":"示例","id":"示例","depth":2,"charIndex":507}],"domain":"","frontmatter":{"sidebar_label":"enableAsyncEntry"},"version":""},{"id":478,"title":"source.enableCustomEntry","content":"#\n\n * 类型： boolean\n * 默认值： false\n\n该选项用于使用 Modern.js 自定义入口场景。\n\n开启此选项后，Modern.js 将使用 src/entry.[jt]sx 文件作为项目的入口， 具体使用姿势可参考页面入口。\n\n\n示例#\n\n首先，在配置文件中开启此选项：\n\n\n\n创建 src/entry.tsx 文件：\n\n","routePath":"/configure/app/source/enable-custom-entry","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":126}],"domain":"","frontmatter":{"sidebar_label":"enableCustomEntry"},"version":""},{"id":479,"title":"source.entriesDir","content":"#\n\n * 类型： string\n * 默认值： ./src\n\nModern.js 默认会扫描 src 目录来识别页面入口，你可以通过该选项自定义页面入口的识别目录。\n\n例如，当配置与目录结构如下时：\n\n\n\n\n\nModern.js 会扫描 ./src/pages 目录，自动生成构建入口 a 和入口 b，结果如下：\n\n","routePath":"/configure/app/source/entries-dir","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_label":"entriesDir"},"version":""},{"id":480,"title":"source.entries","content":"#\n\n * 类型：\n\n\n\n * 默认值： 根据当前项目的目录结构计算出的入口对象。\n\n用于配置自定义页面入口。\n\n何时使用\n\n对于大部分场景，Modern.js 根据目录结构自动生成的入口已经可以满足需求，具体可参考入口。\n\n如果你需要自定义页面入口时，可以通过该选项进行设置。\n\n\nString 类型#\n\n当 entries 对象的 value 为 string 类型时，表示入口模块的文件路径:\n\n\n\n默认情况下，配置的入口等价于 App.[jt]sx，即指定的入口文件只需要导出应用的根组件。\n\n例如以下目录结构：\n\n\n\n上述目录不符合 Modern.js 的目录结构约定，因此，Modern.js 在分析目录结构时，不会得到任何默认入口。\n\n在不想改变目录结构的情况下（如项目迁移），可以通过 source.entries 自定义入口：\n\n\n\n\nObject 类型#\n\n当值为 Object 时，可配置如下属性：\n\n * entry：string，入口文件路径。\n * disableMount：boolean = false，关闭 Modern.js 自动生成入口代码的行为。\n * customBootstrap： string = ''，指定自定义 Bootstrap 的文件路径。\n\n\n\n\n禁用入口文件生成#\n\n默认情况下，配置的入口等价于 App.[jt]sx，Modern.js 会自动生成一个入口文件来引用你配置的入口。\n\n如果你希望禁用 Modern.js 自动生成入口文件的逻辑，可以将 disableMount 属性设置为 true。\n\n\n\n\n约定式路由#\n\n如果你需要为某个自定义入口启用约定式路由，可以将 entry 设置为目录路径：\n\n\n\n\n入口合并规则#\n\n在设置 source.entries 后，如果没有设置 disableDefaultEntries: true，Modern.js\n会将自定义入口与分析目录结构得到的入口合并。\n\n合并规则为：\n\n * 比较自定义入口设置的入口路径和默认入口路径，当入口路径一致时，自定义入口会覆盖默认入口。\n\n例如以下目录结构:\n\n\n\nModern.js 会分析 src/ 目录，得到默认入口 chat 和 home。当用户在 modern.config.ts 文件中配置如下时：\n\n\n\n可以看到自定义入口 index 的路径和默认入口 home 的路径一致，在合并的过程中，index 会覆盖掉 home，最终入口如下：\n\n * chat -> ./src/chat/App.tsx\n * index -> ./src/home/index.ts","routePath":"/configure/app/source/entries","lang":"zh","toc":[{"text":"String 类型","id":"string-类型","depth":2,"charIndex":141},{"text":"Object 类型","id":"object-类型","depth":2,"charIndex":376},{"text":"禁用入口文件生成","id":"禁用入口文件生成","depth":3,"charIndex":552},{"text":"约定式路由","id":"约定式路由","depth":3,"charIndex":685},{"text":"入口合并规则","id":"入口合并规则","depth":2,"charIndex":737}],"domain":"","frontmatter":{"sidebar_label":"entries"},"version":""},{"id":481,"title":"source.exclude","content":"#\n\n * 类型： Array\n * 默认值： []\n\n指定不需要编译的 JavaScript/TypeScript 文件。用法与 webpack 中的 Rule.exclude\n一致，支持传入字符串或正则表达式来匹配模块的路径。\n\n比如:\n\n","routePath":"/configure/app/source/exclude","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_label":"exclude"},"version":""},{"id":482,"title":"source.globalVars","content":"#\n\n * 类型： Record | Function\n * 默认值：\n\n\n\n用于在构建时将类似 process.env.FOO 的全局变量表达式替换为指定的值，比如：\n\n\n\n\n示例#\n\n在下方示例中，会在代码中注入 ENABLE_VCONSOLE 和 APP_CONTEXT 两个环境变量：\n\n\n\n你可以在代码中直接使用它们：\n\n\n\n\n函数用法#\n\n * 类型：\n\n\n\n你可以将 source.globalVars 设置为一个函数，从而动态设置一些环境变量的值。\n\n比如，根据当前的构建产物类型进行动态设置：\n\n\n\n\n与 define 的区别#\n\nsource.globalVars 是 source.define 的一个语法糖，它们之间唯一的区别是，source.globalVars 会自动将传入的值进行\nJSON 序列化处理，这使得设置全局变量的值更加方便。注意 globalVars 的每个值都需要是可以被 JSON 序列化的值。\n\n\n\n\n注意事项#\n\nsource.globalVars 是通过字符串替换的形式来注入环境变量的，因此它无法对「解构赋值」等动态写法生效。\n\n在使用解构赋值时，Builder 将无法判断变量 NODE_ENV 是否与要替换的表达式 process.env.NODE_ENV\n存在关联，因此以下使用方式是无效的：\n\n","routePath":"/configure/app/source/global-vars","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":88},{"text":"函数用法","id":"函数用法","depth":3,"charIndex":168},{"text":"与 define 的区别","id":"与-define-的区别","depth":3,"charIndex":259},{"text":"注意事项","id":"注意事项","depth":3,"charIndex":424}],"domain":"","frontmatter":{"sidebar_label":"globalVars"},"version":""},{"id":483,"title":"source.include","content":"#\n\n * 类型： RuleSetCondition[]\n * 默认值：\n\n\n\nsource.include 用于指定额外需要编译的 JavaScript 文件。\n\n为了避免二次编译，默认情况下，Rsbuild 只会编译当前目录下的 JavaScript 文件，以及所有目录下的 TypeScript 和 JSX\n文件，不会编译 node_modules 下的 JavaScript 文件。\n\n通过 source.include 配置项，可以指定需要 Rsbuild 额外进行编译的目录或模块。source.include 的用法与 Rspack 中的\nRule.include 一致，支持传入字符串、正则表达式来匹配模块的路径。\n\n比如:\n\n\n\n\n编译 npm 包#\n\n比较典型的使用场景是编译 node_modules 下的 npm 包，因为某些第三方依赖存在 ES6+\n的语法，这可能导致在低版本浏览器上无法运行，你可以通过该选项指定需要编译的依赖，从而解决此类问题。\n\n以 query-string 为例，你可以做如下的配置：\n\n\n\n上述两种方法分别通过 \"路径前缀\" 和 \"正则表达式\"\n来匹配文件的绝对路径，值得留意的是，项目中所有被引用的模块都会经过匹配，因此你不能使用过于松散的值进行匹配，避免造成编译性能问题或编译异常。\n\n\n编译 npm 包的子依赖#\n\n当你通过 source.include 编译一个 npm 包时，Builder 默认只会编译匹配到的模块，不会编译对应模块的子依赖。\n\n以 query-string 为例，它依赖的 decode-uri-component 包中同样存在 ES6+ 代码，因此你需要将\ndecode-uri-component 也加入到 source.include 中：\n\n\n\n\n编译 Monorepo 中的其他库#\n\n在 Monorepo 中进行开发时，如果需要引用 Monorepo 中其他库的源代码，也可以直接在 source.include 进行配置:\n\n\n\n\n编译 CommonJS 模块#\n\nBabel 默认无法编译 CommonJS 模块，如果你编译了一个 CommonJS 模块，可能会出现 exports is not defined\n的运行时报错信息。\n\n当你需要使用 source.include 来编译 CommonJS 模块时，可以将 Babel 的 sourceType 配置设置为 unambiguous：\n\n\n\n将 sourceType 设置为 unambiguous 可能会产生一些其他影响，请参考 Babel 官方文档。\n\n\n匹配 Symlink#\n\n如果你匹配的模块是通过 symlink 链接到当前项目中的，那么需要匹配这个模块的真实路径，而不是 symlink 后的路径。\n\n比如，你将 Monorepo 中的 packages/foo 路径 symlink 到当前项目的 node_modules/foo 路径下，则需要去匹配\npackages/foo 路径，而不是 node_modules/foo 路径。\n\n该行为可以通过 webpack 的 resolve.symlinks 配置项来进行控制。\n\n\n注意事项#\n\n注意，source.include 不应该被用于编译整个 node_modules 目录，比如下面的写法是错误的：\n\n\n\n如果你对整个 node_modules 进行编译，不仅会使编译时间大幅度增加，并且可能会产生不可预期的错误。因为 node_modules 中的大部分 npm\n包发布的已经是编译后的产物，通常没必要经过二次编译。此外，core-js 等 npm 包被编译后可能会出现异常。","routePath":"/configure/app/source/include","lang":"zh","toc":[{"text":"编译 npm 包","id":"编译-npm-包","depth":3,"charIndex":324},{"text":"编译 npm 包的子依赖","id":"编译-npm-包的子依赖","depth":3,"charIndex":571},{"text":"编译 Monorepo 中的其他库","id":"编译-monorepo-中的其他库","depth":3,"charIndex":768},{"text":"编译 CommonJS 模块","id":"编译-commonjs-模块","depth":3,"charIndex":863},{"text":"匹配 Symlink","id":"匹配-symlink","depth":3,"charIndex":1109},{"text":"注意事项","id":"注意事项","depth":3,"charIndex":1353}],"domain":"","frontmatter":{"sidebar_label":"include"},"version":""},{"id":484,"title":"source.mainEntryName","content":"#\n\n * 类型： string\n * 默认值： main\n\n该选项用于配置 Modern.js 的主入口名称。\n\n默认情况下，Modern.js 的默认主入口名称为 main，当使用单入口或者入口名称和 package.json 中 name\n字段一致时，会将对应入口作为主入口，通过该配置可以修改主入口的名称。\n\n比如将主入口名称改为 index：\n\n\n\n构建之后，对应 html 产物路径将会变为 dist/html/index/index.html。\n\nINFO\n\n当修改主入口名称后，其他 **ByEntries 的配置也需要对应调整使用修改后的入口名称。","routePath":"/configure/app/source/mainEntryName","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_label":"mainEntryName"},"version":""},{"id":485,"title":"source.moduleScopes","content":"#\n\n * 类型： Array | Function\n * 默认值： undefined\n * 打包工具： 仅支持 webpack\n\n限制源代码的引用路径。配置该选项后，所有源文件只能从约定的目录下引用代码，从其他目录引用代码会产生对应的报错提示。\n\n\n示例#\n\n首先我们配置 moduleScopes 仅包含 src 目录：\n\n\n\n然后在 src/App.tsx 中导入 src 目录外部的 utils/a 模块:\n\n\n\n在编译时，会提示引用路径错误:\n\n\n\n通过该选项配置 utils 目录，再进行编译，则不会出现错误提示。\n\n\n\n\nArray 类型#\n\n当 moduleScopes 的值为 Array 类型时，可以直接设置若干个代码路径，比如添加以下配置：\n\n\n\n\nFunction 类型#\n\nmoduleScopes 也支持通过函数的形式来进行修改，避免覆盖默认值：\n\n","routePath":"/configure/app/source/module-scopes","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":126},{"text":"Array 类型","id":"array-类型","depth":3,"charIndex":268},{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":336}],"domain":"","frontmatter":{"sidebar_label":"moduleScopes"},"version":""},{"id":486,"title":"source.preEntry","content":"#\n\n * 类型： string | string[]\n * 默认值： undefined\n\n在每个页面的入口文件前添加一段代码，这段代码会早于页面的代码执行，因此可以用于执行一些全局的代码逻辑，比如注入 polyfill、设置全局样式等。\n\n添加单个脚本#\n\n首先创建一个 src/polyfill.ts 文件：\n\n\n\n然后将 src/polyfill.ts 配置到 source.preEntry 上：\n\n\n\n重新运行编译并访问任意页面，可以看到 src/polyfill.ts 中的代码已经执行，并在 console 中输出了对应的内容。\n\n添加全局样式#\n\n你也可以通过 source.preEntry 来配置全局样式，这段 CSS 代码会早于页面代码加载，比如引入一个 normalize.css 文件：\n\n\n\n添加多个脚本#\n\n你可以将 preEntry 设置为数组来添加多个脚本，它们会按数组顺序执行：\n\n","routePath":"/configure/app/source/pre-entry","lang":"zh","toc":[{"text":"添加单个脚本","id":"添加单个脚本","depth":4,"charIndex":121},{"text":"添加全局样式","id":"添加全局样式","depth":4,"charIndex":273},{"text":"添加多个脚本","id":"添加多个脚本","depth":4,"charIndex":360}],"domain":"","frontmatter":{"sidebar_label":"preEntry"},"version":""},{"id":487,"title":"source.resolveExtensionPrefix","content":"#\n\n * 类型： string | Record\n * 默认值： undefined\n\n用于为 resolve.extensions 添加统一的前缀。\n\n如果多个文件拥有相同的名称，但具有不同的文件后缀，Builder 会根据 extensions\n数组的顺序进行识别，解析数组中第一个被识别的文件，并跳过其余文件。\n\n\n示例#\n\n下面是配置 .web 前缀的例子。\n\n\n\n配置完成后，extensions 数组会发生以下变化：\n\n\n\n在代码中 import './foo' 时，会优先识别 foo.web.js 文件，再识别 foo.js 文件。\n\n根据产物类型设置#\n\n当你同时构建多种类型的产物时，你可以为不同的产物类型设置不同的 extension 前缀。此时，你需要把 resolveExtensionPrefix\n设置为一个对象，对象的 key 为对应的产物类型。\n\n比如为 web 和 node 设置不同的 extension 前缀：\n\n\n\n在代码中 import './foo' 时，对于 node 产物，会优先识别 foo.node.js 文件，而对于 web 产物，则会优先识别\nfoo.web.js 文件。","routePath":"/configure/app/source/resolve-extension-prefix","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":161},{"text":"根据产物类型设置","id":"根据产物类型设置","depth":4,"charIndex":276}],"domain":"","frontmatter":{"sidebar_label":"resolveExtensionPrefix"},"version":""},{"id":488,"title":"source.resolveMainFields","content":"#\n\n * 类型：\n\n\n\n * 默认值： undefined\n\n该配置项将决定你使用 package.json 哪个字段导入 npm 模块。对应 webpack 的 resolve.mainFields 配置。\n\n\n示例#\n\n\n\n根据产物类型设置#\n\n当你同时构建多种类型的产物时，你可以为不同的产物类型设置不同的 mainFields。此时，你需要把 resolveMainFields 设置为一个对象，对象的\nkey 为对应的产物类型。\n\n比如为 web 和 node 设置不同的 mainFields：\n\n","routePath":"/configure/app/source/resolve-main-fields","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":107},{"text":"根据产物类型设置","id":"根据产物类型设置","depth":4,"charIndex":114}],"domain":"","frontmatter":{"sidebar_label":"resolveMainFields"},"version":""},{"id":489,"title":"source.transformImport","content":"#\n\n用于按需引入组件库的代码和样式，能力等价于 babel-plugin-import。\n\n它与 babel-plugin-import 的区别在于，source.transformImport 不与 Babel 耦合。Builder\n会自动识别当前使用的编译工具是 Babel、SWC 还是 Rspack，并添加相应的按需引入配置。\n\n * 类型：\n\n\n\n * 默认值：\n\n当项目中安装了 Ant Design 组件库 <= 4.x 版本时，Builder 会自动添加以下默认配置：\n\n\n\n当项目中安装了 Arco Design 组件库 时，Builder 会自动添加以下默认配置：\n\n\n\nTIP\n\n当你添加了 antd 或 @arco-design/web-react 相关的配置时，优先级会高于上述默认配置。\n\n\n示例#\n\n当使用上述 antd 默认配置：\n\n\n\n源代码如下：\n\n\n\n会被转换成：\n\n\n\n\n禁用默认配置#\n\n你可以手动设置 transformImport: false 来关掉 transformImport 的默认行为。\n\n\n\n比如，当你使用了 externals 来避免打包 antd 时，由于 transformImport 默认会转换 antd\n的引用路径，导致匹配的路径发生了变化，因此 externals 无法正确生效，此时你可以设置关闭 transformImport 来避免该问题。\n\n\n配置#\n\nlibraryName#\n\n * 类型： string\n\n用于指定需要按需加载的模块名称。当 Builder 遍历代码时，如果遇到了对应模块的 import 语句，则会对其进行转换。\n\nlibraryDirectory#\n\n * 类型： string\n * 默认值： 'lib'\n\n用于拼接转换后的路径，拼接规则为 ${libraryName}/${libraryDirectory}/${member}，其中 member 为引入成员。\n\n示例：\n\n\n\n转换结果:\n\n\n\nstyle#\n\n * 类型： boolean\n * 默认值： undefined\n\n确定是否需要引入相关样式，若为 true，则会引入路径 ${libraryName}/${libraryDirectory}/${member}/style。\n若为 false 或 undefined 则不会引入样式。\n\n当配置为 true 时：\n\n\n\n转换结果:\n\n\n\nstyleLibraryDirectory#\n\n * 类型： string\n * 默认值： undefined\n\n该配置用于拼接引入样式时的引入路径，若该配置被指定，则 style 配置项会被忽略。拼接引入路径为\n${libraryName}/${styleLibraryDirectory}/${member}。\n\n当配置为 styles 时：\n\n\n\n转换结果:\n\n\n\ncamelToDashComponentName#\n\n * 类型： boolean\n * 默认值： true\n\n是否需要将 camelCase 的引入转换成 kebab-case。\n\n示例：\n\n\n\n转换结果：\n\n\n\ntransformToDefaultImport#\n\n * 类型： boolean\n * 默认值： true\n\n是否将导入语句转换成默认导入。\n\n示例：\n\n\n\n转换结果：\n\n\n\ncustomName#\n\n * 类型： ((member: string) => string | undefined) | string\n * 默认值： undefined\n\n注意\n * 函数类型的配置只能在 Webpack 构建中使用。\n * 模版类型的配置只能在 Rspack 构建或者使用了 SWC 的 Webpack 构建中使用。\n\n自定义转换后的导入路径，输入是引入的成员，例如配置成 (member) => `my-lib/${member}` ，会将 转换成 。\n\n在使用 Rspack 构建时，不能使用函数配置，但可以使用 handlebars 模版字符串，对于上面的函数配置，在使用模版字符串时可以用以下模版代替\nmy-lib/{{ member }}，也可以使用一些内置帮助方法，例如 my-lib/{{ kebabCase member }} 来转换成\nkebab-case 格式，除了 kebabCase 以外还有 camelCase，snakeCase，upperCase，lowerCase 可以使用。\n\ncustomStyleName#\n\n * 类型： ((member: string) => string | undefined) | string\n * 默认值： undefined\n\n注意\n * 函数类型的配置只能在 Webpack 构建中使用。\n * 模版类型的配置只能在 Rspack 构建或者使用了 SWC 的 Webpack 构建中使用。\n\n自定义转换后的样式导入路径，输入是引入的成员，例如配置成 (member) => `my-lib/${member}` ，会将 转换成 。\n\n在使用 Rspack 构建时，不能使用函数配置，但可以使用 handlebars 模版字符串，对于上面的函数配置，在使用模版字符串时可以用以下模版代替\nmy-lib/{{ member }}，也可以使用一些内置帮助方法，例如 my-lib/{{ kebabCase member }} 来转换成\nkebab-case 格式，除了 kebabCase 以外还有 camelCase，snakeCase，upperCase，lowerCase 可以使用。","routePath":"/configure/app/source/transform-import","lang":"zh","toc":[{"text":"示例","id":"示例","depth":3,"charIndex":360},{"text":"禁用默认配置","id":"禁用默认配置","depth":3,"charIndex":406},{"text":"配置","id":"配置","depth":3,"charIndex":613},{"text":"libraryName","id":"libraryname","depth":4,"charIndex":618},{"text":"libraryDirectory","id":"librarydirectory","depth":4,"charIndex":711},{"text":"style","id":"style","depth":4,"charIndex":855},{"text":"styleLibraryDirectory","id":"stylelibrarydirectory","depth":4,"charIndex":1033},{"text":"camelToDashComponentName","id":"cameltodashcomponentname","depth":4,"charIndex":1219},{"text":"transformToDefaultImport","id":"transformtodefaultimport","depth":4,"charIndex":1327},{"text":"customName","id":"customname","depth":4,"charIndex":1416},{"text":"customStyleName","id":"customstylename","depth":4,"charIndex":1884}],"domain":"","frontmatter":{"sidebar_label":"transformImport"},"version":""},{"id":490,"title":"tools.autoprefixer","content":"#\n\n * 类型： Object | Function\n * 默认值：\n\n\n\n通过 tools.autoprefixer 可以修改 autoprefixer 的配置。\n\n\nObject 类型#\n\n当 tools.autoprefixer 的值为 Object 类型时，会与默认配置通过 Object.assign 合并。比如：\n\n\n\n\nFunction 类型#\n\n当 tools.autoprefixer 为 Function 类型时，默认配置作为第一个参数传入，可以直接修改配置对象，也可以返回一个值作为最终结果。比如：\n\n","routePath":"/configure/app/tools/autoprefixer","lang":"zh","toc":[{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":85},{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":167}],"domain":"","frontmatter":{"sidebar_label":"autoprefixer"},"version":""},{"id":491,"title":"tools.babel","content":"#\n\n * 类型： Object | Function\n * 默认值： undefined\n\n通过 tools.babel 可以修改 babel-loader 的配置项。\n\n\n使用场景#\n\n请留意 tools.babel 在以下使用场景中的局限性：\n\n * Rspack 场景：在使用 Rspack 作为打包工具时，使用 tools.babel 配置项将会明显拖慢 Rspack 构建速度。因为 Rspack\n   默认使用的是 SWC 编译，配置 Babel 会导致代码需要被编译两次，产生了额外的编译开销。\n * webpack + SWC 场景：在使用 webpack 作为打包工具时，如果你使用了 Builder 的 SWC 插件进行代码编译，那么\n   tools.babel 选项将不会生效。\n\n\nFunction 类型#\n\n当 tools.babel 为 Function 类型时，默认 Babel 配置会作为第一个参数传入，你可以直接修改配置对象，也可以返回一个对象作为最终的\nbabel-loader 配置。\n\n\n\ntools.babel 函数的第二个参数提供了一些方便的工具函数，请继续阅读下方文档。\n\nTIP\n\n以上示例仅作为参考，通常来说，你不需要手动配置 babel-plugin-import，因为 Builder 已经提供了更通用的\nsource.transformImport 配置。\n\n\nObject 类型#\n\n当 tools.babel 的值为 Object 类型时，会与默认配置通过 Object.assign 浅合并。\n\nCAUTION\n\nObject.assign 是浅拷贝，会完全覆盖内置的 presets 或 plugins 数组，导致内置的 presets 或 plugins\n失效，请在明确影响面的情况下再使用这种方式。\n\n\n\n\n工具函数#\n\ntools.babel 为 Function 类型时，第二个参数可用的工具函数如下:\n\naddPlugins#\n\n * 类型： (plugins: BabelPlugin[]) => void\n\n添加若干个 Babel 插件。\n\n\n\naddPresets#\n\n * 类型： (presets: BabelPlugin[]) => void\n\n添加若干个 Babel 预设配置 (大多数情况下不需要增加预设)。\n\n\n\nremovePlugins#\n\n * 类型： (plugins: string | string[]) => void\n\n移除 Babel 插件，传入需要移除的插件名称即可，你可以传入单个字符串，也可以传入一个字符串数组。\n\n\n\nremovePresets#\n\n * 类型： (presets: string | string[]) => void\n\n移除 Babel 预设配置，传入需要移除的预设名称即可，你可以传入单个字符串，也可以传入一个字符串数组。\n\n\n\nmodifyPresetEnvOptions#\n\n * 类型： (options: PresetEnvOptions) => void\n\n修改 @babel/preset-env 的配置项，传入的配置会与默认配置进行浅层合并，比如:\n\n\n\n\n\nmodifyPresetReactOptions#\n\n * 类型： (options: PresetReactOptions) => void\n\n修改 @babel/preset-react 的配置项，传入的配置会与默认配置进行浅层合并，比如:\n\n\n\naddIncludes#\n\n已废弃，请使用 source.include 代替，两者功能完全一致。\n\naddExcludes#\n\n已废弃，请使用 source.exclude 代替，两者功能完全一致。\n\n\n调试 Babel 配置#\n\n当你通过 tools.babel 修改 babel-loader 配置后，可以在 Builder 调试模式 下查看最终生成的配置。\n\n首先通过 DEBUG=builder 参数开启调试模式：\n\n\n\n然后打开生成的 (webpack|rspack).config.web.js，搜索 babel-loader 关键词，即可看到完整的 babel-loader\n配置内容。","routePath":"/configure/app/tools/babel","lang":"zh","toc":[{"text":"使用场景","id":"使用场景","depth":3,"charIndex":87},{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":354},{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":610},{"text":"工具函数","id":"工具函数","depth":3,"charIndex":789},{"text":"addPlugins","id":"addplugins","depth":4,"charIndex":840},{"text":"addPresets","id":"addpresets","depth":4,"charIndex":913},{"text":"removePlugins","id":"removeplugins","depth":4,"charIndex":1004},{"text":"removePresets","id":"removepresets","depth":4,"charIndex":1119},{"text":"modifyPresetEnvOptions","id":"modifypresetenvoptions","depth":4,"charIndex":1236},{"text":"modifyPresetReactOptions","id":"modifypresetreactoptions","depth":4,"charIndex":1358},{"text":"addIncludes","id":"addincludes","depth":4,"charIndex":1484},{"text":"addExcludes","id":"addexcludes","depth":4,"charIndex":1535},{"text":"调试 Babel 配置","id":"调试-babel-配置","depth":3,"charIndex":1587}],"domain":"","frontmatter":{"sidebar_label":"babel"},"version":""},{"id":492,"title":"tools.bundlerChain","content":"#\n\n * 类型： Function | undefined\n * 默认值： undefined\n\n你可以通过 tools.bundlerChain 来修改默认的 webpack 和 Rspack 配置，它的值为 Function 类型，接收两个参数：\n\n * 第一个参数为 bundler-chain 对象实例，你可以通过这个实例来修改 webpack 和 Rspack 的配置。\n * 第二个参数为一个工具集合，包括env、isProd、CHAIN_ID 等。\n\n什么是 BundlerChain\n\nBundler chain 是 webpack chain 的子集，其中包含一部分 webpack chain API，你可以用它来同时修改 webpack 和\nRspack 的配置。\n\n通过 bundler chain 修改的配置，在 webpack 和 Rspack 构建时均可生效。需要注意的是，bundler chain 只支持修改\nwebpack 和 Rspack 间无差异部分的配置。如，修改 devtool 配置项(webpack 和 Rspack 的 devtool\n属性值类型相同)，或添加一个Rspack 兼容的 webpack 插件。\n\n> tools.bundlerChain 的执行时机早于 tools.webpackChain / tools.webpack /\n> tools.rspack，因此会被其他几个配置中的修改所覆盖。\n\n更多信息可参考 Rsbuild#tools.bundlerChain","routePath":"/configure/app/tools/bundler-chain","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_label":"bundlerChain"},"version":""},{"id":493,"title":"tools.cssExtract","content":"#\n\n * 类型： Object | Function\n * 默认值：\n\n\n\n通过 tools.cssExtract 可以更改 CssExtractRspackPlugin 或 mini-css-extract-plugin 的配置。\n\n详细用法可参考 Rsbuild - tools.cssExtract。","routePath":"/configure/app/tools/css-extract","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_label":"cssExtract"},"version":""},{"id":494,"title":"tools.cssLoader","content":"#\n\n * 类型： Object | Function\n * 默认值： undefined\n\n通过 tools.cssLoader 可以修改 css-loader 的配置项。默认配置如下:\n\n\n\n详细用法可参考 Rsbuild - tools.cssLoader。","routePath":"/configure/app/tools/css-loader","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_label":"cssLoader"},"version":""},{"id":495,"title":"tools.devServer","content":"#\n\n * 类型： Object\n * 默认值： {}\n\n通过 tools.devServer 可以修改开发环境服务器的配置。\n\nTIP\n\nModern.js 中并没有直接使用 webpack-dev-server 或 @rspack/dev-server, 而是基于\nwebpack-dev-middleware 实现 DevServer。\n\n\n选项#\n\nafter#\n\nWARNING\n\nDeprecated：该配置已废弃，请使用 dev.setupMiddlewares 代替。\n\n * 类型： Array\n * 默认值： []\n\n添加自定义中间件，在所有开发环境中间件后执行。\n\n\n\nwebpack-dev-server 使用 Express 作为服务端框架。Modern.js 中没有使用任何框架，上述中间件中 req 和 res 都是\nNode 原生对象，因此 webpack-dev-server 的 Express 中间件不一定能直接在 Modern.js 中使用。\n\n如果要迁移 webpack-dev-server 中使用的 Express 中间件，可以使用以下方式，将 Express app 作为中间件传入：\n\n\n\nbefore#\n\nWARNING\n\nDeprecated：该配置已废弃，请使用 dev.setupMiddlewares 代替。\n\n * 类型： Array\n * 默认值： []\n\n添加自定义中间件，在所有开发环境中间件前执行。\n\n\n\nclient#\n\nWARNING\n\nDeprecated：该配置已废弃，请使用 dev.client 代替。\n\n * 类型：\n\n\n\n * 默认值：\n\n\n\n对应 HMR 客户端的配置，通常用于设置 HMR 对应的 WebSocket URL。\n\ncompress#\n\n * 类型： boolean\n * 默认值： true\n\n是否对静态资源启用 gzip 压缩。\n\n如果你需要禁用 gzip 压缩，可以将 compress 设置为 false：\n\n\n\ndevMiddleware#\n\nWARNING\n\nDeprecated：该配置已废弃，请使用 dev.writeToDisk 代替。\n\n * 类型：\n\n\n\n * 默认值：\n\n\n\ndevMiddleware 配置项。当前配置是 webpack-dev-middleware 配置项的子集.\n\nheaders#\n\n * 类型： Record\n * 默认值： undefined\n\n设置自定义响应头。\n\n\n\nhistoryApiFallback#\n\n * 类型： boolean | ConnectHistoryApiFallbackOptions\n * 默认值： false\n\n在需要对一些 404 响应或其他请求提供替代页面的场景，可通过 devServer.historyApiFallback 进行设置：\n\n\n\n更多选项和详细信息可参考 connect-history-api-fallback 文档。\n\nhot#\n\nWARNING\n\nDeprecated：该配置已废弃，请使用 dev.hmr 代替。\n\n * 类型： boolean\n * 默认值： true\n\n是否开启 Hot Module Replacement 热更新能力。\n\nhttps#\n\nWARNING\n\nDeprecated：该配置已废弃，请使用 dev.https 代替。\n\n * 类型： boolean | { key: string; cert: string }\n * 默认值： false\n\n默认情况下，DevServer 会启用 HTTP 服务器。通过设置 devServer.https 为 true 将开启对 HTTPS 的支持，同时会禁用\nHTTP 服务器。\n\n你也可以手动传入 HTTPS 服务器所需要的证书和对应的私钥：\n\n\n\nliveReload#\n\nWARNING\n\nDeprecated：该配置已废弃，请使用 dev.liveReload 代替。\n\n * 类型： boolean\n * 默认值： true\n\n默认情况下，当监听到文件变化时，DevServer 将会刷新页面（为使 liveReload 能够生效，devServer.hot 配置项应当禁用）。通过设置\ndevServer.liveReload 为 false 可以关闭该行为。\n\nsetupMiddlewares#\n\nWARNING\n\nDeprecated：该配置已废弃，请使用 dev.setupMiddlewares 代替。\n\n * 类型：\n\n\n\n * 默认值： undefined\n\n提供执行自定义函数和应用自定义中间件的能力。\n\n几种不同中间件之间的执行顺序是: devServer.before => unshift => 内置中间件 => push =>\ndevServer.after。\n\n\n\n一些特殊场景需求可能需要使用服务器 API：\n\n * sockWrite。允许向 hmr 客户端传递一些消息，hmr 客户端将根据接收到的消息类型进行不同的处理。如果你发送一个\n   \"content-changed \" 的消息，页面将会重新加载。\n\n\n\nproxy#\n\n * 类型： Record | Record\n * 默认值： undefined\n\n代理请求到指定的服务上。\n\n\n\n此时，/api/users 请求将会代理到 http://localhost:3000/api/users。\n\n如果你不想传递 /api，可以通过 pathRewrite 重写请求路径：\n\n\n\nDevServer Proxy 基于 http-proxy-middleware 实现。你可以使用 http-proxy-middleware\n的所有配置项，具体可以查看文档。\n\nDevServer Proxy 完整类型定义为：\n\n\n\n除了 http-proxy-middleware 的选项外，还支持 bypass 和 context 两个配置项：\n\n * bypass：根据函数的返回值绕过代理。\n   * 返回 null 或 undefined 会继续用代理处理请求。\n   * 返回 false 会返回 404 错误。\n   * 返回一个具体的服务路径，将会使用此路径替代原请求路径。\n * context：如果你想代理多个特定的路径到同一个目标，你可以使用 context 配置项。\n\n\n\n\n\nwatch#\n\n * 类型： boolean\n * 默认值： true\n\n是否监听 mock/、server/、api/ 等目录的文件变化。","routePath":"/configure/app/tools/dev-server","lang":"zh","toc":[{"text":"选项","id":"选项","depth":3,"charIndex":173},{"text":"after","id":"after","depth":4,"charIndex":178},{"text":"before","id":"before","depth":4,"charIndex":519},{"text":"client","id":"client","depth":4,"charIndex":637},{"text":"compress","id":"compress","depth":4,"charIndex":759},{"text":"devMiddleware","id":"devmiddleware","depth":4,"charIndex":862},{"text":"headers","id":"headers","depth":4,"charIndex":1007},{"text":"historyApiFallback","id":"historyapifallback","depth":4,"charIndex":1063},{"text":"hot","id":"hot","depth":4,"charIndex":1266},{"text":"https","id":"https","depth":4,"charIndex":1381},{"text":"liveReload","id":"livereload","depth":4,"charIndex":1621},{"text":"setupMiddlewares","id":"setupmiddlewares","depth":4,"charIndex":1833},{"text":"proxy","id":"proxy","depth":4,"charIndex":2175},{"text":"watch","id":"watch","depth":4,"charIndex":2690}],"domain":"","frontmatter":{"sidebar_label":"devServer"},"version":""},{"id":496,"title":"tools.esbuild","content":"#\n\n * 类型： Object\n * 默认值： undefined\n\nWARNING\n\n当前文档中的 esbuild 功能已停止迭代，我们更推荐使用 Rspack + SWC 的方案，因为 Rspack + SWC\n具备更好的构建性能、功能丰富度和产物兼容性。\n\n请参考「使用 Rspack」了解更多。\n\n\n介绍#\n\nesbuild 是一款基于 Golang 开发的前端构建工具，具有打包、编译和压缩 JavaScript 代码的功能，相比传统的打包编译工具，esbuild\n在性能上有显著提升。在代码压缩方面，相比 webpack 内置的 terser 压缩器，esbuild 在性能上有数十倍的提升。\n\nModern.js Builder 提供了 esbuild 插件，让你能使用 esbuild 代替 babel-loader、ts-loader 和\nterser 等库进行代码编译和压缩。在大型工程中启用 esbuild 后，可以大幅度减少代码编译和压缩所需的时间，同时有效避免 OOM (heap out\nof memory) 问题。\n\n\n配置项#\n\n你可以通过 tools.esbuild 配置项来设置 esbuild 编译行为。\n\n\n\n完整配置项请参考 Modern.js Builder - esbuild 插件配置。","routePath":"/configure/app/tools/esbuild","lang":"zh","toc":[{"text":"介绍","id":"介绍","depth":2,"charIndex":154},{"text":"配置项","id":"配置项","depth":2,"charIndex":475}],"domain":"","frontmatter":{"sidebar_label":"esbuild"},"version":""},{"id":497,"title":"tools.htmlPlugin","content":"#\n\n * 类型： false | Object | Function\n * 默认值：\n\n\n\n通过 tools.htmlPlugin 可以修改 html-webpack-plugin 或 html-rspack-plugin 的配置项。\n\n\n禁用 HTML#\n\n将 tools.htmlPlugin 配置为 false，可以禁用默认的 html-webpack-plugin 插件。\n\n\n\n\n禁用 JS / CSS 压缩#\n\n默认情况下，Builder 会在生产环境构建时压缩 HTML 内的 JavaScript / CSS\n代码，从而提升页面性能。此能力通常在使用自定义模版或插入自定义脚本时会有帮助。然而，当开启 output.enableInlineScripts 或\noutput.enableInlineStyles 时，会出现对 inline JavaScript / CSS\n代码重复压缩的情况，对构建性能会有一定影响。你可以通过修改 tools.htmlPlugin.minify 配置项来修改默认的压缩行为。\n\n\n\n详细用法可参考 Rsbuild - tools.htmlPlugin。","routePath":"/configure/app/tools/html-plugin","lang":"zh","toc":[{"text":"禁用 HTML","id":"禁用-html","depth":3,"charIndex":120},{"text":"禁用 JS / CSS 压缩","id":"禁用-js--css-压缩","depth":3,"charIndex":195}],"domain":"","frontmatter":{"sidebar_label":"htmlPlugin"},"version":""},{"id":498,"title":"tools.less","content":"#\n\n * 类型： Object | Function\n * 默认值：\n\n\n\n你可以通过 tools.less 修改 less-loader 的配置。\n\n\nObject 类型#\n\n当 tools.less 的值为 Object 类型时，会与默认配置通过 Object.assign 进行浅层合并，值得注意的是，lessOptions 会通过\ndeepMerge 进行深层合并。\n\n\n\n\nFunction 类型#\n\n当 tools.less 为 Function\n类型时，默认配置作为第一个参数传入，可以直接修改配置对象，也可以返回一个值作为最终结果，第二个参数提供了一些可以直接调用的工具函数：\n\n\n\n\n修改 Less 版本#\n\n在某些场景下，如果你需要使用特定的 Less 版本，而不是使用 Builder 内置的 Less v4，可以在项目中安装需要使用的 Less 版本，并通过\nless-loader 的 implementation 选项设置。\n\n\n\n\n工具函数#\n\naddExcludes#\n\n * 类型： (excludes: RegExp | RegExp[]) => void\n\n用来指定 less-loader 不编译哪些文件，你可以传入一个或多个正则表达式来匹配 less 文件的路径。例如：\n\n","routePath":"/configure/app/tools/less","lang":"zh","toc":[{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":77},{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":192},{"text":"修改 Less 版本","id":"修改-less-版本","depth":3,"charIndex":301},{"text":"工具函数","id":"工具函数","depth":3,"charIndex":431},{"text":"addExcludes","id":"addexcludes","depth":4,"charIndex":438}],"domain":"","frontmatter":{"sidebar_label":"less"},"version":""},{"id":499,"title":"tools.minifyCss","content":"#\n\n * 类型： Object | Function | undefined\n * 默认值：\n\n\n\n在生产环境构建时，Builder 会通过 css-minimizer-webpack-plugin 对 CSS 代码进行压缩优化。可以通过\ntools.minifyCss 修改 css-minimizer-webpack-plugin 的配置。\n\n\nObject 类型#\n\n当 tools.minifyCss 的值为 Object 类型时，会与默认配置通过 Object.assign 合并。\n\n例如下面修改 cssnano 的 preset 配置：\n\n\n\n\nFunction 类型#\n\n当 tools.minifyCss 配置为 Function 类型时，默认配置作为第一个参数传入，可以直接修改配置对象，也可以返回一个值作为最终结果。\n\n","routePath":"/configure/app/tools/minify-css","lang":"zh","toc":[{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":175},{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":280}],"domain":"","frontmatter":{"sidebar_label":"minifyCss"},"version":""},{"id":500,"title":"tools.postcss","content":"#\n\n * 类型： Object | Function\n * 默认值：\n\n\n\nBuilder 默认集成 PostCSS，你可以通过 tools.postcss 对 postcss-loader 进行配置。\n\n\nFunction 类型#\n\n值为 Function 类型时，内部默认配置作为第一参数传入，可以直接修改配置对象不做返回，也可以返回一个对象作为最终结果；第二个参数为修改\npostcss-loader 配置的工具函数集合。\n\n例如，需要在原有插件的基础上新增一个 PostCSS 插件，在 postcssOptions.plugins 数组中 push 一个新的插件即可：\n\n\n\n需要给 PostCSS 插件传递参数时，可以通过函数参数的形式进行传入：\n\n\n\ntools.postcss 可以返回一个配置对象，并完全替换默认配置：\n\n\n\n\nObject 类型#\n\n当此值为 Object 类型时，与默认配置通过 Object.assign 合并。注意 Object.assign 是浅拷贝，会完全覆盖内置的 plugins\n数组，请谨慎使用。\n\n\n\n\n工具函数#\n\naddPlugins#\n\n * 类型： (plugins: PostCSSPlugin | PostCSSPlugin[]) => void\n\n用于添加额外的 PostCSS 插件，你可以传入单个 PostCSS 插件，也可以传入 PostCSS 插件数组。\n\n\n\nTIP\n\nBuilder 中使用的 PostCSS 版本为 v8，当你引入社区中的 PostCSS 插件时，请注意版本是否适配，部分旧版本插件可能无法在 PostCSS\nv8 下运行。","routePath":"/configure/app/tools/postcss","lang":"zh","toc":[{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":104},{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":373},{"text":"工具函数","id":"工具函数","depth":3,"charIndex":479},{"text":"addPlugins","id":"addplugins","depth":4,"charIndex":486}],"domain":"","frontmatter":{"sidebar_label":"postcss"},"version":""},{"id":501,"title":"tools.pug","content":"#\n\n * 类型： true | Object | Function | undefined\n * 默认值： false\n\n配置 Pug 模板引擎。\n\n\nBoolean 类型#\n\nBuilder 默认不启用 Pug 模板引擎，你可以将 tools.pug 设置为 true 来启用它。\n\n\n\n启用后，你可以在 html.template 中指定使用 index.pug 作为模板文件。\n\n\nObject 类型#\n\n当 tools.terser 的值为 Object 类型时，可以配置 Pug 模板引擎的选项：\n\n\n\n详细参数请查看 Pug API Reference。\n\n\nFunction 类型#\n\n当 tools.pug 配置为 Function 类型时，默认配置作为第一个参数传入，可以直接修改配置对象，也可以返回一个值作为最终结果。\n\n","routePath":"/configure/app/tools/pug","lang":"zh","toc":[{"text":"Boolean 类型","id":"boolean-类型","depth":3,"charIndex":76},{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":194},{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":286}],"domain":"","frontmatter":{"sidebar_label":"pug"},"version":""},{"id":502,"title":"tools.rspack","content":"#\n\n * 类型： Object | Function | undefined\n * 默认值： undefined\n * 打包工具： 仅支持 Rspack\n\ntools.rspack 选项用于配置原生的 Rspack。\n\n\nObject 类型#\n\ntools.rspack 可以配置为一个对象，这个对象将会和内置的 Rspack 配置通过 webpack-merge 进行深层合并。\n\n比如添加 resolve.alias 配置：\n\n\n\n\nFunction 类型#\n\ntools.rspack 也可以配置为一个函数，这个函数接收一个参数，即内置的 Rspack 配置对象，你可以对这个对象进行修改，然后返回一份新的配置。比如：\n\n\n\nTIP\n\ntools.rspack 函数返回的对象会直接作为最终使用的 Rspack 配置，不会再与内置的 Rspack 配置进行合并。\n\n\n工具集合#\n\n这个函数的第二个参数是一个对象，包含了一些工具函数和属性，详情如下：\n\nenv#\n\n * 类型： 'development' | 'production' | 'test'\n\n通过 env 参数可以判断当前环境为 development、production 还是 test。比如：\n\n\n\nisProd#\n\n * 类型： boolean\n\n通过 isProd 参数可以判断当前环境是否为 production。比如：\n\n\n\ntarget#\n\n * 类型： 'web' | 'node' | 'modern-web' | 'web-worker'\n\n通过 target 参数可以判断当前构建的目标运行时环境。比如：\n\n\n\nisServer#\n\n * 类型： boolean\n\n判断当前构建的目标运行时环境是否为 node，等价于 target === 'node'。\n\n\n\nisWebWorker#\n\n * 类型： boolean\n\n判断当前构建的目标运行时环境是否为 web-worker，等价于 target === 'web-worker'。\n\n\n\nrspack#\n\n * 类型： typeof import('@rspack/core')\n\n通过这个参数你可以拿到 Rspack 实例。比如：\n\n\n\naddRules#\n\n * 类型： (rules: RuleSetRule | RuleSetRule[]) => void\n\n添加额外的 Rspack rules。\n\n示例：\n\n\n\nprependPlugins#\n\n * 类型： (plugins: RspackPluginInstance | RspackPluginInstance[]) => void\n\n在内部 Rspack 插件数组头部添加额外的插件，数组头部的插件会优先执行。\n\n\n\nappendPlugins#\n\n * 类型： (plugins: RspackPluginInstance | RspackPluginInstance[]) => void\n\n在内部 Rspack 插件数组尾部添加额外的插件，数组尾部的插件会在最后执行。\n\n\n\nremovePlugin#\n\n * 类型： (name: string) => void\n\n删除内部的 Rspack 插件，参数为该插件的 constructor.name。\n\n例如，删除内部的 webpack-bundle-analyzer：\n\n\n\nmergeConfig#\n\n * 类型： (...configs: RspackConfig[]) => RspackConfig\n\n用于合并多份 Rspack 配置，等价于 webpack-merge。\n\n","routePath":"/configure/app/tools/rspack","lang":"zh","toc":[{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":111},{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":219},{"text":"工具集合","id":"工具集合","depth":3,"charIndex":387},{"text":"env","id":"env","depth":4,"charIndex":430},{"text":"isProd","id":"isprod","depth":4,"charIndex":539},{"text":"target","id":"target","depth":4,"charIndex":606},{"text":"isServer","id":"isserver","depth":4,"charIndex":704},{"text":"isWebWorker","id":"iswebworker","depth":4,"charIndex":780},{"text":"rspack","id":"rspack","depth":4,"charIndex":871},{"text":"addRules","id":"addrules","depth":4,"charIndex":947},{"text":"prependPlugins","id":"prependplugins","depth":4,"charIndex":1039},{"text":"appendPlugins","id":"appendplugins","depth":4,"charIndex":1171},{"text":"removePlugin","id":"removeplugin","depth":4,"charIndex":1303},{"text":"mergeConfig","id":"mergeconfig","depth":4,"charIndex":1429}],"domain":"","frontmatter":{"sidebar_label":"rspack"},"version":""},{"id":503,"title":"tools.sass","content":"#\n\n * 类型： Object | Function\n * 默认值：\n\n\n\n你可以通过 tools.sass 修改 sass-loader 的配置。\n\n\nObject 类型#\n\n当 tools.sass 的值为 Object 类型时，会与默认配置通过 Object.assign 进行浅层合并，值得注意的是，sassOptions 会通过\ndeepMerge 进行深层合并。\n\n\n\n\nFunction 类型#\n\n当 tools.sass 为 Function\n类型时，默认配置作为第一个参数传入，可以直接修改配置对象，也可以返回一个值作为最终结果，第二个参数提供了一些可以直接调用的工具函数：\n\n\n\n\n修改 Sass 版本#\n\n在某些场景下，如果你需要使用特定的 Sass 版本，而不是使用 Builder 内置的 Dart Sass v1，可以在项目中安装需要使用的 Sass\n版本，并通过 sass-loader 的 implementation 选项设置。\n\n\n\n\n工具函数#\n\naddExcludes#\n\n * 类型： (excludes: RegExp | RegExp[]) => void\n\n用来指定 sass-loader 不编译哪些文件，你可以传入一个或多个正则表达式来匹配 sass 文件的路径。例如：\n\n","routePath":"/configure/app/tools/sass","lang":"zh","toc":[{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":77},{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":192},{"text":"修改 Sass 版本","id":"修改-sass-版本","depth":3,"charIndex":301},{"text":"工具函数","id":"工具函数","depth":3,"charIndex":436},{"text":"addExcludes","id":"addexcludes","depth":4,"charIndex":443}],"domain":"","frontmatter":{"sidebar_label":"sass"},"version":""},{"id":504,"title":"tools.styleLoader","content":"#\n\n * 类型： Object | Function\n * 默认值： {}\n\n通过 tools.styleLoader 可以设置 style-loader 的配置项。\n\n值得注意的是，Builder 默认不会开启 style-loader，你可以通过 output.disableCssExtract 配置项来开启它。\n\n\nObject 类型#\n\n当此值为 Object 类型时，与默认配置通过 Object.assign 合并。比如：\n\n\n\n\nFunction 类型#\n\n当此值为 Function 类型时，默认配置作为第一个参数传入，你可以直接修改配置对象，也可以返回一个对象作为最终配置。比如：\n\n","routePath":"/configure/app/tools/style-loader","lang":"zh","toc":[{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":162},{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":223}],"domain":"","frontmatter":{"sidebar_label":"styleLoader"},"version":""},{"id":505,"title":"tools.styledComponents","content":"#\n\n * 类型： Object | Function | false\n * 默认值：\n\n\n\n对应 babel-plugin-styled-components 或使用 SWC 时 @swc/plugin-styled-components 的配置。\n值为 Object 类型时，利用 Object.assign 函数与默认配置合并。比如:\n\n\n\n值为 Function 类型时，第一个参数为默认配置，第二个参数提供了一些可以直接调用的工具函数：\n\n\n\n该特性默认启用，你可以配置 tools.styledComponents 为 false 来关闭该行为，关闭后可以提升编译性能：\n\n","routePath":"/configure/app/tools/styled-components","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_label":"styledComponents"},"version":""},{"id":506,"title":"tools.swc","content":"#\n\n * 类型： Object | Function\n * 默认值： undefined\n\n\n介绍#\n\nSWC (Speedy Web Compiler) 是基于 Rust 语言编写的高性能 JavaScript 和 TypeScript 转译和压缩工具。在\nPolyfill 和语法降级方面可以和 Babel 提供一致的能力，并且性能比 Babel 高出一个数量级。\n\nModern.js 提供了开箱即用的 SWC 插件，可以为你的 Web 应用提供语法降级、Polyfill 以及压缩，并且移植了一些额外常见的 Babel\n插件。\n\nTIP\n\n在使用 Rspack 作为打包工具时，默认会使用 SWC 进行转译和压缩，因此你不需要再安装和配置 SWC 插件。\n\n\n在 Rspack 模式下使用#\n\n通过 tools.swc 可以设置 Rspack builtin:swc-loader 的选项。\n\n\n\n更多用法可参考 Rsbuild - tools.swc。\n\n\n在 Webpack 模式下使用#\n\n首先，你需要执行 pnpm run new 启用 SWC 编译：\n\n\n\n执行完成后，你只需在 modern.config.ts 文件中注册 Modern.js 的 SWC 插件，即可启用 SWC 编译和压缩能力。\n\n\n\n\n配置项#\n\n你可以通过 tools.swc 配置项来设置 SWC 编译行为。\n\n\n\n当然也可以使用函数进行更灵活的配置，或者修改某些默认配置。\n\n\n\n完整配置项请参考 Modern.js Builder - SWC 插件配置。","routePath":"/configure/app/tools/swc","lang":"zh","toc":[{"text":"介绍","id":"介绍","depth":2,"charIndex":47},{"text":"在 Rspack 模式下使用","id":"在-rspack-模式下使用","depth":2,"charIndex":334},{"text":"在 Webpack 模式下使用","id":"在-webpack-模式下使用","depth":2,"charIndex":434},{"text":"配置项","id":"配置项","depth":3,"charIndex":563}],"domain":"","frontmatter":{"sidebar_label":"swc"},"version":""},{"id":507,"title":"tools.tailwindcss","content":"#\n\n * 类型： Object | Function\n * 默认值：\n\n\n\n用于修改 Tailwind CSS 的配置项。\n\n\n启用 Tailwind CSS#\n\n在使用 tools.tailwindcss 之前，你需要启用 Modern.js 的 Tailwind CSS 插件。\n\n请阅读「使用 Tailwind CSS」 章节来了解开启方式。\n\n\nFunction 类型#\n\n当 tools.tailwindcss 为 Function 类型时，默认配置会作为第一个参数传入，你可以直接修改配置对象，也可以返回一个值作为最终结果：\n\n\n\n\nObject 类型#\n\n当 tools.tailwindcss 的值为 Object 类型时，会与默认配置通过 Object.assign 浅合并。\n\n\n\n\n注意事项#\n\n注意：\n\n * 如果你同时使用了 tailwind.config.{ts,js} 文件和 tools.tailwindcss 选项，那么\n   tools.tailwindcss 定义的配置会优先生效，并覆盖 tailwind.config.{ts,js} 中定义的内容。\n * 如果你同时使用了 source.designSystem 配置项，那么 Tailwind CSS 的 theme 配置将会被\n   source.designSystem 的值所覆盖。\n\n其他配置的使用方式与 Tailwind CSS 官方用法一致，请参考 tailwindcss - Configuration。\n\n\n关于 source.designSystem#\n\nsource.designSystem 是 Modern.js 中废弃的配置项。\n\n从 Modern.js v2.33.0 版本开始，你可以使用 Tailwind CSS 的 theme 配置项来代替\nsource.designSystem，不再需要将 theme 配置拆分并设置到 designSystem 上。\n\n * 旧版本用法：\n\n\n\n * 当前版本用法：\n\n","routePath":"/configure/app/tools/tailwindcss","lang":"zh","toc":[{"text":"启用 Tailwind CSS","id":"启用-tailwind-css","depth":3,"charIndex":64},{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":177},{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":273},{"text":"注意事项","id":"注意事项","depth":3,"charIndex":352},{"text":"关于 source.designSystem","id":"关于-sourcedesignsystem","depth":3,"charIndex":659}],"domain":"","frontmatter":{"sidebar_label":"tailwindcss"},"version":""},{"id":508,"title":"tools.terser","content":"#\n\n * 类型： Object | Function | undefined\n * 默认值：\n\n\n\n * 打包工具： 仅支持 webpack\n\n在生产环境构建时，Builder 会通过 terser-webpack-plugin 对 JavaScript 代码进行压缩优化。可以通过\ntools.terser 修改 terser-webpack-plugin 的配置。\n\n\nObject 类型#\n\n当 tools.terser 的值为 Object 类型时，会与默认配置通过 Object.assign 合并。\n\n例如通过 exclude 排除部分文件的压缩：\n\n\n\n\nFunction 类型#\n\n当 tools.terser 配置为 Function 类型时，默认配置作为第一个参数传入，可以直接修改配置对象，也可以返回一个值作为最终结果。\n\n\n\n禁用代码压缩\n\n如果你需要禁用代码压缩，可以使用 output.disableMinimize 配置项。","routePath":"/configure/app/tools/terser","lang":"zh","toc":[{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":187},{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":285}],"domain":"","frontmatter":{"sidebar_label":"terser"},"version":""},{"id":509,"title":"tools.tsChecker","content":"#\n\n * 类型： Object | Function\n * 默认值：\n\n\n\n默认情况下，Builder 会开启 fork-ts-checker-webpack-plugin 进行类型检查。你可以通过\noutput.disableTsChecker 配置项来关闭类型检查。\n\n\nObject 类型#\n\n当 tsChecker 的值为 Object 类型时，会与默认配置进行深层合并。\n\n\n\n\nFunction 类型#\n\n当 tsChecker 的值为 Function 类型时，默认配置会作为第一个参数传入，你可以直接修改配置对象，也可以返回一个对象作为最终配置。\n\n","routePath":"/configure/app/tools/ts-checker","lang":"zh","toc":[{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":138},{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":195}],"domain":"","frontmatter":{"sidebar_label":"tsChecker"},"version":""},{"id":510,"title":"tools.tsLoader","content":"#\n\n * 类型： Object | Function | undefined\n * 默认值： undefined\n * 打包工具： 仅支持 webpack\n\n不再推荐使用 ts-loader\n\n使用 babel-loader 或 Rspack 转译 TypeScript 代码的性能明显优于 ts-loader 且能够使用更多拓展能力。\n\n启用 ts-loader 时将无法使用 source.transformImport 和 tools.styledComponents 等由 Babel 和\nSWC 提供支持的能力。\n\n项目中默认不开启 ts-loader，当 tools.tsLoader 不为 undefined 则表示开启 ts-loader，同时禁用\nbabel-loader 对 TypeScript 的编译。\n\n\nObject 类型#\n\n当此值为 Object 类型时，与默认配置通过 Object.assign 合并。\n\n默认配置如下:\n\n\n\n你可以通过 tools.tsLoader 配置项来覆盖默认配置:\n\n\n\n\nFunction 类型#\n\n当此值为 Function 类型时，默认配置作为第一参数传入，可以直接修改配置对象，也可以返回一个对象作为最终配置；第二个参数为修改 ts-loader\n配置工具函数集合：\n\n\n\n\n工具函数#\n\naddIncludes#\n\n已废弃，请使用 source.include 代替，两者功能完全一致。\n\naddExcludes#\n\n已废弃，请使用 source.exclude 代替，两者功能完全一致。","routePath":"/configure/app/tools/ts-loader","lang":"zh","toc":[{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":366},{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":469},{"text":"工具函数","id":"工具函数","depth":3,"charIndex":574},{"text":"addIncludes","id":"addincludes","depth":4,"charIndex":581},{"text":"addExcludes","id":"addexcludes","depth":4,"charIndex":632}],"domain":"","frontmatter":{"sidebar_label":"tsLoader"},"version":""},{"id":511,"title":"tools.webpackChain","content":"#\n\n * 类型： Function | undefined\n * 默认值： undefined\n * 打包工具： 仅支持 webpack\n\n你可以通过 tools.webpackChain 来修改默认的 webpack 配置，它的值为 Function 类型，接收两个参数：\n\n * 第一个参数为 webpack-chain 对象实例，你可以通过这个实例来修改默认的 webpack 配置。\n * 第二个参数为一个工具集合，包括env、isProd、CHAIN_ID 等。\n\n相比于 tools.webpack，webpack-chain 不仅支持链式调用，而且能够基于别名来定位到内置的 Rule 或\nPlugin，从而实现精准的配置修改。我们推荐使用 tools.webpackChain 来代替 tools.webpack。\n\n> tools.webpackChain 的执行时机早于 tools.webpack，因此会被 tools.webpack 中的修改所覆盖。\n\n\n工具集合#\n\nenv#\n\n * 类型： 'development' | 'production' | 'test'\n\n通过 env 参数可以判断当前环境为 development、production 还是 test。比如：\n\n\n\nisProd#\n\n * 类型： boolean\n\n通过 isProd 参数可以判断当前环境是否为 production。比如：\n\n\n\ntarget#\n\n * 类型： 'web' | 'node' | 'modern-web' | 'web-worker'\n\n通过 target 参数可以判断当前构建的目标运行时环境。比如：\n\n\n\nisServer#\n\n * 类型： boolean\n\n判断当前构建的目标运行时环境是否为 node，等价于 target === 'node'。\n\n\n\nisWebWorker#\n\n * 类型： boolean\n\n判断当前构建的目标运行时环境是否为 web-worker，等价于 target === 'web-worker'。\n\n\n\nwebpack#\n\n * 类型： typeof import('webpack')\n\n通过这个参数你可以拿到 webpack 实例。比如：\n\n\n\nHtmlWebpackPlugin#\n\n * 类型： typeof import('html-webpack-plugin')\n\n通过这个参数你可以拿到 HtmlWebpackPlugin 实例。\n\n\n\nCHAIN_ID#\n\nBuilder 中预先定义了一些常用的 Chain ID，你可以通过这些 ID 来定位到内置的 Rule 或 Plugin。\n\nTIP\n\n请留意，下列的一部分 Rule 或 Plugin 并不是默认存在的，当你开启特定配置项、或是注册某些插件后，它们才会被包含在 webpack 配置中。\n\n比如，RULE.STYLUS 仅在注册了 Stylus 插件后才会存在。\n\nCHAIN_ID.RULE#\n\nID            描述\nRULE.MJS      处理 mjs 的规则\nRULE.JS       处理 js 的规则\nRULE.TS       处理 ts 的规则\nRULE.CSS      处理 css 的规则\nRULE.LESS     处理 less 的规则\nRULE.SASS     处理 sass 的规则\nRULE.STYLUS   处理 stylus 的规则（依赖 Stylus 插件）\nRULE.SVG      Rule for svg\nRULE.PUG      处理 pug 的规则\nRULE.TOML     处理 toml 的规则\nRULE.YAML     处理 yaml 的规则\nRULE.WASM     处理 wasm 的规则\nRULE.NODE     处理 node 的规则\nRULE.FONT     处理字体的规则\nRULE.IMAGE    处理图片的规则\nRULE.MEDIA    处理媒体资源的规则\n\nCHAIN_ID.ONE_OF#\n\n通过 ONE_OF.XXX 可以匹配到规则数组中的某一类规则。\n\nID                  描述\nONE_OF.SVG          处理 SVG 的规则，在 data URI 和单独文件之间自动选择\nONE_OF.SVG_URL      处理 SVG 的规则，输出为单独文件\nONE_OF.SVG_INLINE   处理 SVG 的规则，作为 data URI 内联到 bundle 中\nONE_OF.SVG_ASSETS   处理 SVG 的规则，在 data URI 和单独文件之间自动选择\n\nCHAIN_ID.USE#\n\n通过 USE.XXX 可以匹配到对应的 loader。\n\nID                                描述\nUSE.TS                            对应 ts-loader\nUSE.CSS                           对应 css-loader\nUSE.LESS                          对应 less-loader\nUSE.SASS                          对应 sass-loader\nUSE.STYLUS                        对应 stylus-loader\nUSE.PUG                           对应 pug-loader\nUSE.VUE                           对应 vue-loader\nUSE.TOML                          对应 toml-loader\nUSE.YAML                          对应 yaml-loader\nUSE.NODE                          对应 node-loader\nUSE.URL                           对应 url-loader\nUSE.SVGR                          对应 @svgr/webpack\nUSE.BABEL                         对应 babel-loader\nUSE.STYLE                         对应 style-loader\nUSE.POSTCSS                       对应 postcss-loader\nUSE.CSS_MODULES_TS                对应 css-modules-typescript-loader\nUSE.MINI_CSS_EXTRACT              对应 mini-css-extract-plugin.loader\nUSE.RESOLVE_URL_LOADER_FOR_SASS   对应 resolve-url-loader\n\nCHAIN_ID.PLUGIN#\n\n通过 PLUGIN.XXX 可以匹配到对应的 plugin。\n\nID                             描述\nPLUGIN.HMR                     对应 HotModuleReplacementPlugin\nPLUGIN.COPY                    对应 CopyWebpackPlugin\nPLUGIN.HTML                    对应 HtmlWebpackPlugin，使用时需要拼接 entry\n                               名称：${PLUGIN.HTML}-${entryName}\nPLUGIN.DEFINE                  对应 DefinePlugin\nPLUGIN.IGNORE                  对应 IgnorePlugin\nPLUGIN.BANNER                  对应 BannerPlugin\nPLUGIN.PROGRESS                对应 Webpackbar\nPLUGIN.APP_ICON                对应 AppIconPlugin\nPLUGIN.MANIFEST                对应 WebpackManifestPlugin\nPLUGIN.TS_CHECKER              对应 ForkTsCheckerWebpackPlugin\nPLUGIN.INLINE_HTML             对应 InlineChunkHtmlPlugin\nPLUGIN.BUNDLE_ANALYZER         对应 WebpackBundleAnalyzer\nPLUGIN.MINI_CSS_EXTRACT        对应 MiniCssExtractPlugin\nPLUGIN.VUE_LOADER_PLUGIN       对应 VueLoaderPlugin\nPLUGIN.REACT_FAST_REFRESH      对应 ReactFastRefreshPlugin\nPLUGIN.NODE_POLYFILL_PROVIDE   对应处理 node polyfill 的 ProvidePlugin\nPLUGIN.SUBRESOURCE_INTEGRITY   对应 webpack-subresource-integrity\nPLUGIN.ASSETS_RETRY            对应 Builder 中的 webpack 静态资源重试插件 WebpackAssetsRetryPlugin\nPLUGIN.AUTO_SET_ROOT_SIZE      对应 Builder 中的自动设置根字体大小插件 AutoSetRootSizePlugin\n\nCHAIN_ID.MINIMIZER#\n\n通过 MINIMIZER.XXX 可以匹配到对应的压缩工具。\n\nID                  描述\nMINIMIZER.JS        对应 TerserWebpackPlugin\nMINIMIZER.CSS       对应 CssMinimizerWebpackPlugin\nMINIMIZER.ESBUILD   对应 ESBuildPlugin\nMINIMIZER.SWC       对应 SwcWebpackPlugin\n\n\n使用示例#\n\n使用示例可参考：WebpackChain 使用示例。","routePath":"/configure/app/tools/webpack-chain","lang":"zh","toc":[{"text":"工具集合","id":"工具集合","depth":3,"charIndex":440},{"text":"env","id":"env","depth":4,"charIndex":447},{"text":"isProd","id":"isprod","depth":4,"charIndex":556},{"text":"target","id":"target","depth":4,"charIndex":623},{"text":"isServer","id":"isserver","depth":4,"charIndex":721},{"text":"isWebWorker","id":"iswebworker","depth":4,"charIndex":797},{"text":"webpack","id":"webpack","depth":4,"charIndex":888},{"text":"HtmlWebpackPlugin","id":"htmlwebpackplugin","depth":4,"charIndex":961},{"text":"CHAIN_ID","id":"chain_id","depth":4,"charIndex":1063},{"text":"CHAIN_ID.RULE","id":"chain_idrule","depth":4,"charIndex":1258},{"text":"CHAIN_ID.ONE_OF","id":"chain_idone_of","depth":4,"charIndex":1708},{"text":"CHAIN_ID.USE","id":"chain_iduse","depth":4,"charIndex":1986},{"text":"CHAIN_ID.PLUGIN","id":"chain_idplugin","depth":4,"charIndex":2997},{"text":"CHAIN_ID.MINIMIZER","id":"chain_idminimizer","depth":4,"charIndex":4243},{"text":"使用示例","id":"使用示例","depth":3,"charIndex":4490}],"domain":"","frontmatter":{"sidebar_label":"webpackChain"},"version":""},{"id":512,"title":"tools.webpack","content":"#\n\n * 类型： Object | Function | undefined\n * 默认值： undefined\n * 打包工具： 仅支持 webpack\n\ntools.webpack 选项用于配置原生的 webpack。\n\n> tools.bundlerChain 同样可以修改 webpack 配置，并且功能更加强大，建议优先使用 tools.bundlerChain。\n\n\nObject 类型#\n\ntools.webpack 可以配置为一个对象，这个对象将会和内置的 webpack 配置通过 webpack-merge 进行深层合并。\n\n比如添加 resolve.alias 配置：\n\n\n\n\nFunction 类型#\n\ntools.webpack 也可以配置为一个函数，这个函数的第一个入参为内置的 webpack 配置对象，你可以对这个对象进行修改，然后返回一份新的配置。比如：\n\n\n\nTIP\n\ntools.webpack 函数返回的对象会直接作为最终使用的 webpack 配置，不会再与内置的 webpack 配置进行合并。\n\n\n工具集合#\n\n这个函数的第二个参数是一个对象，包含了一些工具函数和属性，详情如下：\n\nenv#\n\n * 类型： 'development' | 'production' | 'test'\n\n通过 env 参数可以判断当前环境为 development、production 还是 test。比如：\n\n\n\nisProd#\n\n * 类型： boolean\n\n通过 isProd 参数可以判断当前环境是否为 production。比如：\n\n\n\ntarget#\n\n * 类型： 'web' | 'node' | 'modern-web' | 'web-worker'\n\n通过 target 参数可以判断当前构建的目标运行时环境。比如：\n\n\n\nisServer#\n\n * 类型： boolean\n\n判断当前构建的目标运行时环境是否为 node，等价于 target === 'node'。\n\n\n\nisWebWorker#\n\n * 类型： boolean\n\n判断当前构建的目标运行时环境是否为 web-worker，等价于 target === 'web-worker'。\n\n\n\nwebpack#\n\n * 类型： typeof import('webpack')\n\n通过这个参数你可以拿到 webpack 实例。比如：\n\n\n\nHtmlWebpackPlugin#\n\n * 类型： typeof import('html-webpack-plugin')\n\n通过这个参数你可以拿到 HtmlWebpackPlugin 实例。\n\n\n\naddRules#\n\n * 类型： (rules: RuleSetRule | RuleSetRule[]) => void\n\n添加额外的 webpack rules。\n\n示例：\n\n\n\nprependPlugins#\n\n * 类型： (plugins: WebpackPluginInstance | WebpackPluginInstance[]) => void\n\n在内部 webpack 插件数组头部添加额外的插件，数组头部的插件会优先执行。\n\n\n\nappendPlugins#\n\n * 类型： (plugins: WebpackPluginInstance | WebpackPluginInstance[]) => void\n\n在内部 webpack 插件数组尾部添加额外的插件，数组尾部的插件会在最后执行。\n\n\n\nremovePlugin#\n\n * 类型： (name: string) => void\n\n删除内部的 webpack 插件，参数为该插件的 constructor.name。\n\n例如，删除内部的 fork-ts-checker-webpack-plugin：\n\n\n\nmergeConfig#\n\n * 类型： (...configs: WebpackConfig[]) => WebpackConfig\n\n用于合并多份 webpack 配置，等价于 webpack-merge。\n\n","routePath":"/configure/app/tools/webpack","lang":"zh","toc":[{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":190},{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":300},{"text":"工具集合","id":"工具集合","depth":3,"charIndex":472},{"text":"env","id":"env","depth":4,"charIndex":515},{"text":"isProd","id":"isprod","depth":4,"charIndex":624},{"text":"target","id":"target","depth":4,"charIndex":691},{"text":"isServer","id":"isserver","depth":4,"charIndex":789},{"text":"isWebWorker","id":"iswebworker","depth":4,"charIndex":865},{"text":"webpack","id":"webpack","depth":4,"charIndex":956},{"text":"HtmlWebpackPlugin","id":"htmlwebpackplugin","depth":4,"charIndex":1029},{"text":"addRules","id":"addrules","depth":4,"charIndex":1131},{"text":"prependPlugins","id":"prependplugins","depth":4,"charIndex":1224},{"text":"appendPlugins","id":"appendplugins","depth":4,"charIndex":1359},{"text":"removePlugin","id":"removeplugin","depth":4,"charIndex":1494},{"text":"mergeConfig","id":"mergeconfig","depth":4,"charIndex":1628}],"domain":"","frontmatter":{"sidebar_label":"webpack"},"version":""},{"id":513,"title":"配置使用","content":"#\n\nModern.js 中有两种配置，分别是编译时配置和服务端运行时配置。\n\n编译时配置可以在两个位置进行配置：\n\n * 根路径下的 modern.config.(ts|js|mjs) 文件\n * package.json 文件\n\nINFO\n\nModern.js 不支持同时在 package.json 中和 modern.config.ts 中配置同一个配置项，推荐在 modern.config.ts\n中进行配置。如果 Modern.js 检测到重复配置导致的冲突，将会抛出警告。\n\n服务端运行时配置可以在根路径下的 modern.server-runtime.config.(ts|js|mjs) 中进行配置。\n\n\n在配置文件中配置#\n\nModern.js 的配置文件定义在项目的根目录下，支持 .ts, .js 和 .mjs 格式：\n\n * modern.config.ts\n * modern.config.js\n * modern.config.mjs\n\n\nmodern.config.ts（推荐）#\n\n我们推荐使用 .ts 格式的配置文件，它提供了友好的 TypeScript 类型提示，从而帮助你避免配置中的错误。\n\n从 @modern-js/app-tools 中导入 defineConfig 工具函数, 它会帮助你进行配置的类型推导和类型补全：\n\n\n\n当你使用 Rspack 作为打包工具时，由于 webpack 和 Rspack 的配置类型存在一些差异，需要为 defineConfig 指定\n<'rspack'> 泛型：\n\n\n\n\nmodern.config.js#\n\n如果你在开发一个非 TypeScript 项目，可以使用 .js 格式的配置文件：\n\n\n\n你也可以通过 process.env.NODE_ENV，根据环境做不同配置：\n\n\n\n\n导出配置函数#\n\nModern.js 支持在配置文件中导出一个函数，你可以在函数中动态计算配置，并返回给 Modern.js。\n\n\n\n该函数接受以下入参：\n\n * env：对应 process.env.NODE_ENV 的值。\n   * 当运行 modern dev 或 modern start 时，env 的值为 development。\n   * 当运行 modern build 或 modern serve 时，env 的值为 production。\n * command：对应当前运行的命令，如 dev、start、build、serve。\n\n\n导出异步函数#\n\nModern.js 也支持在配置文件中导出一个异步函数，你可以在函数中进行一些异步操作：\n\n\n\n\n指定配置文件#\n\nModern.js 命令行支持通过 --config 选项来指定配置文件的名称。\n\n例如，你需要在执行 build 命令时使用 modern.prod.config.ts 文件，可以在 package.json 中添加如下配置：\n\n\n\n你也可以将 --config 选项缩写为 -c：\n\n\n\n\n在 package.json 中配置（不推荐）#\n\n除了配置文件外，你也可以在 package.json 中的 modernConfig 字段下设置配置项，如：\n\n\n\n由于 JSON 文件格式的限制，package.json 中只能定义数字、字符串、布尔值、数组等简单类型的值，当我们需要设置函数类型的值时，建议在\nModern.js 配置文件中进行设置。\n\n\n注意事项#\n\n * 不建议同时使用 package.json 和 modern.config.js 进行配置。如果同时使用了两者并出现配置冲突，Modern.js\n   会在命令行进行提示错误。\n * @modern-js/runtime 导出了同名的 defineConfig API，请注意区分。\n\n\n本地调试配置#\n\n为了便于本地调试配置，Modern.js 支持在项目根目录下创建 modern.config.local.(ts|js|mjs) 文件，用于覆盖\nmodern.config.(ts|js|mjs) 中的配置选项。\n\n\n示例#\n\n比如，项目的 modern.config.ts 中配置了端口号为 3000:\n\n\n\n如果你在本地调试时需要将端口号修改为 3001，但是又不希望修改当前项目的 modern.config.ts 文件，那么可以创建一个\nmodern.config.local.ts 文件，并添加以下配置：\n\n\n\nmodern.config.local.ts 文件中的配置会与 modern.config.ts 中的配置进行深层合并，并覆盖 modern.config.ts\n中的配置选项，因此 server.port 会被覆盖为 3001。\n\n\n注意事项#\n\n在使用 modern.config.local.ts 时，请注意以下事项：\n\n * modern.config.local.ts 文件仅会在执行 modern dev 或 modern start 命令时被加载，当执行 modern\n   build 时不会被加载。\n * modern.config.local.ts 文件的优先级不仅高于 modern.config.ts，也高于 package.json 中的\n   modernConfig 字段。\n * 由于 modern.config.local.ts 仅在本地调试时使用，因此不建议将其提交到代码仓库中，请确保项目的 .gitignore 文件中包含\n   modern.config.local.ts 等文件。\n\n\n\n\n合并多份配置#\n\n在某些情况下，你可能需要将多份配置合并为一份配置，此时你可以使用 mergeConfig 工具函数来合并多个配置。\n\nmergeConfig 函数接受一个数组作为参数，数组中的每一项都是一个配置对象，mergeConfig\n会将数组中的每一项配置对象进行深层合并，自动将多个函数项合并为数组，最终返回一个合并后的配置对象。\n\n\n示例#\n\n\n\n在以上示例中，合并后的配置对象为：\n\n\n\n\n配置类型定义#\n\nModern.js 导出了 AppUserConfig 类型，对应 Modern.js 配置对象的类型：\n\n\n\n当你使用 Rspack 作为打包工具时，由于 webpack 和 Rspack 的配置类型存在一些差异，需要为 AppUserConfig 指定\n<'rspack'> 泛型：\n\n","routePath":"/configure/app/usage","lang":"zh","toc":[{"text":"在配置文件中配置","id":"在配置文件中配置","depth":2,"charIndex":311},{"text":"modern.config.ts（推荐）","id":"modernconfigts推荐","depth":3,"charIndex":435},{"text":"modern.config.js","id":"modernconfigjs","depth":3,"charIndex":678},{"text":"导出配置函数","id":"导出配置函数","depth":3,"charIndex":785},{"text":"导出异步函数","id":"导出异步函数","depth":3,"charIndex":1064},{"text":"指定配置文件","id":"指定配置文件","depth":3,"charIndex":1122},{"text":"在 package.json 中配置（不推荐）","id":"在-packagejson-中配置不推荐","depth":2,"charIndex":1278},{"text":"注意事项","id":"注意事项","depth":3,"charIndex":1459},{"text":"本地调试配置","id":"本地调试配置","depth":2,"charIndex":1612},{"text":"示例","id":"示例","depth":3,"charIndex":1730},{"text":"注意事项","id":"注意事项-1","depth":3,"charIndex":1999},{"text":"合并多份配置","id":"合并多份配置","depth":2,"charIndex":2348},{"text":"示例","id":"示例-1","depth":3,"charIndex":2521},{"text":"配置类型定义","id":"配置类型定义","depth":2,"charIndex":2550}],"domain":"","frontmatter":{"sidebar_position":0},"version":""},{"id":514,"title":"运行时框架","content":"#\n\nModern.js 的 BFF 支持不同的运行时框架，当前 Modern.js 的 BFF 支持两种运行时框架 Express.js 和 Koa.js。\n\n\n函数写法#\n\n在函数写法下，各类运行时框架仅中间件写法存在差异，其他实现基本相同。这里以 Express 为例，介绍如何在 api/_app.ts\n中，手写一个中间件，添加权限校验：\n\n\n\n然后添加一个普通的 BFF 函数 /api/hello.ts：\n\n\n\n最后在前端 src/App.tsx 添加接口的访问代码，直接使用一体化的方式调用：\n\n\n\n然后 pnpm run dev 启动项目，访问 http://localhost:8080/ 会发现 /api/hello 的请求被拦截了：\n\n\n\n最后再修改前端代码 src/App.tsx，在访问 /api/hello 前先调用登录接口：\n\n\n\n刷新页面，可以看到 /api/hello 访问成功：\n\n\n\n以上代码模拟了在 /api/_app.ts 中添加中间件的方式，实现了简易的登录功能。同样，可以在这个钩子文件中实现其他功能来扩展 BFF Server。\n\n\n框架写法#\n\n框架写法下，Modern.js 不会收集 api/_app.ts 中的中间件，运行流程由插件自行控制。\n\n\nExpress#\n\nExpress 的框架写法支持可在 api/app.[tj]s 定义 API Server\n的启动逻辑，执行应用的初始化工作，添加全局中间件，声明路由，甚至扩展原有框架等。\n\nBFF 函数定义的路由会在 app.ts 文件定义的路由之后注册，所以在这里你也可以拦截 BFF 函数定义的路由，进行预处理或是提前响应。\n\n\n\n\nKoa#\n\nKoa 框架写法与 Express 类似，支持在 app.[tj]s 定义 API Server\n的启动逻辑，执行应用的初始化工作，添加全局中间件，声明路由，扩展原有框架等。\n\nBFF 函数定义的路由会在 app.ts 文件定义的路由之后注册，所以在这里你也可以拦截 BFF 函数定义的路由，进行预处理或是提前响应。\n\n注意\n\n在框架写法下，当没有 app.ts 的时候，Modern.js 默认会添加 koa-body；当有 app.ts 时，如果开发者希望使用带有 Body 的\nBFF 函数，需要确保 koa-body 中间件已经添加。\n\n","routePath":"/guides/advanced-features/bff/frameworks","lang":"zh","toc":[{"text":"函数写法","id":"函数写法","depth":2,"charIndex":81},{"text":"框架写法","id":"框架写法","depth":2,"charIndex":490},{"text":"Express","id":"express","depth":3,"charIndex":551},{"text":"Koa","id":"koa","depth":3,"charIndex":723}],"domain":"","frontmatter":{"sidebar_position":3,"title":"运行时框架"},"version":""},{"id":515,"title":"基础用法","content":"#\n\n通过 Modern.js 开发的应用，可以在 api/\n目录下定义接口函数，前端可以调用这些接口函数，即可发起请求，无需写前后端胶水层代码，同时保证前后端类型安全。\n\n\n启用 BFF#\n\n 1. 执行 pnpm new，选择启用 BFF\n\n 2. 根据选择的运行时框架，将下面的代码添加到 modern.config.[tj]s 中：\n\n\nBFF 函数#\n\n允许通过一体化调用的函数，称为 BFF 函数。这里写一个最简单的 BFF 函数，创建 api/hello.ts 文件：\n\nCAUTION\n\n如果是框架模式（有 api/lambda 目录），需要创建 api/lambda/hello.ts\n\n\n\n接着在 src/App.tsx 中直接引入函数并调用：\n\n\n\nINFO\n\nModern.js 生成器已经在 tsconfig.json 中配置 @api 别名，因此可以直接通过别名的方式引入函数。\n\n在 src/App.tsx 中引入的函数，会自动转换成接口调用，不需要再去通过 fetch 去调用接口。\n\n执行 pnpm run dev 打开 http://localhost:8080/ 可以看到页面已经展示了 BFF 函数返回的内容，在 Network\n中可以看到页面向 http://localhost:8080/api/hello 发送了请求：\n\n\n\n\n函数路由#\n\nModern.js 中，BFF 函数对应的路由系统是基于文件系统实现的，也是一种约定式路由。\n\n函数写法下 api/ 下的所有文件中的每个 BFF 函数都会映射为一个接口。框架写法下 api/lambda 下的所有文件中的每个 BFF\n函数都会映射为一个接口。\n\nNOTE\n\n函数写法和框架写法会在下一节详细介绍。\n\n所有 BFF 函数生成的路由都带有统一的前缀，默认值为 /api。可以通过 bff.prefix 设置公共路由的前缀。\n\n下面介绍几种路由的约定。\n\n\n默认路由#\n\n以 index.[jt]s 命名的文件会被映射到上一层目录。\n\n * api/index.ts -> {prefix}/\n * api/user/index.ts -> {prefix}/user\n\n\n多层路由#\n\n支持解析嵌套的文件，如果创建嵌套文件夹结构，文件仍会以相同方式自动解析路由。\n\n * api/hello.ts -> {prefix}/hello\n * api/user/list.ts -> {prefix}/user/list\n\n\n动态路由#\n\n同样的，创建命名带有 [xxx] 的文件夹或者文件，支持动态的命名路由参数。动态路由的函数参数规则可以看 dynamac-path\n\n * api/user/[username]/info.ts -> {prefix}/user/:username/info\n * api/user/username/[action].ts -> {prefix}/user/username/:action\n\n\n白名单#\n\n默认 api/ 目录下所有文件都会当作 BFF 函数文件去解析，但以下文件不会被解析：\n\n * 命名以 _ 开头的文件。例如：_utils.ts。\n * 命名以 _ 开头的文件夹下所有文件。例如：_utils/index.ts、_utils/cp.ts。\n * 测试文件。例如：foo.test.ts。\n * TypeScript 类型文件。例如：hello.d.ts。\n * node_module 下的文件。\n\n\nRESTful API#\n\nModern.js 的 BFF 函数需要遵循 RESTful API 标准来定义, 遵循 HTTP Method 规范，并且不允许自由定义参数。\n\nINFO\n\n假设函数允许自由定义参数，产出的路由必然由私有协议进行调用（原因是无法区分请求参数与请求体），而无法实现任意的 RESTful API。\n\n如果服务仅用于应用本身不存在问题，但它不标准的接口定义无法融入更大的体系。 在多个系统共同工作的情况下（例如 BFF\n低码搭建），会导致其他系统也需要遵循私有协议。\n\n\n函数具名导出#\n\nModern.js BFF 函数的导出名决定了函数对应接口的 Method，如 get，post 等。\n\n例如，按照以下例子，可导出一个 GET 接口。\n\n\n\n按照以下例子，则可导出一个 POST 接口\n\n\n\n * 对应 HTTP Method，Modern.js 也支持了 9\n   种定义，即：GET、POST、PUT、DELETE、CONNECT、TRACE、PATCH、OPTIONS、HEAD，即可以用这些 Method\n   作为函数导出的名字。\n\n * 名字是大小不敏感的，如果是 GET，写成 get、Get、GEt、GET，都可以准确识别。而默认导出，即 export default xxx\n   则会被映射为 Get。\n\n * 可以在一个文件中定义多个不同 Method 的函数，但如果定义多个相同 Method 的函数，则只有第一个会生效。\n\nINFO\n\n需要注意的是，定义的函数都应该是异步的，与函数调用时类型有关，后面会提到。\n\n\n函数参数规则#\n\n如上所述，为了满足 RESTful API 的设计标准，因此 Modern.js 中 BFF 函数需要遵循一定的入参规则。\n\n函数参数分为两块，分别是请求路径中的动态部分和请求选项 RequestOption。\n\nDynamic Path#\n\n动态路由会作为函数第一部分的入参，每个入参对应一段动态路由。例如以下示例，uid 会作为前两个参数传递到函数中：\n\n\n\n在调用时直接传入动态参数：\n\n\n\nRequestOption#\n\nDynamic Path 之后的参数是包含 querystring、request body 的对象 RequestOption，这个字段用来定义 data 和\nquery 的类型。\n\n在不存在动态路由的普通函数中，可以从第一个入参中获取传入的 data 和 query，例如：\n\n\n\n这里你也可以使用自定义类型：\n\n\n\n当函数文件使用动态路由规则时，动态路由会在 RequestOption 对象参数前。\n\n\n\n调用时也按照函数定义，传入对应的参数即可：\n\n\n\n之前提到，定义的函数都应该是异步的，是因为在前端调用时会自动转换成 HTTP 接口调用，所以为了保持类型定义与实际调用体验统一，需要在定义 BFF\n函数时将它设置为异步。","routePath":"/guides/advanced-features/bff/function","lang":"zh","toc":[{"text":"启用 BFF","id":"启用-bff","depth":2,"charIndex":87},{"text":"BFF 函数","id":"bff-函数","depth":2,"charIndex":172},{"text":"函数路由","id":"函数路由","depth":2,"charIndex":586},{"text":"默认路由","id":"默认路由","depth":3,"charIndex":828},{"text":"多层路由","id":"多层路由","depth":3,"charIndex":936},{"text":"动态路由","id":"动态路由","depth":3,"charIndex":1061},{"text":"白名单","id":"白名单","depth":3,"charIndex":1267},{"text":"RESTful API","id":"restful-api","depth":2,"charIndex":1482},{"text":"函数具名导出","id":"函数具名导出","depth":3,"charIndex":1731},{"text":"函数参数规则","id":"函数参数规则","depth":3,"charIndex":2170},{"text":"Dynamic Path","id":"dynamic-path","depth":4,"charIndex":2286},{"text":"RequestOption","id":"requestoption","depth":4,"charIndex":2378}],"domain":"","frontmatter":{"sidebar_position":1,"title":"基础用法"},"version":""},{"id":516,"title":"BFF","content":"#\n\nBFF（Backends for Frontends）是一种架构模式，主要用于解决前后端协作中的数据聚合问题。在 BFF\n架构下，前端应用程序不直接与后端服务通信，而是通过一个专门为前端定制的BFF中间层与后端服务交互。\n\n它的适用场景包括：\n\n * 根据自身业务需求，对更底层 API 的聚合、映射、裁剪、代理。\n * 对一些特定场景的数据进行缓存，提高性能，进而提升用户体验。\n * 根据已有接口快速开发新产品。\n * 与第三方系统对接，例如登陆鉴权。\n\nModern.js 官方支持了 BFF，并提供了一体化 BFF 方案来进一步强化 BFF 能力，主要包括以下能力：\n\n * 快速开发调试上线，在同一项目中运行、构建、部署 BFF 代码。\n * 极简的纯函数调用，在前端直接 import BFF 函数，调用时能自动转换成 HTTP 请求。\n * 无私有协议，遵循 RESTful API 规范，所有 BFF 接口都是标准化的。\n * 完善的 TypeScript 支持。\n * 满足用户使用偏好，支持多框架扩展写法。","routePath":"/guides/advanced-features/bff/","lang":"zh","toc":[],"domain":"","frontmatter":{"title":"BFF"},"version":""},{"id":517,"title":"自定义请求 SDK","content":"#\n\nModern.js 的 BFF 在 CSR 和 SSR 是同构的。在浏览器端依赖了Fetch API，在服务端依赖了\nnode-fetch。但在很多业务场景下我们需要对请求或响应做一些额外的处理，例如：\n\n * 在请求头中写入鉴权信息\n * 对响应的数据或错误进行统一的处理\n * 特定平台无法使用浏览器的原生 fetch 函数，需要使用其他方式发送请求\n\n针对上述的场景，Modern.js 提供了 configure 函数，自定义能力从低到高，可以用它配置 ssr 透传请求头，拦截器，请求 SDK。\n\n注意\n\nconfigure 函数的调用需要在所有 BFF 请求发送前调用，以确保覆盖默认的请求配置。\n\n\n\n\n配置 ssr 透传请求头#\n\n在同时使用 Modernjs SSR 和 BFF 的场景下，常常需要将 SSR 页面请求上的一些请求头信息，透传给 BFF 服务。\n\n例如项目有页面地址是 https://website.com，该页面是 SSR 的，在组件中会调用 API 接口\nhttps://website.com/api/info，该接口需要用户的 cookie 信息做鉴权。页面在请求该 API 接口时，需要将 SSR 页面请求的\ncookie 传给 BFF。\n\n目前以下请求头在 Modernjs 中是自动透传的：\n\n * cookie\n * x-tt-logid\n * user-agent\n * x-tt-stress\n\n可以通过 configure 配置请求头。例如以下例子，Modern.js 会自动将 SSR 页面请求的 cookie 信息透传给 BFF 服务：\n\n\n\n\n配置拦截器#\n\n在有些业务场景下需要对请求和响应进行一些统一的处理，这种场景下可以配置拦截器满足需求：\n\n\n\n\n配置自定义请求 SDK#\n\n如果仅仅通过配置拦截器无法满足需求，需要对请求的 SDK 做进一步的自定义，可以通过 configure 函数配置自定义请求 SDK：\n\n注意\n\n在 SSR 和一体化调用的场景下，在 SSR 向 BFF 服务发送请求时，Modern.js 会通过服务发现找到 BFF 服务内网 IP，并通过 IP\n发送请求，以提高性能。如果使用自定义请求 SDK 会失去这种优化。\n\n\n\n配置自定义请求 SDK 有以下约定：\n\n * 通过 configure 函数可以配置一个 request 函数，这个函数的入参与浏览器中的 Fetch 或 node-fetch 对齐，所有的一体化\n   BFF 函数会通过该函数发送请求。\n * request 函数出参必须是接口实际返回的数据，不能是 Promise，否则会导致一体化 BFF 函数无法正常返回数据。\n * 如果是 SSR 项目，request 必须要同时支持浏览器端和服务器端发送请求。\n\n使用 axios 定制自定义请求 SDK 的示例：\n\n","routePath":"/guides/advanced-features/bff/sdk","lang":"zh","toc":[{"text":"配置 ssr 透传请求头","id":"配置-ssr-透传请求头","depth":2,"charIndex":311},{"text":"配置拦截器","id":"配置拦截器","depth":2,"charIndex":706},{"text":"配置自定义请求 SDK","id":"配置自定义请求-sdk","depth":2,"charIndex":762}],"domain":"","frontmatter":{"sidebar_position":4,"title":"自定义请求 SDK"},"version":""},{"id":518,"title":"函数写法 & 框架写法","content":"#\n\n运行时框架支持也是 BFF 中重要的一环。Modern.js 支持通过插件扩展 BFF\n的运行时框架，并提供了一系列内置插件，开发者可以直接使用对应框架的约定和生态。\n\n插件中兼容了这些框架大部分的规范，每一种框架都需要提供两类扩展写法 BFF 函数的方式，分别是函数写法和框架写法。\n\nNOTE\n\n当前 api/ 目录结构是否为框架写法由对应的插件决定，Modern.js 并不关心。\n\n\n函数写法#\n\n当插件认为当前为函数写法时，必须支持在 api/_app.ts 中编写中间件，用来扩展 BFF 函数。\n\nModern.js 会收集 api/_app.ts 中的中间件，并传递给插件，由插件将中间件注入运行时，例如：\n\n\n\nNOTE\n\n不同插件的中间件的写法不一定相同，详情可见运行时框架。\n\n\n框架写法#\n\n框架写法是一种使用框架结构来扩展 BFF 函数的方式。和函数写法相比，框架写法虽然能够利用更多框架的结构，在复杂场景下让整个 BFF Server\n更加清晰，但也相的更加复杂，需要关心更多框架层面的内容。\n\n框架写法中，所有的 BFF 函数都需要写在 api/lambda/ 目录下，并且无法使用钩子文件 _app.[tj]s。\n\n多数情况下，函数写法就能覆盖大多数 BFF 函数的定制需求。只有当你的项目服务端逻辑比较复杂，代码需要分层，或者需要使用更多框架的元素时，才需要使用框架写法。\n\nNOTE\n\n不同插件框架写法的目录结构不一定相同，详情可见运行时框架。","routePath":"/guides/advanced-features/bff/type","lang":"zh","toc":[{"text":"函数写法","id":"函数写法","depth":2,"charIndex":198},{"text":"框架写法","id":"框架写法","depth":2,"charIndex":353}],"domain":"","frontmatter":{"sidebar_position":2,"title":"函数写法 & 框架写法"},"version":""},{"id":519,"title":"提升构建性能","content":"#\n\nModern.js 默认对构建性能进行了充分优化，但是随着业务场景变复杂、项目代码量变大，你可能会遇到一些构建性能的问题。\n\n本文档提供了一些可选的提速策略，开发者可以根据实际场景选取其中的部分策略，从而进一步提升构建速度。\n\n📢 注意\n\n在优化产物体积一文中介绍的策略也可以用于提升构建性能，这里不再重复介绍。\n\n\n通用优化策略#\n\n以下是一些通用的优化策略，对开发环境和生产环境均有提速效果，其中部分策略对包体积也有优化。\n\n\n升级 Node.js 版本#\n\n通常来说，将 Node.js 更新到最新的 LTS 版本，有助于提升构建性能。\n\n尤其是对于 Apple M1/M2 芯片的机型，推荐使用 Node 18 进行构建。\n\nNode >= 16 默认提供了 Apple Silicon binaries，因此在 M1/M2 机型上性能会比 Node 14\n有大幅度提升。根据我们的测试，从 Node 14 切换到 Node >= 16 后，编译速度可以提升 100% 以上。\n\n你可以通过以下步骤来切换到 Node 18：\n\n\n\n\n使用 Rspack 构建#\n\n如果你对构建性能有更极致的需求，可以一键切换到 Rspack 构建模式，请参考 使用 Rspack 来进行切换。\n\n\n使用 SWC 或 esbuild 编译#\n\nSWC (Speedy Web Compiler) 是基于 Rust 语言编写的高性能 JavaScript 和 TypeScript 转译和压缩工具。在\nPolyfill 和语法降级方面可以和 Babel 提供一致的能力，并且性能比 Babel 高出一个数量级。\n\nesbuild 是一款基于 Golang 开发的前端构建工具，具有打包、编译和压缩 JavaScript 代码的功能，相比传统的打包编译工具，esbuild\n在性能上有显著提升。\n\nModern.js 提供了 SWC 插件和 esbuild 插件，让你能使用 SWC 或 esbuild 代替 babel-loader、ts-loader 和\nterser 等库进行代码编译和压缩。详见：\n\n * SWC 插件文档\n * esbuild 插件文档\n\nSWC vs esbuild\n\nSWC 编译产物的兼容性较好，支持注入 core-js 等 Polyfill，并且功能更加完备，因此推荐优先使用 SWC 插件。\n\n\n避免使用 ts-loader#\n\n默认情况下，Modern.js 使用 Babel 编译 TS 文件，开启 tools.tsLoader 选项后，会使用 ts-loader 编译 TS 文件。\n\n由于 ts-loader 需要进行额外的语法解析和类型检查，因此会导致项目构建速度变慢，请避免使用。\n\n\n\n详见 tools.tsLoader 文档。\n\n\n开发环境优化策略#\n\n以下是针对开发环境进行提速的策略。\n\n\n调整 Source Map 格式#\n\n为了提供良好的调试体验，Modern.js 在开发环境下默认使用 cheap-module-source-map 格式 Source Map，这是一种高质量的\nSource Map 格式，会带来一定的性能开销。\n\n你可以通过调整开发环境的 Source Map 格式来提升构建速度。\n\n比如禁用 Source Map：\n\n\n\n或是把开发环境的 Source Map 格式设置为开销最小的 eval 格式：\n\n\n\n> 关于不同 Source Map 格式之间的详细差异，请查看 webpack - devtool。\n\n\n调整 Browserslist 范围#\n\n这项优化的原理与「提升 Browserslist 范围」类似，区别在于，我们可以为开发环境和生产环境设置不同的\nbrowserslist，从而减少开发环境下的编译开销。\n\n比如，你可以在 package.json 中添加以下配置，表示在开发环境下只兼容最新的浏览器，在生产环境下兼容实际需要的浏览器：\n\n\n\n注意，这项优化策略会导致开发环境与生产环境的构建产物存在一定差异。\n\n\n生产环境优化策略#\n\n以下是针对生产环境进行提速的策略。\n\n\n禁用 Source Map#\n\n如果项目在生产环境下不需要 Source Map，可以通过 disableSourceMap 配置项关闭，从而提升 build 构建的速度。\n\n\n\n详见 output.disableSourceMap。","routePath":"/guides/advanced-features/build-performance","lang":"zh","toc":[{"text":"通用优化策略","id":"通用优化策略","depth":2,"charIndex":162},{"text":"升级 Node.js 版本","id":"升级-nodejs-版本","depth":3,"charIndex":219},{"text":"使用 Rspack 构建","id":"使用-rspack-构建","depth":3,"charIndex":474},{"text":"使用 SWC 或 esbuild 编译","id":"使用-swc-或-esbuild-编译","depth":3,"charIndex":548},{"text":"避免使用 ts-loader","id":"避免使用-ts-loader","depth":3,"charIndex":1012},{"text":"开发环境优化策略","id":"开发环境优化策略","depth":2,"charIndex":1188},{"text":"调整 Source Map 格式","id":"调整-source-map-格式","depth":3,"charIndex":1219},{"text":"调整 Browserslist 范围","id":"调整-browserslist-范围","depth":3,"charIndex":1497},{"text":"生产环境优化策略","id":"生产环境优化策略","depth":2,"charIndex":1708},{"text":"禁用 Source Map","id":"禁用-source-map","depth":3,"charIndex":1739}],"domain":"","frontmatter":{"sidebar_position":12},"version":""},{"id":520,"title":"代码分割","content":"#\n\n代码分割（code splitting）是优化前端资源加载的一种常用手段，本文将介绍 Modern.js 支持的三种代码分割方式：\n\nINFO\n\n使用 Modern.js 约定式路由时，默认会根据路由组件做代码分割，无需自行进行代码分割。\n\n * 动态 import\n * React.lazy\n * loadable\n\n\n动态 import#\n\n使用动态 import() 语法，传入的 JS 模块将会被被打包到单独的 JS 文件中。例如：\n\n\n\n\nReact.lazy#\n\nReact 官方提供的组件代码分割的方式。\n\nCAUTION\n\nReact.lazy 通常配合 使用，因此仅在 CSR 或 React 18 Streaming SSR 中可用。\n\n对于使用传统 SSR（字符串渲染）的项目，不支持 React.lazy，请使用 Loadable API。\n\n\n\nReact.lazy 更多用法请见 React 官网文档。\n\n\nLoadable#\n\n在 Modern.js 中，可以从 @modern-js/runtime/loadable 中导出使用 Loadable API，示例如下：\n\n\n\nModern.js 开箱即用的支持在 SSR 中使用 loadable，无需再添加 Babel 插件，或是在 SSR 时向 HTML 中注入脚本。\n\n但需要注意的是，任何 Loadable API 在 SSR 中都不支持配合 使用。\n\nINFO\n\n如果希望在 React 17 及以下的 CSR 项目中使用 ，可以用 loadable.lazy 代替 React.lazy。\n\n更多用法请见 Loadable API。","routePath":"/guides/advanced-features/code-split","lang":"zh","toc":[{"text":"动态 import","id":"动态-import","depth":2,"charIndex":164},{"text":"React.lazy","id":"reactlazy","depth":2,"charIndex":228},{"text":"Loadable","id":"loadable","depth":2,"charIndex":421}],"domain":"","frontmatter":{"sidebar_position":3},"version":""},{"id":521,"title":"浏览器兼容性","content":"#\n\n\nBrowserslist 配置#\n\nModern.js 支持设置 Web 应用需要兼容的浏览器范围，你可以在 .browserslistrc 文件里设置 Browserslist 的值。\n\n当你创建一个新的 Modern.js 项目时，默认会包含一份 .browserslistrc 配置，这表示 JavaScript 代码会被编译至 ES6 格式。\n\n\n\nTIP\n\n请查看 Rsbuild - 设置浏览器范围 来了解更多内容。\n\n\nPolyfill#\n\n\n编译时 Polyfill#\n\nModern.js 在编译时默认通过 core-js 引入对应的 Polyfill 代码。\n\n默认情况下会根据项目 Browserslist 的设置情况引入所需的 Polyfill 代码， 这样基本不用再担心项目源码和第三方依赖的 Polyfill\n问题了，但是因为包含了一些没有用到的 Polyfill 代码，所以最终的包大小可能会有所增加。\n\nINFO\n\n对于明确第三方依赖不需要 Polyfill 的场景，可以设置 output.polyfill 为 usage, 这样 Babel\n编译时只会根据代码中使用到的语法引入 Polyfill 代码。\n\n\n运行时按需 Polyfill#\n\nModern.js 中还提供了基于浏览器 UA 信息的运行时按需 Polyfill 方案，相比于 Babel 优势如下：\n\n * 不会插入到代码中，只根据访问页面的设备，按需下发 Polyfill 代码 ，减少整体代码体积。\n * 相同浏览器会公用一份 Polyfill 代码。因此，随着项目越来越多，基于 UA 的 Polyfill 代码下发速度会越来越快，综合速度超过常规方案。\n\n可以通过微生成器开启该功能：\n\n\n\n执行命令后，在 modern.config.ts 中注册 Polyfill 插件:\n\n\n\n配置 output.polyfill 为 ua 并且执行 pnpm run build && pnpm run serve 启动服务器后，访问页面可以看到\nHTML 产物中包含如下脚本:\n\n\n\n在 Chrome 51 下访问页面可以看到 http://localhost:8080/__polyfill__ 返回内容如下:\n\n\n\n注意\n\n该功能只有在使用 Modern.js 内置的 Web Server 时才会生效。\n\n如果有自定义模版的需求，请参考 HTML 模板。通过 html.template 或 tools.html 手动修改模版时，可能会导致该功能无法正确生效。","routePath":"/guides/advanced-features/compatibility","lang":"zh","toc":[{"text":"Browserslist 配置","id":"browserslist-配置","depth":2,"charIndex":3},{"text":"Polyfill","id":"polyfill","depth":2,"charIndex":220},{"text":"编译时 Polyfill","id":"编译时-polyfill","depth":3,"charIndex":232},{"text":"运行时按需 Polyfill","id":"运行时按需-polyfill","depth":3,"charIndex":526}],"domain":"","frontmatter":{"sidebar_position":6},"version":""},{"id":522,"title":"ESLint 规则集","content":"#\n\nModern.js ESLint 规则集是全量的 ESLint 规则集合，包含 @modern-js （对于 Node.js 项目的 Lint 规则）和\n@modern-js-app（对于前端项目的 Lint 规则）。\n\n下面以具体问题介绍更多 ESLint 用法。\n\n\nQ: 如何处理 Lint#\n\n\n实时自动修复#\n\n多数问题会被 ESLint 规则的自动修复功能或 Prettier 的代码格式化功能（已被集成到 ESLint\n里）自动解决，开发者不需要关心问题的细节和解决方式。\n\nINFO\n\n主要在 IDE 保存文件的环节执行这种自动修复，少数漏网之鱼会在提交代码环节被自动修复。\n\n\n批量自动修复#\n\n在少数情况下，比如旧项目迁移的时候，可以执行以下命令，批量修复和检查所有文件：\n\n\n\n\n人工修复#\n\n对于无法自动修复的问题，可以在 IDE 里点击问题提示框里的规则链接，打开这条规则的文档，查看问题的解释和解决方案。\n\n\n声明例外情况#\n\n目前阶段，有些规则并不能做到足够智能，多数情况下会有很大收益，在少数情况下也许不适用。但如果为了这些少数情况就把整个规则关掉或改掉，得不偿失。\n\n这种情况下可以用 eslint-disable 注释，对符合少数情况的代码块做标注，声明这里是一个例外，应该忽略。比如：\n\n\n\nINFO\n\n在 VS Code 编辑器里输入 eslint，会自动出现关于 \"eslint-disable\" 的提示框，选择提示选项生成对应注释对。\n\n【Modern.js ESLint 规则集】要求 eslint-disable\n必须成对使用，必须明确表达要影响的范围，以及在这个范围内明确表达要禁用什么规则，目的是让例外有明确的、最小化的范围，避免 eslint-disable\n被滥用，导致不属于例外的代码也被禁用了规则。\n\n\nQ: 如何自定义 ESLint 规则#\n\n\n仓库根目录下 package.json 里的 \"eslintConfig\" 字段#\n\n这个地方是整个仓库的默认 ESLint 配置，是针对纯 Node.js 代码（只能在 Node.js 里运行）设计的。\n\n如果项目在某些规则上确实有特殊要求或不可避免的兼容问题（不是例外），可以在这里增加规则配置。该配置会优先于默认的【Modern.js ESLint\n规则集】，比如：\n\n\n\n\nsrc/.eslintrc.js 文件#\n\nModern.js Framework、Modern.js Module 的源代码目录里都会默认有这个配置文件，是针对 Universal JS 代码设计的。\n\nINFO\n\nUniversal JS 代码是既能浏览器端也能在服务器端运行的代码。\n\n如果项目在某些规则上确实有特殊要求或不可避免的兼容问题（不是例外），可以在这里增加规则配置，该配置会优先于默认的【Modern.js ESLint\n规则集】，比如：\n\n\n\n如果有需要，还可以继续在不同的子目录里增加 .eslintrc.js 文件，针对这个子目录里的代码做特殊配置：\n\n\n\n提示\n\n注意：没有必要使用 extends 字段，会自动继承父目录的配置。\n\n\npackage.json 里的 eslintIgnore 字段#\n\n把包含 .js、.jsx、.ts、.tsx 文件、但不需要做代码检查和自动修复的目录，添加到 eslintIgnore 里，可以优化 ESLint\n检查的速度，比如：\n\n\n\n\nQ: 如何升级 ESLint 插件的版本#\n\n只要不是 Major 版本的变化（不符合 Semver 规则的 ^ 符号），就可以直接在业务项目的 package.json 里指定这个依赖，删除 Lock\n文件（或尝试手动删除 Lock 文件中这个包名的内容），执行 pnpm install 重新安装依赖并且生成新的 Lock 文件。\n\n做完这些操作之后，在业务项目的 ./node_modules 目录里，这个插件应该只存在一份，并且升级到了你指定的版本。\n\n提示\n * Major 版本就是主版本号。更多信息，请阅读 Semantic Versioning。\n * 所有被 Modern.js 封装的上游项目（比如 ESLint、ESLint 插件、React Router 等），也都可以这样升级。\n * Modern.js 也会在每次发版中尽量及时的升级这些上游依赖。\n * Major 版本的升级需要由 Modern.js 来发版。\n\n\nQ: WebStorm 有时候会报 ESLint 错误#\n\n由于 WebStorm 认为 ESLint 执行目录是根据 .eslintrc 文件来决定的。因此 src/.eslintrc 文件位置的放置会导致\ntsconfig.json 文件指定的位置（项目根目录下）在 src/ 目录下找不到。\n\n此时需要手动配置一下：\n\n\n\n","routePath":"/guides/advanced-features/eslint","lang":"zh","toc":[{"text":"Q: 如何处理 Lint","id":"q-如何处理-lint","depth":2,"charIndex":138},{"text":"实时自动修复","id":"实时自动修复","depth":3,"charIndex":154},{"text":"批量自动修复","id":"批量自动修复","depth":3,"charIndex":300},{"text":"人工修复","id":"人工修复","depth":3,"charIndex":353},{"text":"声明例外情况","id":"声明例外情况","depth":3,"charIndex":421},{"text":"Q: 如何自定义 ESLint 规则","id":"q-如何自定义-eslint-规则","depth":2,"charIndex":784},{"text":"仓库根目录下 `package.json` 里的 \"eslintConfig\" 字段","id":"仓库根目录下-packagejson-里的-eslintconfig-字段","depth":3,"charIndex":-1},{"text":"`src/.eslintrc.js` 文件","id":"srceslintrcjs-文件","depth":3,"charIndex":-1},{"text":"package.json 里的 `eslintIgnore` 字段","id":"packagejson-里的-eslintignore-字段","depth":3,"charIndex":-1},{"text":"Q: 如何升级 ESLint 插件的版本","id":"q-如何升级-eslint-插件的版本","depth":2,"charIndex":1450},{"text":"Q: WebStorm 有时候会报 ESLint 错误","id":"q-webstorm-有时候会报-eslint-错误","depth":2,"charIndex":1874}],"domain":"","frontmatter":{"sidebar_position":8},"version":""},{"id":523,"title":"静态资源内联","content":"#\n\n静态资源内联是一种优化网页性能的方法，它指的是将静态资源直接内联到 HTML 或 JS\n文件中，而不是使用外部文件引用的方式。这样做的好处是减少了浏览器发起的请求数，从而提高页面的加载速度。\n\n不过，静态资源内联也有一些缺点，比如增加了单个文件的体积，可能会导致加载变慢。所以在实际应用中，需要根据具体情况来决定是否使用静态资源内联。\n\nModern.js 默认会自动内联体积小于 10KB\n的静态资源，但有时候你可能需要手动控制某些特殊资源，让其强制内联或者强制不内联，这篇文档阐述了如何进行精确地控制静态资源内联行为。\n\n\n自动内联#\n\n默认情况下，当图片、字体、媒体等类型的文件体积小于阈值（默认为 10KB）时，Modern.js 会将资源进行内联处理，资源内联后，会被转换成一个 Base64\n编码的字符串，不再会发送独立的 HTTP 请求。当文件体积大于或等于该阈值时，则会被作为单独的资源文件，通过独立的 HTTP 请求来加载。\n\n自动内联的体积阈值可以通过 output.dataUriLimit 配置项修改。例如，修改图片资源的阈值为 5000 字节，设置视频资源不内联：\n\n\n\n\n强制内联#\n\n你可以通过在引入资源时添加 inline URL 参数来强制内联该资源，无论该资源的体积是否小于阈值。\n\n\n\n在上面这个例子中，foo.png 图片将始终被内联，无论该图片的大小是否大于阈值。\n\n除了 inline 参数以外，你也可以使用 __inline 参数来强制内联该资源：\n\n\n\n\n从 CSS 文件中引用#\n\n当你在 CSS 文件中引用静态资源时，同样可以通过 inline 或 __inline 参数来强制内联资源。\n\n\n\n你真的需要强制内联吗？\n\n内联体积过大的资源时，会显著增加页面的白屏时间或首次可交互时间，这会损害用户体验。并且当你将一个静态资源多次内联到 CSS 文件中时，base64\n内容会重复注入，导致产物体积增大。因此，请酌情使用强制内联。\n\n\n强制不内联#\n\n当你想把一些资源始终作为单独的资源文件来处理，无论该资源的体积多小时，你可以添加 url URL 参数来强制不内联该资源。\n\n\n\n在上面这个例子中，foo.png 图片将始终通过单独的资源文件加载，无论该图片的大小是否小于阈值。\n\n除了 url 参数以外，你也可以使用 __inline=false 参数来强制不内联该资源：\n\n\n\n\n从 CSS 文件中引用#\n\n当你在 CSS 文件中引用静态资源时，同样可以通过 url 或 __inline=false 参数来强制不内联资源。\n\n\n\n你真的需要把资源排除内联吗？\n\n将资源排除内联将增加 Web App 需要加载的资源数量，这对于弱网环境，或是未开启 HTTP2 的场景下，将会降低资源加载效率，因此，请酌情使用强制不内联。\n\n\n内联 JS 文件#\n\n除了将静态资源文件内联到 JS 文件里，Modern.js 也支持将 JS 文件内联到 HTML 文件中。\n\n只需要开启 output.enableInlineScripts 配置项，构建生成的 JS 文件将不会被写入产物目录下，而是会直接内联到对应的 HTML\n文件中。\n\n\n\nTIP\n\n内联 JS 文件可能会导致 HTML 单文件体积过大，并且不利于静态资源缓存，请酌情使用。\n\n\n内联 CSS 文件#\n\n你也可以将 CSS 文件内联到 HTML 文件中。\n\n只需要开启 output.enableInlineStyles 配置项，构建生成的 CSS 文件将不会被写入产物目录下，而是会直接内联到对应的 HTML\n文件中。\n\n\n\n\n添加类型声明#\n\n当你在 TypeScript 代码中使用 ?inline 和 ?url 等 URL 参数时，TypeScript 可能会提示该模块缺少类型定义：\n\n\n\n此时你需要为这些 URL 参数添加类型声明，请在项目中创建 src/global.d.ts 文件，并添加以下类型声明：\n\n","routePath":"/guides/advanced-features/inline-assets","lang":"zh","toc":[{"text":"自动内联","id":"自动内联","depth":2,"charIndex":266},{"text":"强制内联","id":"强制内联","depth":2,"charIndex":502},{"text":"从 CSS 文件中引用","id":"从-css-文件中引用","depth":3,"charIndex":654},{"text":"强制不内联","id":"强制不内联","depth":2,"charIndex":846},{"text":"从 CSS 文件中引用","id":"从-css-文件中引用-1","depth":3,"charIndex":1021},{"text":"内联 JS 文件","id":"内联-js-文件","depth":2,"charIndex":1195},{"text":"内联 CSS 文件","id":"内联-css-文件","depth":2,"charIndex":1399},{"text":"添加类型声明","id":"添加类型声明","depth":2,"charIndex":1524}],"domain":"","frontmatter":{"sidebar_position":13},"version":""},{"id":524,"title":"配置底层工具","content":"#\n\n\n使用方式#\n\nModern.js 内部默认集成了 Babel、TypeScript、Webpack、PostCSS、Tailwind CSS\n等工具。通常情况下，默认配置能够满足大多业务开发需求。当有特殊需求时，可以通过底层配置来实现。\n\n以配置 Webpack 为例，只需要在 modern.config.ts 中添加 tools.webpack 即可：\n\n\n\ntools 命名空间下的配置都可以设置为 Object 或者 Function。\n\n值为 Object 时，会与内部默认配置进行合并，具体合并策略参考对应的配置选项文档（见下表）。\n\n值为 Function 时，第一个参数为内部的默认配置对象，可以直接修改这个对象不做返回，也可以返回一个新的对象或者合并后的对象作为最终结果。\n\n\n底层配置明细#\n\n目前提供的底层配置如下表：\n\n底层工具                配置\nDevServer           tools.devServer\nBabel               tools.babel\nstyled-components   tools.styledComponents\nPostCSS             tools.postcss\nLess                tools.less\nSass                tools.sass\nwebpack             tools.webpack\nMinify CSS          tools.minifyCss\nterser              tools.terser\nTailwind CSS        tools.tailwind\nAutoprefixer        tools.autoprefixer","routePath":"/guides/advanced-features/low-level","lang":"zh","toc":[{"text":"使用方式","id":"使用方式","depth":2,"charIndex":3},{"text":"底层配置明细","id":"底层配置明细","depth":2,"charIndex":351}],"domain":"","frontmatter":{"sidebar_position":10},"version":""},{"id":525,"title":"产物体积优化","content":"#\n\n产物体积的优化在生产环境中是非常重要的，因为它直接影响到了线上的用户体验。在这篇文档中，我们将介绍在 Modern.js 中一些常见的产物体积优化方式。\n\n\n减少重复依赖#\n\n在业务项目中，会存在某些第三方依赖被安装了多个版本的现象。重复依赖会导致包体积变大、构建速度变慢。\n\n我们可以通过社区中的一些工具来检测或消除重复依赖。\n\n * 如果你在使用 pnpm >= 7.26.0，可以使用 pnpm 自带的 pnpm dedupe 命令来升级和消除其中的重复依赖。\n\n\n\n * 如果你在使用 pnpm < 7.26.0 版本，可以使用 pnpm-deduplicate 来分析出所有的重复依赖，并通过升级依赖或声明 pnpm\n   overrides 进行版本合并。\n\n\n\n * 如果你在使用 yarn，可以使用 yarn-deduplicate 来自动合并重复依赖：\n\n\n\n\n使用更轻量的库#\n\n建议将项目中体积较大的三方库替换为更轻量的库，比如将 moment 替换为 day.js。\n\n如果你需要找出项目中体积较大的三方库，可以在执行构建时添加 BUNDLE_ANALYZE=true 环境变量：\n\n\n\n详见 performance.bundleAnalyze 配置项。\n\n\n提升 Browserslist 范围#\n\nModern.js 会根据项目的 Browserslist 配置范围进行代码编译，并注入相应的\nPolyfill。如果项目不需要兼容旧版浏览器，可以根据实际情况来提升 Browserslist 范围，从而减少在语法和 Polyfill 上的编译开销。\n\nModern.js 默认的 Browserslist 配置为：\n\n\n\n比如只兼容 Chrome 61 以上的浏览器，可以改成：\n\n\n\nTIP\n\n请阅读 设置浏览器范围 章节来了解更多关于 Browserslist 的用法。\n\n\n按需引入 polyfill#\n\n在明确第三方依赖不需要额外 polyfill 的情况下，你可以将 output.polyfill 设置为 usage。\n\n在 usage 模式下，Modern.js 会分析源代码中使用的语法，按需注入所需的 polyfill 代码，从而减少 polyfill 的代码量。\n\n\n\nTIP\n\n请阅读 浏览器兼容性 章节来了解更多关于 polyfill 的用法。\n\n\n使用图片压缩#\n\n在一般的前端项目中，图片资源的体积往往是项目产物体积的大头，因此如果能尽可能精简图片的体积，那么将会对项目的打包产物体积起到明显的优化效果。你可以在\nModern.js 中注册插件来启用图片压缩功能:\n\n\n\n详见 Image Compress 插件。\n\n\n代码拆包#\n\n良好的拆包策略对于提升应用的加载性能是十分重要的，可以充分利用浏览器的缓存机制，减少请求数量，加快页面加载速度。\n\n在 Modern.js 中内置了多种拆包策略，可以满足大部分应用的需求，你也可以根据自己的业务场景，自定义拆包配置。\n\n比如将 node_modules 下的 axios 库拆分到 axios.js 中：\n\n","routePath":"/guides/advanced-features/optimize-bundle","lang":"zh","toc":[{"text":"减少重复依赖","id":"减少重复依赖","depth":2,"charIndex":81},{"text":"使用更轻量的库","id":"使用更轻量的库","depth":2,"charIndex":392},{"text":"提升 Browserslist 范围","id":"提升-browserslist-范围","depth":2,"charIndex":544},{"text":"按需引入 polyfill","id":"按需引入-polyfill","depth":2,"charIndex":806},{"text":"使用图片压缩","id":"使用图片压缩","depth":2,"charIndex":1003},{"text":"代码拆包","id":"代码拆包","depth":2,"charIndex":1140}],"domain":"","frontmatter":{"sidebar_position":13},"version":""},{"id":526,"title":"使用 Rsbuild 插件","content":"#\n\n\n插件介绍#\n\nRsbuild 是 Modern.js 底层的构建工具，可通过添加 Rsbuild 插件修改默认的构建行为并添加各类额外功能，包括但不限于：\n\n * 修改 Rsbuild 配置\n * 处理新的文件类型\n * 修改或编译文件\n * 部署产物\n\n你可以在 modern.config.ts 中通过 builderPlugins 选项来注册 Rsbuild 插件，详见 builderPlugins\n构建插件。\n\nTIP\n\nModern.js 从 2.46.0 起开始将底层的构建工具升级为 Rsbuild。\n\n如果你当前版本低于 2.46.0, 可通过执行 npx modern upgrade 进行升级。\n\n\n官方插件#\n\n\n内置插件#\n\n以下是已在 Modern.js 中内置的 Rsbuild 官方插件，无需安装，即可启用：\n\n插件                     介绍                                           MODERN.JS 链接\nReact 插件               提供对 React 的支持                                -\nSVGR 插件                支持将 SVG 图片转换为一个 React 组件使用                   output.disableSvgroutput.svgDefaultExport\nStyled Components 插件   提供对 styled-components 的编译时支持                 tools.styledComponents\nAssets Retry 插件        用于在静态资源加载失败时自动发起重试请求                         output.assetsRetry\nType Check 插件          用于在单独的进程中运行 TypeScript 类型检查                  output.disableTsCheckertools.tsChecker\nNode Polyfill 插件       用于注入 Node 核心模块在浏览器端的 polyfills               output.disableNodePolyfill\nSource Build 插件        用于 monorepo 场景，支持引用其他子目录的源代码，并完成构建和热更新       experiments.sourceBuild\nCheck Syntax 插件        用于分析产物的语法兼容性，判断是否存在导致兼容性问题的高级语法              security.checkSyntax\nCSS Minimizer 插件       用于自定义 CSS 压缩工具，切换到 cssnano 或其他工具进行 CSS 压缩。   tools.minifyCss\nPug 插件                 提供对 Pug 模板引擎的支持                              tools.pug\nRem 插件                 用于实现移动端页面的 rem 自适应布局                         output.convertToRem\nYAML 插件                用于引用 YAML 文件，并将其转换为 JavaScript 对象            TOML 文件\nTOML 插件                用于引用 TOML 文件，并将其转换为 JavaScript 对象            YAML 文件\n\n\n未内置插件#\n\n以下是未在 Modern.js 中内置的 Rsbuild 官方插件：\n\n * Image Compress 插件：将项目中用到的图片资源进行压缩处理。\n * Stylus 插件：使用 Stylus 作为 CSS 预处理器。\n * UMD 插件：用于构建 UMD 格式的产物。","routePath":"/guides/advanced-features/rsbuild-plugin","lang":"zh","toc":[{"text":"插件介绍","id":"插件介绍","depth":2,"charIndex":3},{"text":"官方插件","id":"官方插件","depth":2,"charIndex":314},{"text":"内置插件","id":"内置插件","depth":3,"charIndex":322},{"text":"未内置插件","id":"未内置插件","depth":3,"charIndex":1601}],"domain":"","frontmatter":{"sidebar_position":21,"title":"使用 Rsbuild 插件"},"version":""},{"id":527,"title":"使用 Rspack","content":"#\n\nRspack - 高性能 Web 构建工具\n\nRspack 是一个基于 Rust 的高性能 Web 构建工具，具备与 webpack 生态系统的互操作性，可以被 webpack\n项目低成本集成，并提供更好的构建性能。\n\n相较于 webpack，Rspack 的构建性能有明显提升，除了 Rust 带来的语言优势，这也来自于它的并行架构和增量编译等特性。经过 benchmark\n验证，Rspack 可以带来 5 ～ 10 倍编译性能的提升。\n\nModern.js 提供开箱即用的 Rspack 支持，你可以在成熟的 Webpack 和更快的 Rspack 之间进行切换。\n\n这篇文档会向你介绍如何在 Modern.js 中开启 Rspack 构建模式。\n\n\n初始化 Rspack 项目#\n\nModern.js 生成器会提供一个可交互的问答界面，只需将构建工具选择为 Rspack，即可创建一个 Rspack 项目:\n\n\n\n项目创建完成后，在项目中执行 pnpm run dev 即可体验项目，更多信息可参考快速上手。\n\nTIP\n\n在使用 Rspack 作为打包工具时，由于部分能力尚在开发中，以下 features 暂时无法使用，我们将在未来提供支持：\n\n * 客户端渲染（CSR）使用 useLoader\n\n\n开启 Rspack 构建#\n\n从 Modern.js 2.46.0 版本起，在一个已有的 Modern.js 项目中，你仅需在 modern.config.ts 中添加以下配置，即可启用\nRspack 构建：\n\n\n\nTIP\n\n如果你当前版本低于 2.46.0, 可通过执行 npx modern upgrade 进行升级。\n\n\n注意事项#\n\n在使用 Rspack 之前，请留意 Rspack 当前还处于快速迭代阶段。因此，你需要预先了解以下事项：\n\n * Rspack 的 API 和配置项尚未完全稳定，因此在后续的非 major 版本中，可能会引入个别不兼容更新。\n * Rspack 目前基于 SWC 进行代码编译和压缩，由于 SWC 的成熟度不及 babel 和 terser，因此你可能会遇到 SWC 在边界场景下的\n   bug。\n * Rspack 模式兼容了大部分 webpack 生态的插件和 loaders，但仍有少部分插件和 loaders 暂时无法使用。\n\nRspack 正在积极改善上述问题，并计划在未来的版本中逐步解决它们。在决定是否使用 Rspack\n之前，我们建议你评估项目需求和风险承受能力。如果你的项目对稳定性和性能要求较高，可以先选择更成熟的\nwebpack。如果你愿意尝试新的开发体验并为其发展做出贡献，我们欢迎你使用 Rspack，并提供反馈和报告问题，以帮助改进它的稳定性和功能。\n\n\n配置迁移#\n\nModern.js 中 tools.webpack 和 tools.webpackChain 配置仅在 webpack 模式下生效，开启 Rspack\n构建能力后，可根据实际使用场景决定是否修改为 tools.rspack 或 tools.bundlerChain。\n\n\n\nTIP\n\n开启 Rspack 构建能力后，目前有小部分配置在 Rspack 中还不支持使用，如 source.moduleScopes、security.sri 等。\n\n对于不支持的配置，我们在文档中有标注 打包工具： 仅支持 webpack 或 打包工具： 仅支持 rspack，可参考具体配置介绍。\n\n\n修改转译配置#\n\nModern.js 在 Rspack 模式下使用 Rspack builtin:swc-loader 进行代码转译。\n\nModern.js 已对 builtin:swc-loader 的常见配置提供了更方便的配置方式，如：通过 source.transformImport\n配置组件库按需引入。如果对 builtin:swc-loader 有自定义配置的需求，可通过 tools.swc 进行配置：\n\n\n\nTIP\n\n在启用 Rspack 构建时，babel-loader 默认不会被启用。如需添加 babel 插件，可通过 tools.babel\n配置，此时会产生额外的编译开销，在一定程度上拖慢 Rspack 构建速度。\n\n\nRspack 和 Modern.js 的版本关系#\n\n通常情况下，Modern.js 内会集成 Rspack 的最新版本，通过 npx modern upgrade 即可将当前项目中的 Modern.js\n相关依赖以及内置的 Rspack 更新至最新版本。\n\n但 Modern.js 对于 Rspack 的依赖方式为锁版本方式(非自动升级)，由于发版周期不同步等原因，可能会出现 Modern.js 内集成的\nRspack 版本落后于 Rspack 最新版本的情况。\n\n当你执行 dev / build 命令时，Modern.js 会在开启调试模式时自动打印当前使用的 Rspack 版本：\n\n\n\n修改内置 Rspack 版本#\n\n可以使用 pnpm / yarn / npm 等包管理工具自带的依赖升级功能来将 Rspack 强制升级到指定版本。\n\n以 pnpm 为例，可通过 overrides 修改内置的 Rspack 版本。假设需要指定 Rspack 的版本为 0.7.5:\n\n\n\n如果需要使用 Rspack 的 nightly/canary 版本，Rspack 的 nightly/canary 版本的包名会在增加 -canary\n后缀之后发布，需要修改为:\n\n\n\nRspack 提供了 install-rspack 工具来快速修改 Rspack 版本:\n\n\n\nNightly 版本介绍\n\n每天，Rspack 会自动构建基于最新代码的 nightly 版本，用于测试和及早发现错误。\n\n通常情况下，这些版本是可用的。如果发现问题，我们会及时进行修复。但如果 Rspack 有一些 breaking change、需要 Modern.js\n同步修改代码，那么我们建议等待下一个 Modern.js 版本再进行更新。\n\n如果想了解其他包管理工具锁定依赖版本的示例，可以参考：锁定子依赖。","routePath":"/guides/advanced-features/rspack-start","lang":"zh","toc":[{"text":"初始化 Rspack 项目","id":"初始化-rspack-项目","depth":2,"charIndex":331},{"text":"开启 Rspack 构建","id":"开启-rspack-构建","depth":2,"charIndex":558},{"text":"注意事项","id":"注意事项","depth":2,"charIndex":722},{"text":"配置迁移","id":"配置迁移","depth":2,"charIndex":1172},{"text":"修改转译配置","id":"修改转译配置","depth":2,"charIndex":1470},{"text":"Rspack 和 Modern.js 的版本关系","id":"rspack-和-modernjs-的版本关系","depth":2,"charIndex":1793},{"text":"修改内置 Rspack 版本","id":"修改内置-rspack-版本","depth":4,"charIndex":2092}],"domain":"","frontmatter":{"sidebar_position":1},"version":""},{"id":528,"title":"源码构建模式","content":"#\n\n源码构建模式用于 monorepo 开发场景，它允许开发者直接引用 monorepo 中其他子项目的源码进行开发。\n\n\n使用场景#\n\nmonorepo 中项目互相引用主要有产物引用和源码引用两种方式。我们以一个最简单的 monorepo 为例子，来介绍源码引用的使用场景。\n\n比如 monorepo 中包含了一个 app 应用和一个 lib 包：\n\n\n\n其中，app 是基于 Modern.js 构建的，app 依赖了 lib 中的一些方法：\n\n\n\n\n产物引用#\n\n产物引用指的是当前项目引用其他子项目构建后的产物。\n\n比如上述例子中的 lib 是使用 TypeScript 编写的，通常情况下，我们需要提前构建 lib 的代码，生成 JavaScript 产物，这样 app\n才可以正确引用它。当 lib 代码更新时，还需要重新执行一次构建（或者使用 tsc --watch），否则 app 无法引用到最新的代码。\n\n这种方式的优势在于：\n\n * 各个子项目的构建过程是完全独立的，可以拥有不同的构建配置。\n * 可以针对子项目进行构建缓存。\n\n劣势在于：\n\n * 本地开发时 HMR 的链路变长。\n * 当一个项目中包含多个 lib 包时，以上过程会显得十分繁琐。\n\n\n源码引用#\n\n源码引用指的是当前项目引用其他子项目的源码进行构建。\n\n比如上述例子，当你开启了源码构建模式，并在 lib 中添加相关配置后，Modern.js 会自动引用 lib 的 src/index.ts\n源代码。这意味着，你不需要提前构建 lib 的代码，并且当 lib 的源代码更新时，也可以自动触发 app 的热更新。\n\n这种方式的优势在于：\n\n * 子项目不依赖构建工具，也不需要添加构建配置，子项目的代码会被当前项目的构建工具编译。\n * 不需要提前执行子项目的构建流程。\n * 本地开发时 HMR 更高效。\n\n劣势在于：\n\n * 当前项目需要支持子项目用到的语法特性，并且遵循相同的语法规范，比如使用一致的装饰器语法版本。如果当前项目和子项目需要使用不同的编译配置，则不适合使用源码构\n   建。\n * 当前项目需要编译更多的代码，因此构建时间可能会变长。\n\n\n使用源码构建#\n\n\n开启配置#\n\n你可以通过设置 experiments.sourceBuild 为 true 来开启源码构建模式。\n\n\n\n\n配置子项目#\n\n当开启源码构建模式后，Modern.js 在构建过程中，会优先读取子项目的 source 字段对应的文件。因此，你需要在子项目的 package.json\n中配置 source 字段，并且指向源码文件路径。\n\n比如以下例子，当 lib 包被引用时，会读取 ./src/index.ts 文件进行构建：\n\n\n\n如果子项目使用了 exports 配置，那么你同样需要在 exports 中增加 source 字段。\n\n\n\n\n配置 Project Reference#\n\n在 TypeScript 项目中，你需要使用 TypeScript 提供的 Project Reference 能力，它可以帮助你更好地使用源码开发。\n\n\n介绍#\n\nProject reference 提供了以下能力：\n\n * 使 TypeScript 可以正确识别其他子项目的类型，而无须对子项目进行构建。\n * 当你在 VS Code 内进行代码跳转时，VS Code 可以自动跳转到对应模块的源代码文件。\n * Modern.js 会读取 project reference 配置，并自动识别子项目的 tsconfig.compilerOptions.path\n   配置，从而让子项目的别名可以正确生效。\n\n\n示例#\n\n在上文的例子中，由于 app 引用了 lib 子项目，我们需要在 app 的 tsconfig.json 内配置 composite 和\nreferences，并指向 lib 对应的相对目录：\n\n\n\n添加以上两个选项后，project reference 就已经配置完成了，你可以重新启动 VS Code 来查看配置以后的效果。\n\n注意以上只是一个最简单的例子，在实际的 monorepo 项目中，可能会有更复杂的依赖关系，你需要添加完整的 references\n配置，才能使上述功能正确运作。\n\nTIP\n\n如果你想了解更多关于 project reference 的内容，请阅读 TypeScript - Project References 官方文档。\n\n\n注意事项#\n\n在使用源码构建模式的时候，需要注意几点：\n\n 1. 需要保证当前项目可以编译子项目里使用的语法或特性。比如子项目使用了 Stylus 来编写 CSS 样式，那就需要当前 app 支持 Stylus 编译。\n 2. 需要保证当前项目与子项目使用的代码语法特性相同，例如装饰器的语法版本一致。\n 3. 源码构建可能存在一些限制。如果在使用中遇到问题，你可以将子项目 package.json 中的 source 字段移除，使用子项目的构建产物进行调试。\n 4. 开启 composite: true 后，TypeScript 会生成 *.tsbuildinfo 临时文件，你需要将这些临时文件加入\n    .gitignore 中。\n\n","routePath":"/guides/advanced-features/source-build","lang":"zh","toc":[{"text":"使用场景","id":"使用场景","depth":2,"charIndex":62},{"text":"产物引用","id":"产物引用","depth":3,"charIndex":228},{"text":"源码引用","id":"源码引用","depth":3,"charIndex":539},{"text":"使用源码构建","id":"使用源码构建","depth":2,"charIndex":928},{"text":"开启配置","id":"开启配置","depth":3,"charIndex":938},{"text":"配置子项目","id":"配置子项目","depth":3,"charIndex":999},{"text":"配置 Project Reference","id":"配置-project-reference","depth":2,"charIndex":1217},{"text":"介绍","id":"介绍","depth":3,"charIndex":1318},{"text":"示例","id":"示例","depth":3,"charIndex":1549},{"text":"注意事项","id":"注意事项","depth":2,"charIndex":1885}],"domain":"","frontmatter":{"sidebar_position":11},"version":""},{"id":529,"title":"静态站点生成","content":"#\n\nSSG（Static Site Generation）是一种基于数据与模板，在构建时渲染完整静态网页的技术解决方案。\n\n我们首先需要执行 pnpm run new 启用 SSG 功能：\n\n\n\n执行命令后，在 modern.config.ts 中注册 SSG 插件：\n\n\n\nSSG 在约定式路由和自控式路由下的使用方式不同。\n\n\n在约定式路由中使用#\n\n约定式路由中， Modern.js 根据入口下的文件结构生成路由，因此框架能够收集完整的路由信息。\n\n例如，以下是一个使用约定式路由的项目目录结构：\n\n\n\n上述文件目录将会生成以下三条路由：\n\n * /\n * /user\n * /user/profile\n\nNOTE\n\n如果还不了解约定式路由的规则，可以先查看路由方案。\n\n在 src/routes/page.tsx 中添加组件代码：\n\n\n\nSSG 也是在 Node.js 环境渲染页面，因此我们可以在开发阶段开启 SSR，提前在暴露代码问题，验证 SSG 渲染效果：\n\n\n\n在项目根路径下执行 pnpm run dev 命令，查看 dist/ 目录，此时只生成一个 HTML 文件 main/index.html。\n\n在项目根路径下执行 pnpm run build 命令，构建完成后，查看 dist/ 目录，此时生成\nmain/index.html、main/user/index.html 和 main/user/profile/index.html 三个 HTML\n文件，内容分别对应上述三条路由。\n\n约定式路由中的每一条路由，都会生成一个单独的 HTML 文件。查看 main/index.html，可以发现包含 Index Page 的文本内容，这正是\nSSG 的效果。\n\n执行 pnpm run serve 启动项目后，访问页面，在浏览器我们工具的 Network 窗口，查看请求返回的文档，文档包含组件渲染后的完整页面内容。\n\n\n在自控式路由中使用#\n\n自控式路由是通过组件代码定义路由，需要应用运行起来才能获取准确的路由信息。因此，无法开箱即用的使用 SSG 功能。此时需要用户提前告知 Modern.js\n框架，哪些路由需要开启 SSG 功能。\n\n例如有以下代码，包含多条路由，设置 output.ssg 为 true 时，默认只会渲染入口路由即 /：\n\n\n\n如果我们希望同时开启 /about 的 SSG 功能，可以配置 output.ssg，告知 Modern.js 开启指定路由的 SSG 功能。\n\n\n\n执行 pnpm run build 与 pnpm run serve 后，访问 http://localhost:8080/about，在 Preview\n视图中可以看到页面已经完成渲染。\n\n查看构建产物文件，可以看到 dist/ 目录中，新增了一个 main/about/index.html 文件。\n\nINFO\n\n以上仅介绍了单入口的情况，更多相关内容可以查看 API 文档。","routePath":"/guides/advanced-features/ssg","lang":"zh","toc":[{"text":"在约定式路由中使用","id":"在约定式路由中使用","depth":3,"charIndex":166},{"text":"在自控式路由中使用","id":"在自控式路由中使用","depth":3,"charIndex":826}],"domain":"","frontmatter":{"sidebar_position":5},"version":""},{"id":530,"title":"缓存","content":"#\n\n有时我们会将计算结果进行缓存，例如 React useMemo, useCallback Hook。 通过缓存我们可以减少计算的次数来减少 CPU\n资源占用，提高用户体验。\n\n通过将服务器端渲染（SSR）结果进行缓存能够减少服务器每次请求时的计算和渲染时间，从而加速页面加载速度，提高用户体验。\n降低服务端负载，节省计算资源，提高用户访问速度。\n\nINFO\n\n需要 x.43.0+\n\n\n配置方式#\n\n在 server/cache.[t|j]s 中配置缓存即可开启缓存：\n\n\n\n\n配置说明#\n\n\n缓存配置#\n\n缓存策略参考 stale-while-revalidate 进行实现。\n\n在 maxAge 时间内会直接返回缓存内容，超过 maxAge 但在 staleWhileRevalidate\n内也会直接返回缓存内容，但同时会异步做一次重新渲染。\n\nObject 类型\n\n\n\n其中 customKey 为自定义缓存 key。默认情况下 Modern.js 将会把请求 pathname 作为 key\n进行缓存，但在某些情况下这不能满足你的需求，开发者可以进行自定义。\n\nFunction 类型\n\n\n\n有时开发者需要通过 req 来自定义缓存 key，或者特定 url 时缓存不生效，可以配置为函数的形式进行处理, 例如以下代码：\n\n\n\nMapping 类型\n\n\n\n有时开发者面对不同的路由需要应用不同的缓存策略。我们也提供一种映射的方式进行配置, 以下列代码为例子\n\n\n\n * 路由 http://xxx/home 将会应用第一条规则。\n * 路由 http://xxx/about 将会应用第二条规则。\n * 路由 http://xxx/abc 将会应用最后一条规则。\n\n上述 /home 和 /about 将会作为模式进行匹配，这意味着 /home/abc 也会匹配上该规则。 同时，你也可以在其中编写正则语法：/home/.+\n\n\n缓存容器#\n\n默认情况下，Server 将会使用内存进行缓存。但通常情况下服务将会部署在 serverless\n上。每一次的服务访问可能都是一个新的进程，这样每次访问都不能应用缓存\n\n故开发者也可以自定义缓存容器，容器需实现接口 Container\n\n\n\n以下面代码为例，开发者可实现一个 redis 容器。\n\n\n\n\n缓存标识#\n\n当开启渲染缓存后，Modern.js 将通过响应头 x-render-cache 来标识当前请求的缓存状态。\n\n下列是一个响应示例\n\n\n\nx-render-cache 可能会有以下几种值\n\n名称        说明\nhit       缓存命中，返回缓存内容\nstale     缓存命中，但数据陈旧，返回缓存内容的同时做重新渲染\nexpired   缓存命中，重新渲染后返回渲染结果\nmiss      缓存未命中","routePath":"/guides/advanced-features/ssr/cache","lang":"zh","toc":[{"text":"配置方式","id":"配置方式","depth":2,"charIndex":195},{"text":"配置说明","id":"配置说明","depth":2,"charIndex":241},{"text":"缓存配置","id":"缓存配置","depth":3,"charIndex":249},{"text":"缓存容器","id":"缓存容器","depth":3,"charIndex":821},{"text":"缓存标识","id":"缓存标识","depth":2,"charIndex":980}],"domain":"","frontmatter":{"sidebar_position":3,"title":"缓存"},"version":""},{"id":531,"title":"服务端渲染","content":"#\n\n通过在服务器端将网页的 HTML 内容渲染成完整的网页（Server-Side Rendering，简称\nSSR），然后将生成的网页发送到客户端，客户端只需要显示网页即可，不需要再进行额外的渲染。\n\n它主要的优势在于\n\n * 提高首屏加载速度：SSR 可以在服务器端生成完整的网页，客户端只需要下载网页内容即可，不需要再进行额外的渲染，从而提高了首屏加载速度。\n * 提高用户体验：SSR 可以提高网页的响应速度，从而提高用户体验。\n * 有利于 SEO：SSR 可以生成完整的 HTML 内容，搜索引擎可以直接索引 HTML 内容，从而提高网站的排名。\n\n如果你有以下场景的需求，开发者可以考虑使用 SSR 来渲染你的页面：\n\n 1. 对首屏加载速度要求较高的网站，如电商网站、新闻网站等。\n 2. 对用户体验要求较高的网站，如社交网站、游戏网站等。\n 3. 对 SEO 要求较高的网站，如企业官网、博客等。\n\n在 Modern.js 中，SSR 也是开箱即用的。开发者无需为 SSR 编写复杂的服务端逻辑，也无需关心 SSR 的运维，或是创建单独的服务。\n\n除了开箱即用的 SSR 服务，为了保证开发者的开发体验，我们还具备：\n\n * 完备的 SSR 降级策略，保证页面能够安全运行。\n * 自动分割子路由，按需加载，减少首屏资源体积。\n * 内置缓存系统，解决服务端负载高的问题。","routePath":"/guides/advanced-features/ssr/","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":532,"title":"流式渲染","content":"#\n\n\n概述#\n\n流式渲染是一种新的渲染方式，它可以在用户与页面交互时，实时地更新页面内容，从而提高用户体验。\n\n在传统的渲染方式中，页面的渲染是一次性完成的，而在流式渲染中，页面的渲染是逐步完成的，在用户与页面交互时，逐步加载数据，而不是一次性加载所有数据。\n\n相比传统渲染：\n\n * 拥有更快感知速度：流式渲染可以在渲染过程中逐步显示内容能够以最快的速度显示业务首页。\n * 拥有更好的用户体验：通过流式渲染，用户可以更快地看到页面上的内容，而不需要等待整个页面都渲染完成后才能交互。\n * 拥有更好的性能控制：流式渲染可以让开发者更好地控制页面加载的优先级和顺序，从而更好地优化性能和用户体验。\n * 更好的适应性：流式渲染可以更好地适应不同网络速度和设备性能，使得页面在各种环境下都能有更好的表现。\n\n\n使用#\n\nModern.js 支持了 React 18 的流式渲染，可以通过如下配置启用：\n\n\n\nModern.js 的流式渲染基于 React Router 实现，主要涉及 API 有：\n\n * defer：在 Data Loader 中使用，用于支持异步获取数据。\n * Await：用于渲染 Data Loader 返回的异步数据。\n * useAsyncValue：用于从最近的父级 Await 组件中获取数据。\n\n\n异步获取数据#\n\n\n\nuser 是一个 Promise 类型的对象，表示需要异步获取的数据，通过 defer 处理需要异步获取的 user。注意，defer\n必须接收一个对象类型的参数， 因此， 传入 defer 的参数为：{ data: user }\n\ndefer 还可以同时接收异步数据和同步数据。例如：\n\n\n\notherData 前加了 await，所以是同步获取的数据，它可以和异步获取的数据 user 同时传入 defer。\n\n\n渲染异步数据#\n\n通过 Await 组件，可以获取到 Data Loader 中异步返回的数据，然后进行渲染。例如：\n\n\n\nAwait 需要包裹在 Suspense 组件内部，Await 的 resolve 传入的是 Data Loader 异步获取的数据，当数据获取完成后， 通过\nRender Props 模式，渲染获取到的数据。在数据的获取阶段，将展示 Suspense 组件 fallback 属性设置的内容。\n\n注意\n\n从 Data Loader 文件导入类型时，需要使用 import type 语法，保证只导入类型信息，这样可以避免 Data Loader\n的代码打包到前端产物的 bundle 文件中。\n\n所以，这里的导入方式为：``;\n\n也可以通过 useAsyncValue 获取 Data Loader 返回的异步数据。例如：\n\n\n\n\n错误处理#\n\nAwait 组件的 errorElement 属性，可以用来处理当 Data Loader 执行时，或者子组件渲染时抛出的错误。 例如，我们故意在 Data\nLoader 函数中抛出错误：\n\n\n\n然后通过 useAsyncError 获取错误，并将用于渲染错误信息的组件赋值给 Await 组件的 errorElement 属性：\n\n\n\n\n为爬虫等待所有内容加载完毕#\n\n流式传输可以提高用户体验，因为当页面内容可用时，用户可以及时感知到它们。\n\n然而，当一个爬虫访问该页面时，它可能需要先加载所有内容，直接输出整个 HTML，而不是渐进式地加载它。\n\nModern.js 使用 isbot 对请求的 uesr-agent, 以判断请求是否来自爬虫。\n\n补充信息\n 1. Deferred Data\n 2. New Suspense SSR Architecture in React 18","routePath":"/guides/advanced-features/ssr/stream","lang":"zh","toc":[{"text":"概述","id":"概述","depth":2,"charIndex":3},{"text":"使用","id":"使用","depth":2,"charIndex":355},{"text":"异步获取数据","id":"异步获取数据","depth":3,"charIndex":568},{"text":"渲染异步数据","id":"渲染异步数据","depth":3,"charIndex":788},{"text":"错误处理","id":"错误处理","depth":3,"charIndex":1167},{"text":"为爬虫等待所有内容加载完毕","id":"为爬虫等待所有内容加载完毕","depth":2,"charIndex":1344}],"domain":"","frontmatter":{"sidebar_position":2,"title":"流式渲染"},"version":""},{"id":533,"title":"基础使用","content":"#\n\n启用 SSR 非常简单，只需要设置 server.ssr 为 true 即可：\n\n\n\n\nSSR 时的数据获取#\n\nModern.js 中提供了 Data Loader，方便开发者在 SSR、CSR 下同构地获取数据。每个路由模块，如 layout.tsx 和\npage.tsx 都可以定义自己的 Data Loader：\n\n\n\n在组件中可以通过 Hooks API 的方式获取 loader 函数返回的数据：\n\n\n\nModern.js 打破传统的 SSR 开发模式，提供了用户无感的 SSR 开发体验。并且提供了优雅的降级处理，一旦 SSR\n请求失败，会自动降级在浏览器端重新发起请求。\n\n不过，开发者仍然需要关注数据的兜底处理，例如 null 值或不符合预期的数据返回。避免在 SSR 时产生 React 渲染错误或是返回凌乱的渲染结果。\n\n补充信息\n\n 1. 当以客户端路由的方式请求页面时，Modern.js 会发送一个 HTTP 请求，服务端接收到请求后执行页面对应的 Data Loader\n    函数，然后将执行结果作为请求的响应返回浏览器。\n\n 2. 使用 Data Loader 时，数据获取发生在渲染前，Modern.js 也仍然支持在组件渲染时获取数据。更多相关内容可以查看数据获取。\n\n\n保持渲染一致#\n\n有些业务中，UI 展示会和用户设备有关，例如 UA 信息。如果处理不够仔细，此时很有可能出现不符合预期的渲染结果。\n\n这里通过一个例子，演示当 SSR 与 CSR 渲染不一致时出现的问题，在组件中添加以下代码：\n\n\n\n启动应用后，访问页面，会发现浏览器控制台抛出警告信息：\n\n\n\n这是 React hydrate 结果与 SSR 渲染结果不一致造成的。虽然当前页面表现正常，但在复杂应用中，很有可能因此出现 DOM\n层级混乱、样式混乱等问题。\n\nINFO\n\n关于 hydrate (注水)逻辑请参考这里。\n\n应用需要保持 SSR 与 CSR 渲染结果的一致性，如果存在不一致的情况，说明这部分内容无需在 SSR 中进行渲染。Modern.js 为这类在 SSR\n中不需要渲染的内容提供 工具组件：\n\n\n\n在不需要进行 SSR 的元素外部，用 NoSSR 组件包裹：\n\n\n\n修改代码后，刷新页发现之前的 Waring 消失。打开浏览器开发者工具的 Network 窗口，查看返回的 HTML 文档是不包含 NoSSR\n组件包裹的内容的。\n\n补充信息\n\nuseRuntimeContext 可以获取完整的请求信息，可以利用它保证 SSR 与 CSR 的渲染结果一致。\n\n\n关注内存泄漏#\n\n警告\n\n在 SSR 场景下，开发者需要特别关注内存泄露问题，即使是微小的内存泄露，在大量的访问后也会对服务造成影响。\n\nSSR\n时，浏览器的每次请求，都会触发服务端重新执行一次组件渲染逻辑。所以，需要避免在全局定义任何可能不断增长的数据结构，或在全局进行事件订阅，或创建不会被销毁的流。\n\n例如以下代码，使用 redux-observable 时，习惯了 CSR 的开发者通常会在组件中这样编码：\n\n\n\n在组件外层创建 Middleware 实例 epicMiddleware，并在组件内部调用 epicMiddleware.run。\n\n在浏览器端，这段代码不会造成任何问题，但是在 SSR 时，Middleware 实例会一直无法被销毁。每次渲染组件，调用\nepicMiddleware.run(rootEpic) 时，都会在内部添加新的事件绑定，导致整个对象不断变大，最终对应用性能造成影响。\n\nCSR 中这类问题不易被发觉，因此从 CSR 切换到 SSR 时，如果不确定应用是否存在这类隐患，可以对应用进行压测。\n\n\n收敛服务端数据#\n\n为了使浏览器端能够直接使用 SSR 阶段请求的数据，Modern.js 会将渲染过程中收集的数据与状态注入到 HTML 内。但是，CSR\n应用常常存在接口数据量大、组件状态未收敛的情况，这时如果直接使用 SSR，渲染得到的 HTML 体积可能会存在过大的问题。此时，SSR\n不仅无法为应用带来用户体验上的提升，反而可能起到相反的作用。\n\n因此，使用 SSR 时，开发者需要为应用做合理的瘦身：\n\n 1. 关注首屏，SSR 中可以只请求首屏需要的数据，并在浏览器端渲染剩余的部分。\n 2. 将与渲染无关的数据，从接口返回数据中剔除。\n\n\nServerless Pre-render#\n\nWARNING\n\nx.43.0+ 已废弃，请使用 SSR Cache 替代\n\nModern.js 提供 Serverless Pre-rendering (SPR) 这一特性来提升 SSR 性能。\n\nSPR 利用预渲染与缓存技术，为 SSR 页面提供静态 Web 的响应性能。它让 SSR 应用拥有静态 Web\n页面的响应速度与稳定性，同时还能保持数据的动态更新。\n\n在 Modern.js 中使用 SPR 非常简单，只需要在组件中新增 PreRender 组件，该组件所在的页面就会自动开启 SPR。\n\n这里模拟一个使用 useLoaderData API 的组件，Data Loader 中的请求需要消耗 2s 时间。\n\n\n\n\n\n执行 dev 命令后，打开页面，可以明显的察觉到页面需要等到 2s 后才返回。\n\n接下来使用 PreRender 组件来进行优化，该组件可以直接从 @modern-js/runtime/ssr 中导出：\n\n\n\n在路由组件内使用 PreRender 组件，并设置参数 interval，用于表示该次渲染结果的过期时间为 5s：\n\n\n\n修改后，执行 pnpm run build && pnpm run serve 启动应用，并打开页面。\n\n首次打开时，和之前的渲染并没有什么不同，同样存在 2s 延迟。点击刷新，页面瞬间打开，但此时，页面数据并没有因为刷新发生变化，这是因为缓存还没有过期。\n\n等待 5s，重新刷新页面，页面的数据仍然没有变化。再一次刷新页面数据发生变化，但是页面仍然几乎是瞬间响应的。 这是因为在之前的请求时，SPR\n已经在后台异步获取了新的渲染结果，本次请求到的页面是已经缓存在服务器中的版本。\n\n可以想象，当 interval 设置为 1 时，用户可以在感知到实时数据的同时，拥有静态页面的响应体验。\n\n补充信息\n\nPreRender 的详细使用可以参考这里。\n\n\nTreeshaking#\n\n开启 SSR 时，Modern.js 会用相同的入口，构建出 SSR Bundle 和 CSR Bundle 两份产物。因此，在 SSR Bundle 中存在\nWeb API，或是在 CSR Bundle 中存在 Node API 时，都可能导致运行出错。\n\n在组件中引入 Web API，通常情况下是要做一些全局监听，或是获取浏览器相关的数据，例如：\n\n\n\n在组件文件中引入 Node API，通常情况下是因为使用了 useLoader，例如：\n\n\n\n\n环境变量区分#\n\n对于第一种情况，我们可以直接使用 Modern.js 内置的环境变量 MODERN_TARGET 进行判断，在构建时删除无用代码：\n\n\n\n开发环境打包后，SSR 产物和 CSR 产物会被编译成以下内容。因此 SSR 环境中不会再因为 Web API 报错：\n\n\n\nNOTE\n\n更多内容可以查看环境变量。\n\n\n文件后缀区分#\n\n但例如第二种情况，在代码中引入了 fs-extra，它内部有使用了 Node API 的副作用，如果直接引用到组件中，会造成 CSR 加载报错。\n\n环境变量的方式并不能在这种情况下生效，Modern.js 也支持通过 .node. 后缀的文件来区分 SSR Bundle 和 CSR Bundle\n产物的打包文件。\n\n可以创建同名的 .ts 和 .node.ts 文件做一层代理：\n\n\n\n\n\n在文件中直接引入 ./compat，此时 SSR 环境下会优先使用 .node.ts 后缀的文件，CSR 环境下会使用 .ts 后缀的文件。\n\n\n\n\n独立文件#\n\n上述两种方式，都会为开发者带来一些心智负担。在真实的业务中，我们发现大多数的 Node / Web 代码混用都出现在数据请求中。\n\n因此，Modern.js 基于嵌套路由开发设计了更简单的方案来分离 CSR 和 SSR 的代码。\n\n我们可以通过独立文件来分离数据请求与组件代码。在 routes/page.tsx 中编写组件逻辑，在 routes/page.data.ts\n中编写数据请求逻辑。\n\n\n\n\n\n\n接口请求#\n\n在 SSR 中发起接口请求时，开发者有时自己封装了同构的请求工具。部分接口需要传递用户 Cookie，开发者可以通过 useRuntimeContext API\n获取到请求头来实现。\n\n需要注意的是，此时获取到的是 HTML\n请求的请求头，不一定适用于接口请求，因此千万不能透传所有请求头。并且，一些后端接口，或是通用网关，会根据请求头中的信息做校验，全量透传容易出现各种难以排查的问题\n，推荐按需透传。\n\n如果实在需要透传所有请求头，请务必过滤 host 字段。","routePath":"/guides/advanced-features/ssr/usage","lang":"zh","toc":[{"text":"SSR 时的数据获取","id":"ssr-时的数据获取","depth":2,"charIndex":46},{"text":"保持渲染一致","id":"保持渲染一致","depth":2,"charIndex":558},{"text":"关注内存泄漏","id":"关注内存泄漏","depth":2,"charIndex":1101},{"text":"收敛服务端数据","id":"收敛服务端数据","depth":2,"charIndex":1572},{"text":"Serverless Pre-render","id":"serverless-pre-render","depth":2,"charIndex":1850},{"text":"Treeshaking","id":"treeshaking","depth":2,"charIndex":2684},{"text":"环境变量区分","id":"环境变量区分","depth":3,"charIndex":2926},{"text":"文件后缀区分","id":"文件后缀区分","depth":3,"charIndex":3089},{"text":"独立文件","id":"独立文件","depth":3,"charIndex":3369},{"text":"接口请求","id":"接口请求","depth":2,"charIndex":3580}],"domain":"","frontmatter":{"sidebar_position":1,"title":"基础使用"},"version":""},{"id":534,"title":"使用 Storybook","content":"#\n\nStorybook 是一个专门用于组件调试的工具，它围绕着组件开发提供了：\n\n * 丰富多样的调试能力\n * 可与一些测试工具结合使用\n * 可重复使用的文档内容\n * 可分享能力\n * 工作流程自动化\n\nTIP\n\n本教程适用于新版 Storybook V7 用户，如果你在使用老版本 Storybook V6 (有使用 @modern-js/plugin-storybook\n插件)，可参考 迁移指南 进行升级。\n\n\n快速开始#\n\nModern.js 默认集成了 Storybook 的调试能力，当我们想要对组件进行调试的时候，可以通过以下方式启用 Storybook 调试功能：\n\n\n\n该命令会创建好 Storybook 常用的模版，包括：\n\n * 创建配置文件夹 .storybook，以及默认配置文件 .storybook/main.ts\n * 创建 stories 组件示例\n * 更新 package.json，新增依赖 @storybook/addon-essential 和 @modern-js/storybook，以及创建\n   storybook 相关脚本\n\n运行 npm run storybook 即可启动 Storybook 预览。\n\n\n开启 Rspack 构建#\n\nRspack 构建速度非常快，在 Modern.js 中只需要如下配置即可使用 Rspack 作为构建工具。\n\n\n\n注意上面配置中，更改了 reactDocgen 配置，因为 Rspack 目前还不支持\n@storybook/react-docgen-typescript-plugin。\n\n\n配置#\n\n在 .storybook/main.js 中包含一些配置。\n\n\nconfigPath#\n\n * 类型: string\n * 默认值: modern.config.(j|t)s\n\n用于指定配置文件路径。\n\n例如\n\n\n\n\nbundler#\n\n * 类型: 'webpack' | 'rspack'\n * 默认值: webpack\n\n指定底层构建工具使用 Webpack 还是 Rspack。\n\n例如\n\n\n\n\nbuilderConfig#\n\n * 类型: BuilderConfig\n * 默认值: undefined\n\n更改构建配置，该配置比配置文件拥有更高的优先级，若不想使用配置文件，也可直接在此处指定。\n\n例如\n\n\n\n\n命令行#\n\n@modern-js/storybook 代理了部分 storybook cli 的命令。\n\n\nstorybook dev#\n\n启动 Storybook，详情请看 storybook#dev\n\n\nstorybook build#\n\n对 Storybook 进行生产环境构建，详情请看 storybook#build\n\n\nStorybook addon 兼容性#\n\n由于当前文档中的 Storybook 版本为 7，因此请选择 storybook V7 的 addon。\n\n当 addon 不需要额外的 Babel 或 Webpack 配置时，可以直接使用，如 @storybook/addon-essentials。\n\n部分 addon 需要依赖 babel 插件和 Webpack 配置时，如 @storybook/addon-coverage，只有使用 webpack\n构建才会支持。\n\n\n收益#\n\n使用 @modern-js/storybook 可以带给你 Rspack 超快的构建，并且完全无需繁琐配置，开箱即用。并且默认包含了许多 Web\n构建中的最佳实践，例如 code splitting 策略，内置 css module 和 postcss，开箱即用的 TypeScript 支持，内置常用\nBabel 插件等等。\n\nModern.js 的构建能力和配置都可以直接在 Storybook 项目中使用。\n\n\nTrouble Shooting#\n\n 1. 使用 Modern.js 启动 storybook 时不会读取 babel.config.json 等配置文件，因此 babel 配置需要在\n    tools.babel 中进行配置。 同样的 webpack 配置需要写在 tools.webpack 或 tools.webpackChain 中。\n\n 2. 如果发现构建速度很慢，请检查是否开启了自动文档生成功能，如果想要最高的性能，请配置为 react-docgen。react-docgen 和\n    react-docgen-typescript 的区别是，前者基于 Babel 实现，后者基于 TypeScript\n    实现，前者性能会更好，但类型推断能力更弱。如果使用 Rspack 构建，则只支持 react-docgen。\n\n\n\n\n迁移指南#\n\n\n从 Modern.js Storybook V6 迁移#\n\n如果你是从 V6 迁移至 V7 的用户，可以通过 上述方式 使用 V7，同时做以下调整:\n\n修改配置文件#\n\n若你在旧版本对 storybook 进行了一些自定义配置，需要将配置文件 root/config/storybook/main.(j|t)s 移动到\nroot/.storybook/main.(j|t)s。\n\n并在 root/.storybook/main.(j|t)s 中添加以下配置，指定 framework 为 @modern-js/storybook：\n\n\n\n依赖升级#\n\n升级 @storybook/addon-* 系列依赖，升级到 7 版本。\n\n移除 @modern-js/plugin-storybook 插件#\n\n在 modern.config.(j|t)s 中删除 @modern-js/plugin-storybook 插件的注册。\n\n修改 Storybook 写法#\n\n按照 Storybook 官网文档，对一些 breaking change 做相应的更新，例如 stories 的写法，MDX 的写法等，参考storybook\n迁移文档。\n\n\n从原生 Storybook 项目迁移#\n\n若当前 Storybook 版本还是 6，需要先按照 Storybook 官网文档升级到版本 7，参考 storybook 迁移文档。\n\n\n\nModern.js 的配置文件默认为 modern.config.(j|t)s，配置请查看 modern.js 配置。\n\n若原来项目中包含了 Babel 等配置，需要对应的写在 modern 配置中，大部分 Babel 配置已经包含进了 Modern.js。\n\n安装完成后进行相应的配置。","routePath":"/guides/advanced-features/using-storybook","lang":"zh","toc":[{"text":"快速开始","id":"快速开始","depth":2,"charIndex":212},{"text":"开启 Rspack 构建","id":"开启-rspack-构建","depth":2,"charIndex":535},{"text":"配置","id":"配置","depth":2,"charIndex":697},{"text":"configPath","id":"configpath","depth":3,"charIndex":734},{"text":"bundler","id":"bundler","depth":3,"charIndex":811},{"text":"builderConfig","id":"builderconfig","depth":3,"charIndex":904},{"text":"命令行","id":"命令行","depth":2,"charIndex":1013},{"text":"storybook dev","id":"storybook-dev","depth":3,"charIndex":1067},{"text":"storybook build","id":"storybook-build","depth":3,"charIndex":1117},{"text":"Storybook addon 兼容性","id":"storybook-addon-兼容性","depth":2,"charIndex":1179},{"text":"收益","id":"收益","depth":2,"charIndex":1416},{"text":"Trouble Shooting","id":"trouble-shooting","depth":2,"charIndex":1630},{"text":"迁移指南","id":"迁移指南","depth":2,"charIndex":2006},{"text":"从 Modern.js Storybook V6 迁移","id":"从-modernjs-storybook-v6-迁移","depth":3,"charIndex":2014},{"text":"从原生 Storybook 项目迁移","id":"从原生-storybook-项目迁移","depth":3,"charIndex":2534}],"domain":"","frontmatter":{"sidebar_position":15},"version":""},{"id":535,"title":"自定义 Web Server","content":"#\n\nModern.js\n作为以客户端为中心的开发框架，对服务端的定制能力较弱。而在有些开发场景下，需要定制特殊的服务端逻辑，例如用户鉴权、请求预处理、添加页面渲染骨架等。\n\n一些开发者可能会有疑惑，Modern.js 已经提供了 BFF 能力，为什么还需要自定义 Web Server。\n\n因为在默认情况下，页面路由并不会经过 BFF，它没有办法为页面访问提供服务端的定制逻辑。之所以这样设计，是因为我们不希望控制页面的服务与 BFF\n服务绑定在一起，避免 BFF 的框架限制页面的部署方式。例如将页面与 BFF 分开托管、将页面服务部署到非 Node 的环境上，或是针对部署平台做定制等。\n\n出于上述原因，Modern.js 提供了三种方式，让项目可以在根据需求，渐进式的定制服务端能力。\n\nWARNING\n\n三种扩展方式无法同时工作，开发者需要根据场景选择合适的方式。\n\n\n使用 API 扩展 Web Server#\n\n第一种方式是通过 Modern.js 提供的服务端运行时 API，在特定的生命周期对服务端进行定制。提供这种方式的目的是在部分情况下，开发者并不需要控制完整的\nWeb Server，只需要添加服务端逻辑即可。\n\n这种方式无法控制完整的 Web Server，并且扩展逻辑只在请求页面时生效。因此，它适用于服务端逻辑相对简单，不希望额外创建 BFF 或者 BFF\n和页面无需公用服务端逻辑场景。\n\n可以在项目根目录执行 pnpm run new 命令，开启「自定义 Web Serve」功能：\n\n\n\n执行命令后，在 modern.config.ts 中注册 @modern-js/plugin-server 插件:\n\n\n\n开启功能后，项目目录下会自动创建 server/index.ts 文件，可以在这个文件中编写自定义逻辑。Modern.js 提供了 Hook 与\nMiddleware 两类 API 来扩展 Web Server。\n\n\nHook#\n\nModern.js 提供的 Hook 用于控制 Web Server 中的内置逻辑，所有的页面请求都会经过 Hook。\n\n目前提供了两种 Hook，分别是 AfterMatch 和 AfterRender，可以用于修改渲染结果。可以在 server/index.ts 中这样写：\n\n\n\n项目在使用 Hook 时，应该有以下最佳实践：\n\n 1. 在 afterMatch 中做权限校验。\n 2. 在 afterMatch 做 Rewrite 和 Redirect。\n 3. 在 afterRender 中做 HTML 内容注入。\n\nNOTE\n\n详细 API 和更多用法可以查看 Hook。\n\n\nMiddleware#\n\n对于某些项目，可能在服务端有更多的需求，Modern.js 提供了 Middleware 为 Web Server 添加前置中间件。它只能运行在 Node\n环境下，因此如果项目被部署到其他环境中，如 Worker 环境，则不可以使用 Middleware。\n\nNOTE\n\n下一个大版本，Modern.js 将会使用新 Middleware 来替代该写法。\n\n推荐使用 UnstableMiddleware 处理页面请求。\n\nModern.js 默认提供了一套 API 供项目使用：\n\n\n\nNOTE\n\n详细 API 和更多用法可以查看 Middleware。\n\n项目在使用 Middleware 时，应该有以下最佳实践：\n\n 1. 在 Middleware 中可以直接操作原生的请求、响应对象，做数据打点、注入 SSR 渲染可能用到的 Node 服务（数据库、Redis 等）。\n 2. 在 Middleware 里可以做类似功能打标、爬虫优化等功能。\n 3. 在 Middleware 里可以无视后续默认渲染，自定义渲染流程。\n\n总的来说，CSR 项目中，使用 Hook 基本能满足简单场景的所有需求。SSR 项目中，可以使用 Middleware 做更复杂的 Node 扩展。\n\n\nUnstable Middleware#\n\nModern.js 将提供新 Middleware 为 Web Server 添加前置中间件，支持在处理页面的前后执行自定义逻辑。\n\n\n\nNOTE\n\n详细 API 和更多用法查看 UnstableMiddleware\n\n\n通过 BFF 托管页面请求#\n\n第二种方式，是利用 BFF 来托管页面渲染，这种方式下，所有的请求都会先打到 BFF 的服务。\n\n因为这种方式可以通过 BFF 统一控制所有请求的服务端逻辑。因此，它适用于服务端逻辑复杂，BFF 和页面需要公用服务端逻辑的场景。但它整体还是依托于\nModern.js 的 Web Server 运行，无法将逻辑运行在已有的服务上。\n\n使用这种方式，我们需要先通过 pnpm new 开启「BFF」功能。然后在配置文件中添加 bff.enableHandleWeb 配置：\n\n\n\n当该值设置为 true 时，页面请求流量也会经过 BFF，并且 Modern.js 内置的页面渲染的逻辑默认会作为 BFF 服务的最后一个中间件运行。\n\n\n完全自定义的 Web Server#\n\nNOTE\n\n敬请期待","routePath":"/guides/advanced-features/web-server","lang":"zh","toc":[{"text":"使用 API 扩展 Web Server","id":"使用-api-扩展-web-server","depth":2,"charIndex":389},{"text":"Hook","id":"hook","depth":3,"charIndex":831},{"text":"Middleware","id":"middleware","depth":3,"charIndex":1134},{"text":"Unstable Middleware","id":"unstable-middleware","depth":3,"charIndex":1689},{"text":"通过 BFF 托管页面请求","id":"通过-bff-托管页面请求","depth":2,"charIndex":1822},{"text":"完全自定义的 Web Server","id":"完全自定义的-web-server","depth":2,"charIndex":2155}],"domain":"","frontmatter":{"sidebar_position":16},"version":""},{"id":536,"title":"路径别名","content":"#\n\n路径别名（alias）允许开发者为模块定义别名，以便于在代码中更方便的引用它们。当你想要使用一个简短、易于记忆的名称来代替冗长复杂的路径时，这将非常有用。\n\n例如，假如你在项目中经常引用 src/common/request.ts 模块，你可以为它定义一个别名 @request，然后在代码中通过 ``\n来引用它，而不需要每次都写出完整的相对路径。同时，这也允许你将模块移动到不同的位置，而不需要更新代码中的所有 import 语法。\n\n在 Modern.js 中，你有两种方式可以设置路径别名:\n\n * 通过 tsconfig.json 中的 paths 配置。\n * 通过 source.alias 配置。\n\n\n通过 tsconfig.json 的 paths 配置#\n\n你可以通过 tsconfig.json 中的 paths 来配置别名，这是我们在 TypeScript 项目中推荐使用的方式，因为它可以解决路径别名的 TS\n类型问题。\n\n比如：\n\n\n\n以上配置完成后，如果你在代码中引用 @common/Foo.tsx, 则会映射到 /src/common/Foo.tsx 路径上。\n\nTIP\n\n你可以阅读 TypeScript - paths 文档来了解更多用法。\n\n\n通过 source.alias 配置#\n\nModern.js 提供了 source.alias 配置项，对应 webpack / Rspack 原生的 resolve.alias\n配置，你可以通过对象或者函数的方式来配置这个选项。\n\n\n使用场景#\n\n由于 tsconfig.json 的 paths 配置是写在静态 JSON 文件里的，因此它不具备动态性。\n\n而 source.alias 则可以弥补这一不足，你可以通过 JavaScript 代码来动态设置 source.alias（比如基于环境变量来设置）。\n\n\n对象用法#\n\n你可以通过对象的方式来配置 source.alias，其中的相对路径会被自动补全为绝对路径。\n\n比如：\n\n\n\n以上配置完成后，如果你在代码中引用 @common/Foo.tsx, 则会映射到 /src/common/Foo.tsx 路径上。\n\n\n函数用法#\n\n你也可以将 source.alias 配置为一个函数，拿到内置的 alias 对象，对其进行修改。\n\n比如：\n\n\n\n\n优先级#\n\ntsconfig.json 的 paths 配置的优先级高于 source.alias，当一个路径同时匹配到这两者定义的规则时，会优先使用\ntsconfig.json 的 paths 定义的值。\n\n你可以通过 source.aliasStrategy 来调整这两个选项的优先级。\n\n\n默认别名#\n\nModern.js 框架内置了以下别名:\n\n\n\n此外，在启用框架的 BFF 插件时，默认会添加 @api 别名。\n\n","routePath":"/guides/basic-features/alias","lang":"zh","toc":[{"text":"通过 `tsconfig.json` 的 `paths` 配置","id":"通过-tsconfigjson-的-paths-配置","depth":2,"charIndex":-1},{"text":"通过 `source.alias` 配置","id":"通过-sourcealias-配置","depth":2,"charIndex":-1},{"text":"使用场景","id":"使用场景","depth":3,"charIndex":661},{"text":"对象用法","id":"对象用法","depth":3,"charIndex":802},{"text":"函数用法","id":"函数用法","depth":3,"charIndex":932},{"text":"优先级","id":"优先级","depth":3,"charIndex":998},{"text":"默认别名","id":"默认别名","depth":2,"charIndex":1146}],"domain":"","frontmatter":{"sidebar_position":4},"version":""},{"id":537,"title":"使用 CSS Modules","content":"#\n\nCSS Modules 让我们能以模块化的方式编写 CSS 代码，并且可以在 JavaScript 文件中导入和使用这些样式。使用 CSS Modules\n可以自动生成唯一的类名，隔离不同模块之间的样式，避免类名冲突。\n\nModern.js 默认支持使用 CSS Modules，无需添加额外的配置。我们约定使用 [name].module.css 文件名来启用 CSS\nModules。\n\n以下样式文件会被视为 CSS Modules：\n\n * *.module.scss\n * *.module.less\n * *.module.css\n\n\n示例#\n\n * 编写样式：\n\n\n\n * 使用样式：\n\n\n\n\n为所有样式文件启用 CSS Modules#\n\n在默认情况下，只有 *.module.css 结尾的文件才被视为 CSS Modules 模块。\n\n如果你想将源码目录下的所有 CSS 文件当做 CSS Modules 模块进行处理，可以通过开启\noutput.disableCssModuleExtension 来实现，比如：\n\n\n\n设置后，以下两个文件都会被视为 CSS Modules：\n\n\n\nTIP\n\n我们不推荐开启此配置项，因为开启 disableCssModuleExtension 后，CSS Modules 文件和普通 CSS\n文件无法得到明确的区分，不利于长期维护。\n\n\n为指定的样式文件启用 CSS Modules#\n\n在默认情况下，只有 *.module.css 结尾的文件才被视为 CSS Modules 模块。\n\n如果你想只为一些指定的样式文件启用 CSS Modules，可以通过配置 output.cssModules 来实现，比如：\n\n\n\n\n自定义类名#\n\n自定义 CSS Modules 生成的类名也是我们比较常用的功能，你可以使用 output.cssModuleLocalIdentName 来进行配置。\n\n\n\n如果你需要自定义 CSS Modules 的其他配置，可以通过 tools.cssLoader 进行设置。\n\n\n添加类型声明#\n\n当你在 TypeScript 代码中引用 CSS Modules 时，TypeScript 可能会提示该模块缺少类型定义：\n\n\n\n此时你需要为 CSS Modules 添加类型声明文件，请在项目中创建 src/global.d.ts 文件，并添加相应的类型声明：\n\n\n\n如果你开启了 disableCssModuleExtension 配置值，还需要添加以下类型：\n\n\n\n添加类型声明后，如果依然存在上述错误提示，请尝试重启当前 IDE，或者调整 global.d.ts 所在的目录，使 TypeScript 能够正确识别类型定义。\n\n\n生成准确的类型定义#\n\n上述方法虽然可以解决 CSS Modules 在 TypeScript 中的类型问题，但是无法准确地提示出某个 CSS 文件导出了哪些类名。\n\nBuilder 支持为 CSS Modules 生成准确的类型声明，你只需要开启 output.enableCssModuleTSDeclaration\n配置项，再执行构建命令，Builder 就会为项目中所有的 CSS Modules 文件生成相应的类型声明文件。\n\n\n\n\n示例#\n\n例如某个文件夹下面有 src/index.ts 和 src/index.module.scss 两个文件：\n\n\n\n\n\n执行构建命令后，会自动生成 src/index.module.scss.d.ts 类型声明文件：\n\n\n\n此时再打开 src/index.ts 文件，可以看到 styles 对象已经具备了准确的类型。\n\n\n相关配置#\n\n在上述例子中，src/index.module.scss.d.ts 是编译生成的代码，你可以选择将它们提交到 Git 仓库里，也可以选择在 .gitignore\n文件中忽略它们：\n\n\n\n此外，如果生成的代码导致了 ESLint 报错，你也可以将上述配置添加到 .eslintignore 文件里。","routePath":"/guides/basic-features/css-modules","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":275},{"text":"为所有样式文件启用 CSS Modules","id":"为所有样式文件启用-css-modules","depth":2,"charIndex":305},{"text":"为指定的样式文件启用 CSS Modules","id":"为指定的样式文件启用-css-modules","depth":2,"charIndex":599},{"text":"自定义类名","id":"自定义类名","depth":2,"charIndex":741},{"text":"添加类型声明","id":"添加类型声明","depth":2,"charIndex":885},{"text":"生成准确的类型定义","id":"生成准确的类型定义","depth":2,"charIndex":1163},{"text":"示例","id":"示例-1","depth":3,"charIndex":1385},{"text":"相关配置","id":"相关配置","depth":3,"charIndex":1551}],"domain":"","frontmatter":{"sidebar_position":14},"version":""},{"id":538,"title":"样式开发","content":"#\n\nModern.js 内置多种常用的 CSS 开发方案，包括 Less / Sass / Stylus 预处理器、PostCSS、CSS\nModules、CSS-in-JS 和 Tailwind CSS。\n\n\n使用 Less、Sass 和 Stylus#\n\nModern.js 内置了社区流行的 CSS 预处理器，包括 Less 和 Sass。\n\n默认情况下，你不需要对 Less 和 Sass 进行任何配置。如果你有自定义 loader 配置的需求，可以通过配置 tools.less、tools.sass\n来进行设置。\n\n你也可以在 Modern.js 中使用 Stylus，只需要安装 Rsbuild 提供的 Stylus 插件即可，使用方式请参考 Stylus 插件。\n\n\n使用 PostCSS#\n\nModern.js 内置了 PostCSS 来转换 CSS 代码。\n\n请阅读 Rsbuild - 使用 PostCSS 了解更多用法。\n\n\n使用 CSS Modules#\n\n请阅读 使用 CSS Modules 章节来了解 CSS Modules 的完整用法。\n\n\n使用 CSS-in-JS#\n\nCSS-in-JS 是一种可以将 CSS 样式写在 JS 文件里的技术。\n\nModern.js 集成了社区常用的 CSS-in-JS 实现库 styled-components，它使用 JavaScript 的新特性 Tagged\ntemplate 编写组件的 CSS 样式。可以直接从 @modern-js/runtime/styled 引入 styled-components 的 API\n进行使用。\n\n当需要编写一个内部字体为红色的 div 组件时，可以如下实现：\n\n\n\n当需要根据组件的 props 动态设置组件样式时，例如 props 的属性 primary 为 true 时，按钮的颜色为白色，其他情况为红色，实现代码如下：\n\n\n\n关于 styled-components 的更多用法，请参考 styled-components 官网。\n\nModern.js 内部集成了 Babel 的 babel-plugin-styled-components 插件，你可以通过\ntools.styledComponents 对插件进行配置。\n\n提示\n\n如果需要使用 styled-jsx、Emotion 等其他 CSS-in-JS 库，需要先安装对应库的依赖。具体使用方式请参考对应库的官网。\n\n\n使用 Tailwind CSS#\n\nTailwind CSS 是一个以 Utility Class 为基础的 CSS 框架和设计系统，可以快速地为组件添加常用样式，同时支持主题样式的灵活扩展。\n\n在 Modern.js 中使用 Tailwind CSS，你只需要按照以下步骤操作：\n\n 1. 在项目根目录下执行 pnpm run new，按照如下进行选择：\n\n\n\n成功开启后，你会看到 package.json 中新增了 tailwindcss 和 @modern-js/plugin-tailwindcss 依赖。\n\n 2. 在 modern.config.ts 中注册 Tailwind 插件:\n\n\n\n 3. 创建 index.css 文件，添加以下代码：\n\n\n\nINFO\n\n根据需求不同，你可以选择性地导入 Tailwind CSS 提供的 CSS 样式。请参考 @tailwind 文档 来了解 @tailwind 指令的详细用法。\n\n 4. 引用 index.css 文件，比如在入口的根组件 src/App.jsx 添加如下代码：\n\n\n\n 5. 然后即可在各个组件中使用 Tailwind CSS 提供的 Utility Class 了：\n\n\n\n\n配置 Tailwind CSS#\n\n在 Modern.js 中，你有两种方式来配置 Tailwind CSS：\n\n 1. 使用 tailwind.config.{ts,js} 文件，该用法与 Tailwind CSS 的官方用法一致，请参考 \"Tailwind CSS -\n    Configuration\" 来了解更多用法。\n\n\n\nTIP\n\n请升级 Modern.js 到 >= 2.33.0 版本，以支持自动读取 tailwind.config.{ts,js} 文件。\n\n 2. 使用 tools.tailwindcss 配置项，这是旧版本的用法，我们更推荐使用 tailwind.config.{ts,js} 文件进行配置。\n\n\n\n如果你同时使用了 tailwind.config.{ts,js} 文件和 tools.tailwindcss 选项，那么 tools.tailwindcss\n定义的配置会优先生效，并覆盖 tailwind.config.{ts,js} 中定义的内容。\n\n\nTailwind CSS 自动补全#\n\nTailwind CSS 官方提供了 Tailwind CSS IntelliSense 插件，用于在 VS Code 中自动补全 Tailwind CSS 的\nclass names、CSS functions 和 directives。\n\n你可以参考以下步骤来启动自动补全功能：\n\n 1. 在 VS Code 中安装 Tailwind CSS IntelliSense 插件。\n 2. 如果项目的根目录没有 tailwind.config.{ts,js} 文件，那么你需要创建该文件，并写入当前项目的 Tailwind CSS 配置，否则\n    IDE 插件将无法正确生效。\n\n\nTailwind CSS 版本#\n\nModern.js 同时支持 Tailwind CSS v2 和 v3 版本，框架会识别项目 package.json 中的 tailwindcss\n依赖版本，并启用相应的配置。默认情况下，我们会为你安装 Tailwind CSS v3 版本。\n\n如果你的项目仍在使用 Tailwind CSS v2，我们推荐你升级到 v3 以支持 JIT 等能力。关于 Tailwind CSS v2 与 v3\n版本之间的差异，请参考以下文章：\n\n * Tailwind CSS v3.0\n * Upgrade Guide\n\n\n浏览器兼容性#\n\nTailwind CSS v2 和 v3 均不支持 IE 11 浏览器，相关背景请参考：\n\n * Tailwind CSS v3 - Browser Support。\n * Tailwind CSS v2 - Browser Support\n\n如果你在 IE 11 浏览器上使用 Tailwind CSS，可能会出现部分样式不可用的现象，请谨慎使用。","routePath":"/guides/basic-features/css","lang":"zh","toc":[{"text":"使用 Less、Sass 和 Stylus","id":"使用-lesssass-和-stylus","depth":2,"charIndex":106},{"text":"使用 PostCSS","id":"使用-postcss","depth":2,"charIndex":342},{"text":"使用 CSS Modules","id":"使用-css-modules","depth":2,"charIndex":425},{"text":"使用 CSS-in-JS","id":"使用-css-in-js","depth":2,"charIndex":488},{"text":"使用 Tailwind CSS","id":"使用-tailwind-css","depth":2,"charIndex":1053},{"text":"配置 Tailwind CSS","id":"配置-tailwind-css","depth":3,"charIndex":1583},{"text":"Tailwind CSS 自动补全","id":"tailwind-css-自动补全","depth":3,"charIndex":2031},{"text":"Tailwind CSS 版本","id":"tailwind-css-版本","depth":3,"charIndex":2344},{"text":"浏览器兼容性","id":"浏览器兼容性","depth":3,"charIndex":2619}],"domain":"","frontmatter":{"sidebar_position":1},"version":""},{"id":539,"title":"数据获取","content":"#\n\nModern.js 中提供了开箱即用的数据获取能力，开发者可以通过这些 API，在项目中获取数据。\n\n需要注意的是，这些 API 并不帮助应用发起请求，而是帮助开发者更好地管理数据，提升项目的性能。\n\n\nData Loader(推荐)#\n\nModern.js 推荐使用约定式路由做路由的管理，通过 Modern.js 的约定式（嵌套）路由，每个路由组件(layout.ts 或\npage.ts)可以有一个同名的 data 文件，该 data 文件可以导出一个 loader 函数，函数会在组件渲染之前执行，为路由组件提供数据。\n\nINFO\n\nModern.js v1 支持通过 useLoader 获取数据，这已经不是我们推荐的用法。除迁移过程外，不推荐两者混用。\n\nWARNING\n * 在之前的版本中，Modern.js Data Loader 是定义在 loader 文件中的，在之后的版本中，我们推荐定义在 data\n   文件中，同时我们会保持对 loader 文件的兼容。\n * 在 data 文件中，对应的 loader 需要具名导出。\n\n\n基础示例#\n\n路由组件如 layout.ts 或 page.ts，可以定义同名的 data 文件，data 文件中导出一个 loader\n函数，该函数提供组件所需的数据，然后在路由组件中通过 useLoaderData 函数获取数据，如下面示例：\n\n\n\n在文件中定义以下代码：\n\n\n\n\n\nCAUTION\n\n这里路由组件和 data 文件共享类型，要使用 import type 语法。\n\n在 CSR 环境下，loader 函数会在客户端执行，loader 函数内可以使用浏览器的 API（但通常不需要，也不推荐）。\n\n在 SSR 环境下，不管是首屏，还是在客户端的导航，loader 函数只会在服务端执行，这里可以调用任意的 Node.js\nAPI，同时这里使用的任何依赖和代码都不会包含在客户端的 bundle 中。\n\nINFO\n\n在以后的版本中，Modern.js 可能会支持在 CSR 环境下，loader 函数也在服务端运行，以提高性能和安全性，所以这里建议尽可能地保证 loader\n的纯粹，只做数据获取的场景。\n\n当在客户端导航时，基于 Modern.js 的约定式路由，所有的 loader 函数会并行执行（请求），即当访问 /user/profile 时，/user 和\n/user/profile 下的 loader 函数都会并行执行（请求），以提高客户端的性能。\n\n\nloader 函数#\n\nloader 函数有两个入参：\n\nparams#\n\n当路由文件通过 [] 时，会作为动态路由，动态路由片段会作为参数传入 loader 函数：\n\n\n\n当访问 /user/123 时，loader 函数的参数为 { params: { id: '123' } }。\n\nrequest#\n\nrequest 是一个 Fetch Request 实例。\n\n一个常见的使用场景是通过 request 获取查询参数：\n\n\n\n返回值#\n\nloader 函数的返回值可以是任何可序列化的内容，也可以是一个 Fetch Response 实例：\n\n\n\n默认情况下，loader 返回的响应 Content-type 是 application/json，status 为 200，你可以通过自定义\nResponse 来设置：\n\n\n\n\n请求 API#\n\nModern.js 对 fetch API 做了 polyfill, 用于发起请求，该 API 与浏览器的 fetch API 一致，但是在服务端也能使用该\nAPI 发起请求，这意味着不管是 CSR 还是 SSR，都可以使用统一的 fetch API 进行数据获取：\n\n\n\n\n错误处理#\n\n基本用法#\n\n在 loader 函数中，可以通过 throw error 或者 throw response 的方式处理错误，当 loader\n函数中有错误被抛出时，Modern.js 会停止执行当前 loader 中的代码，并将前端 UI 切换到定义的 ErrorBoundary 组件：\n\n\n\n实践#\n\n在 SSR 项目中你可以通过在 data loader 中 throw response 的方式，控制页面的状态码，展示对应的\nUI，如以下示例，整条路由路线中有一个 loader throw response，页面的状态码将与这个 response 保持一致，页面的 UI 也会切换为\nErrorBoundary:\n\n\n\n\n获取上层组件的数据#\n\n很多场景下，子组件需要获取到祖先组件 loader 中的数据，你可以通过 useRouteLoaderData 方便地获取到祖先组件的数据：\n\n\n\nuserRouteLoaderData 接受一个参数 routeId，在使用约定式路由时，Modern.js 会为你自动生成routeId，routeId\n的值是对应组件相对于 src/routes 的路径，如上面的例子中，子组件想要获取 routes/user/layout.tsx 中 loader\n返回的数据，routeId 的值就是 user/layout。\n\n在多入口（MPA） 场景下，routeId 的值需要加上对应入口的名称，入口名称非指定情况下一般是入口的目录名，如以下目录结构：\n\n\n\n如果想获取 entry1/routes/layout.tsx 中 loader 返回的数据，routeId 的值就是 entry1_layout。\n\n\nLoading UI (Experimental)#\n\nINFO\n\n此功能目前是实验性质，后续 API 可能有调整。\n\n创建 user/layout.data.ts，并添加以下代码：\n\n\n\n在 user/layout.tsx 中添加以下代码：\n\n\n\nINFO\n\nAwait 组件的具体用法请查看 Await\n\ndefer 的具体用法请查看 defer\n\n\n数据缓存#\n\n在路由导航时，Modern.js 只会加载路由变化的部分的数据，如当前路由是 a/b，a 路径对应的 Data Loader 已经执行过，当从 /a/b 跳转到\n/a/c时，a 路径对应的 Data Loader 不会重新执行，c 路径对应的 Data Loader 会执行，并获取了数据。\n\n即 Modern.js 在数据加载时，只会加载路由变化部分的数据，这种默认的优化策略避免了无效重复数据的请求。\n\n你可能会问，如何更新 a 路径对应 Data Loader 的数据？\n\n在 Modern.js 中，以下几种情况，Modern.js 会重新加载对应路由路径的数据：\n\n 1. 在 Data Action 触发后\n 2. URL 上搜索参数发生了变化\n 3. 用户点击的链接与当前页面的 URL 相同\n 4. 在路由组件中定义了 shouldRevalidate 函数，该函数返回 true\n\nINFO\n\n如果你在路由上定义了 shouldRevalidate 函数，会先检查该函数，判断是否需要重新加载数据。\n\n\nshouldRevalidate#\n\nWARNING\n\n目前 shouldRevalidate 会在 csr 和 streaming ssr 下生效。\n\n在每个路由组件(layout.tsx，page.tsx, $.tsx)中，我们可以导出一个 shouldRevalidate\n函数，在每次项目中的路由变化时，这个函数会触发，该函数可以控制要重新加载哪些路由中的数据，当这个函数返回 true， 对应路由的数据就会重新加载。\n\n\n\nINFO\n\nshouldRevalidate 函数的更多信息可以参考 react-router\n\n\nClient Loader#\n\nINFO\n 1. 这个 feature 需要 x.36.0 以上版本，推荐使用框架最新版本\n 2. 只有 SSR 项目中有 Client Loader，CSR 项目中可以认为默认就是 Client Loader\n 3. 这个特性可以渐进使用，并不是每个项目都需要，具体可以看下面文档适用场景的说明\n\n适用场景#\n\n在 SSR 项目中，Data Loader 中的代码只会在服务端执行，当客户端进行 SPA 导航时， 框架会发送一个 http 请求到 SSR 服务，触发\nData Loader 的执行， 但有些场景下，我们可能期望在客户端发送的请求不经过 SSR 服务，直接请求数据源。\n\nINFO\n\n为什么 SSR 项目中 Data Loader 只会在服务端执行可参考 常见问题\n\n例如以下场景：\n\n 1. 在 SSR 降级时，不希望框架向 SSR 服务发送请求获取数据，希望能直接请求后端服务。\n 2. 在客户端有一些缓存，不希望请求 SSR 服务获取数据。\n\n这些场景下，我们可以使用 Client Loader。添加 Client Loader 后，会调用 Client Loader 中的代码，而不再像 SSR\n服务发送请求：\n\n 1. SSR 降级为 CSR 后，在客户端获取数据时，会执行 Client Loader 代替框架发送请求到 Data Loader（Server）\n    获取数据。\n\n 2. SSR 项目进行 SPA 跳转时，获取数据，会执行 Clinet Loader。\n\n使用方式#\n\nWARNING\n\n要使用 client loader，必须有对应的 server loader(data loader)\n\n 1. 如果原有项目中 loader 是以 .loader.ts 文件为约定的，需要修改 .loader.ts 为 .data.ts（如果 loader 是在\n    .data.ts 文件中定义，忽略这个步骤）。\n\n * 将 .loader.ts 文件重命名为 .data.ts\n * 将文件中的代码做以下改动：\n\n\n\n 2. 添加 client loader，client loader API 中的入参和 data loader 是一致的。\n\n\n\n\n错误用法#\n\n 1. loader 中只能返回可序列化的数据，在 SSR 环境下，loader 函数的返回值会被序列化为 JSON\n    字符串，然后在客户端被反序列化为对象。因此，loader 函数中不能返回不可序列化的数据（如函数）。\n\nWARNING\n\n目前 CSR 下没有这个限制，但我们强烈推荐你遵循该限制，且未来我们可能在 CSR 下也加上该限制。\n\n\n\n 2. Modern.js 会帮你调用 loader 函数，你不应该自己调用 loader 函数：\n\n\n\n 3. 不能从路由组件中引入 loader 文件，也不能从 loader 文件引入路由组件中的变量，如果需要共享类型的话，应该使用 import type\n\n\n\n 4. 在服务端运行时，loader 函数会被打包为一个统一的 bundle，所以我们不推荐服务端的代码使用 __filename 和 __dirname。\n\n\n常见问题#\n\n 1. loader 和 BFF 函数的关系\n\n在 CSR 项目中，loader 在客户端执行，在 loader 可以直接调用 BFF 函数进行接口请求。\n\n在 SSR 项目中，每个 loader 也是一个服务端接口，我们推荐使用 loader 替代 http method 为 get 的 BFF\n函数，作为接口层，避免多一层转发和执行。\n\n 2. 为什么 SSR 项目中 Data Loader 只会在服务端执行？\n\n我们设计 SSR 项目中 Data Loader 只会在服务端，在客户端渲染时，由框架发送请求到服务端主要有以下原因：\n\n * 简化使用方式，有 server loader 后，SSR 阶段和 CSR 阶段数据获取的操作都可以放在 server loader\n   中（真实的调用由框架层去做），server loader 中的代码无需关心是在浏览器环境中还是服务端环境中。\n\n * 减少网络请求的数据，作为 BFF 层，可以减少前端运行时需要获取的数据。\n\n * 减少客户端 bundle 体积，将逻辑代码及其依赖，从客户端移动到了服务端。\n\n * 提高可维护性，将逻辑代码移动到服务端，减少了数据逻辑对前端 UI 的直接影响。此外，也避免了客户端 bundle 中误引入服务端依赖，或服务端\n   bundle 中误引入客户端依赖的问题。\n\n\nuseLoader（旧版）#\n\nuseLoader 是 Modern.js 老版本中的 API。该 API 是一个 React Hook，专门提供给 SSR\n应用使用，让开发者能同构的在组件中获取数据。\n\nTIP\n\nCSR 的项目没有必要使用 useLoader 获取数据。\n\n以下是一个最简单的例子：\n\n\n\n上述代码启动后，访问页面。可以看到在终端输出了日志，而在浏览器终端却没有打印日志。\n\n这是因为 Modern.js 在服务端渲染时，在会收集 useLoader 返回的数据，并将数据注入到响应的 HTML 中。如果 SSR 渲染成功，在 HTML\n中可以看到如下代码片段：\n\n\n\n在这全局变量中，记录了每一份数据，而在浏览器端渲染的过程中，会优先使用这份数据。如果数据不存在，则会重新执行 useLoader 函数。\n\nNOTE\n\n在构建阶段，Modern.js 会自动为每个 useLoader 生成一个 Loader ID，并注入到 SSR 和 CSR 的 JS Bundle\n中，用来关联 Loader 和数据。\n\n相比于 Next.js 中的 getServerSideProps，在渲染前预先获取数据。使用 useLoader，可以在组件中获取局部 UI\n所需要的数据，而不用将数据层层传递。同样，也不会因为不同路由需要不同数据请求，而在最外层的数据获取函数中添加冗余的逻辑。当然 useLoader\n也存在一些问题，例如服务端代码 Treeshaking 困难，服务端需要多一次预渲染等。\n\nModern.js 在新版本中，设计了全新的 Loader 方案。新方案解决了这些问题，并能够配合嵌套路由，对页面性能做优化。\n\nNOTE\n\n详细 API 可以查看 useLoader。","routePath":"/guides/basic-features/data/data-fetch","lang":"zh","toc":[{"text":"Data Loader(推荐)","id":"data-loader推荐","depth":2,"charIndex":104},{"text":"基础示例","id":"基础示例","depth":3,"charIndex":480},{"text":"`loader` 函数","id":"loader-函数","depth":3,"charIndex":-1},{"text":"`params`","id":"params","depth":4,"charIndex":-1},{"text":"`request`","id":"request","depth":4,"charIndex":-1},{"text":"返回值","id":"返回值","depth":4,"charIndex":1292},{"text":"请求 API","id":"请求-api","depth":3,"charIndex":1444},{"text":"错误处理","id":"错误处理","depth":3,"charIndex":1591},{"text":"基本用法","id":"基本用法","depth":4,"charIndex":1598},{"text":"实践","id":"实践","depth":4,"charIndex":1747},{"text":"获取上层组件的数据","id":"获取上层组件的数据","depth":3,"charIndex":1915},{"text":"Loading UI (Experimental)","id":"loading-ui-experimental","depth":3,"charIndex":2330},{"text":"数据缓存","id":"数据缓存","depth":3,"charIndex":2508},{"text":"`shouldRevalidate`","id":"shouldrevalidate","depth":3,"charIndex":-1},{"text":"Client Loader","id":"client-loader","depth":3,"charIndex":3243},{"text":"适用场景","id":"适用场景","depth":4,"charIndex":3409},{"text":"使用方式","id":"使用方式","depth":4,"charIndex":3913},{"text":"错误用法","id":"错误用法","depth":3,"charIndex":4210},{"text":"常见问题","id":"常见问题","depth":3,"charIndex":4610},{"text":"useLoader（旧版）","id":"useloader旧版","depth":2,"charIndex":5202}],"domain":"","frontmatter":{"title":"数据获取","sidebar_position":3},"version":""},{"id":540,"title":"数据写入","content":"#\n\n在 Data Loader 章节中，介绍了 Modern.js 获取数据的方式，你可能会遇到两个问题：\n\n 1. 如何更新 Data Loader 中的数据？\n 2. 如何将新的数据传递到服务器?\n\nEdenX 对此的解决方案是 DataAction。\n\n\n基本示例#\n\nData Action 和 Data Loader 一样，也是基于约定式路由的，通过 Modern.js\n的约定式（嵌套）路由，每个路由组件(layout.ts，page.ts 或 $.tsx)可以有一个同名的 data 文件，data 文件中可以导出一个命名为\naction 的函数。\n\n\n\n在文件中定义以下代码：\n\n\n\n\n\n这里当执行 submit 后，会触发定义的 action 函数；在 action 函数中，可以通过 request\n（request.json，request.formData）获取提交的数据，获取数据后，再发送数据到服务端。\n\n而 action 函数执行完，会执行 loader 函数代码，并更新对应的数据和视图。\n\n\n\n\n为什么要提供 Data Action#\n\nModern.js 中提供 Data Action 主要是为了使 UI 和服务器的状态能保持同步，通过这种方式可以减少状态管理的负担，\n传统的状态管理方式，会在客户端和远程分别持有状态：\n\n\n\n而在 Modern.js 中，我们希望通过 Loader 和 Action 帮助开发者自动的同步客户端和服务端的状态：\n\n\n\n如果项目中组件共享的数据主要来自于服务端的状态，则无需在项目引入客户端状态管理库。可以使用 Data Loader 请求数据，通过\nuseRouteLoaderData 在子组件中共享数据，使用 Data Action 修改和同步服务端的状态。\n\n\naction 函数#\n\n与 loader 函数一样，action 函数有两个入参，params 和 request：\n\n\nparams#\n\n当路由文件通过 [] 时，会作为动态路由，动态路由片段会作为参数传入 action 函数：\n\n\n\n当访问 /user/123 时，action 函数的参数为 { params: { id: '123' } }。\n\n\nrequest#\n\nrequest 是一个 Fetch Request 实例。\n\n通过 request，可以在 action 函数中获取到客户端提交的数据，如\nrequest.json()，request.formData()，request.json() 等， 具体应该使用哪个 API，请参考数据类型。\n\n\n\n\n返回值#\n\naction 函数的返回值可以是任何可序列化的内容，也可以是一个 Fetch Response 实例， 可以通过 useActionData 访问\nresponse 中内容。\n\n\nuseSubmit 和 useFetcher#\n\n\n区别#\n\n你可以通过 useSubmit 或 useFetcher 调用 action，它们的区别是通过 useSubmit 调用 action，会触发浏览器的导航，通过\nuseFetcher 则不会触发浏览器的导航。\n\nuseSubmit:\n\n\n\nuseFetcher:\n\n\n\nsubmit 函数有两个入参，method 和 action，method 相当于表单提交时的 method，大部分写入数据的场景下，method 可以传入\npost， action 用来指定触发哪个路由组件的 action，如果未传入 action 入参，默认会触发当前路由组件的 action，即\nuser/page.tsx 组件或子组件中执行 submit， 会触发 user/page.data.ts 中定义的 action。\n\nINFO\n\n这两个 API 更多的信息可参考相关文档：\n\n * useSubmit\n * useFetcher\n\n\n数据类型#\n\nsubmit 函数的第一个入参，可以接受不同类型的值。 如 FormData：\n\n\n\n或 URLSearchParams 类型的值：\n\n\n\n或任意 URLSearchParams 构造函数可接受的值\n\n\n\n默认情况下，如果 submit 函数中的第一个入参是一个对象，对应的数据会被 encode 为 formData：\n\n\n\n也可以指定为 json 编码：\n\n\n\n或提交纯文本：\n\n\n\n\nCSR 和 SSR#\n\n与 Data Loader 一样，SSR 项目中，Data Action 是在服务端执行的（框架会自动发请求触发 Data Action），而在 CSR\n项目中，Data Action 是在客户端执行的。","routePath":"/guides/basic-features/data/data-write","lang":"zh","toc":[{"text":"基本示例","id":"基本示例","depth":2,"charIndex":131},{"text":"为什么要提供 Data Action","id":"为什么要提供-data-action","depth":2,"charIndex":465},{"text":"`action` 函数","id":"action-函数","depth":2,"charIndex":-1},{"text":"`params`","id":"params","depth":3,"charIndex":-1},{"text":"`request`","id":"request","depth":3,"charIndex":-1},{"text":"返回值","id":"返回值","depth":3,"charIndex":1107},{"text":"useSubmit 和 useFetcher","id":"usesubmit-和-usefetcher","depth":2,"charIndex":1203},{"text":"区别","id":"区别","depth":3,"charIndex":1229},{"text":"数据类型","id":"数据类型","depth":3,"charIndex":1646},{"text":"CSR 和 SSR","id":"csr-和-ssr","depth":2,"charIndex":1848}],"domain":"","frontmatter":{"title":"数据写入","sidebar_position":4},"version":""},{"id":541,"title":"部署应用","content":"#\n\n目前，Modern.js 提供了两种部署方式：\n\n * 你可以将应用自行托管在包含 Node.js 环境的容器中，这为应用提供了部署的灵活性。\n * 你也可以通过平台部署应用，目前 Modern.js 官方支持了 Netlify 和 Vercel 平台。\n\nINFO\n\n目前 Modern.js 仅支持在 Node.js 环境中运行，未来将提供更多运行时环境的支持。\n\n\n构建部署产物#\n\n执行 modern deploy 命令将自动输出部署产物。此过程包括优化 Bundler\n构建产物及产物依赖，检测当前部署平台，并自动生成可以在该平台运行的产物。 如果你希望在本地生成并测试特定部署平台的产物，可以通过设置环境变量来指定平台:\n\n\n\nINFO\n\n在 Modern.js 官方支持的部署平台中部署时，无需指定环境变量。\n\n\nNode.js#\n\n\n单仓库项目#\n\n默认情况下，如果未检测到 Modern.js 支持的部署平台，Modern.js 将生成可以在 Node.js 环境下运行的部署产物。\n\n你可以使用以下命令构建项目：\n\n\n\n当执行 modern deploy 命令时，Modern.js 将生成可执行的部署产物，并在控制台输出以下内容：\n\n\n\n现在，你可以通过执行 node .output/index 命令来运行服务器。在 .output/static\n目录中，存放了页面运行所需的静态资源，你可以选择将这些资源上传到 CDN 以提高访问速度。\n\nINFO\n\n默认情况下，运行 Modern.js 服务器时会监听 8080 端口，如果你想修改监听的端口，可以指定 PORT 环境变量：\n\n\n\n\nMonorepo#\n\n对于 Monorepo 项目，除了需要构建当前的项目外，还需要构建当前项目依赖的仓库中其他子项目。\n\n假设当前项目的 package.json 中的 name 为 app，以 pnpm 作为 Monorepo 管理工具为例，你可以在项目 package.json\n中添加以下命令用于构建：\n\n\n\n如果你使用 rush 作为 Monorepo 管理工具，可以在 package.json 中添加以下命令：\n\n\n\n构建完成后，框架会将项目中所有的依赖生成在 .output/node_modules 目录下。你同样可以使用 node .output/index 运行\nModern.js 服务器。\n\n\nNetlify#\n\nNetlify 是一个流行的 Web 开发平台，专为构建、发布和维护现代 Web 项目而设计。在 Netlify 上部署，通常需要配置 netlify.toml\n文件，你可以根据项目复杂度，渐进地配置该文件。\n\n\n纯前端项目#\n\n在当前项目的根目录添加 netlify.toml 文件：\n\n\n\n在 netlify.toml 中添加以下内容：\n\n\n\n在 Netlify 平台上添加项目，部署即可。\n\n\n全栈项目#\n\n全栈项目是指使用了自定义 Web Server、SSR、BFF 的项目，这些项目需要部署在 Netlify Functions 上。你需要基于上述的\nnetlify.toml 文件，添加以下配置：\n\n\n\nINFO\n\n目前 Modern.js 还不支持在 Netlify Edge Functions 进行部署，我们将在后续的版本中支持。\n\n\nMonorepo 项目#\n\nINFO\n\n以下指南主要针对于全栈项目，对于纯 CSR 的项目，只需要按照纯前端项目部署即可。\n\n对于 Monorepo 项目，除了需要构建当前的项目外，还需要构建当前项目依赖的仓库中其他子项目。这里以一个 pnpm Monorepo 仓库为例，在\nNetlify 上对 Monorepo 项目进行部署。\n\n假设 Monorepo 仓库目录结构如下：\n\n\n\n你需要在 Netlify 平台上配置 Base directory 为 packages/app:\n\n在 packages/app/package.json 中添加以下 script，在执行 app 仓库的部署命令之前，先执行 workspace\n中其他仓库的构建：\n\n\n\n在 netlify.toml 配置构建命令：\n\n\n\n提交你的代码，使用 Netlify 平台部署即可。\n\n\nVercel#\n\nVercel 是一个面向现代 Web 应用的部署平台，它提供了丰富的功能，支持部署静态网站，服务端渲染应用等。在 Vercel 上部署，通常需要配置\nvercel.json 文件，你可以根据项目复杂度，渐进地配置该文件。\n\n\n纯前端项目#\n\n在当前项目的根目录添加 vercel.json 文件：\n\n\n\n在 vercel.json 中添加以下内容：\n\n\n\n提交你的项目到 git，在 Vercel 平台上选择 Frmeworkwork Preset 为 Other，部署即可。\n\n\n全栈项目#\n\n全栈项目是指使用了自定义 Web Server、SSR、BFF 的项目，这些项目需要部署在 Vercel Functions 上。\n\n全栈项目除了按照纯前端项目的方式配置 vercel.json 外，有两点需要注意：\n\n 1. 当前，Modern.js 还不支持在 Vercel 平台上部署 BFF 项目，我们将在后续的版本中支持。\n 2. Vercel 平台部署时，默认 node 运行时为 20.x，部署全栈项目时建议选择 18.x，具体原因详见Serverless Function\n    contains invalid runtime error，你可以修改 package.json 指定版本：\n\n\n\n\nMonorepo 项目#\n\nINFO\n\n以下指南主要针对于全栈项目，对于纯 CSR 的项目，只需要按照纯前端项目部署即可。\n\n对于 Monorepo 项目，除了需要构建当前的项目外，还需要构建当前项目依赖的仓库中其他子项目。这里以一个 pnpm Monorepo 仓库为例，在\nVercel 上对 Monorepo 项目进行部署。\n\n假设 Monorepo 仓库目录结构如下：\n\n\n\n首先，你需要在 Vercel 平台上配置 Root Directory 为 packages/app:\n\n将 Node.js 运行时设置为 18.x：\n\n\n\n在 packages/app/package.json 中添加以下 script，在执行 app 仓库的部署命令之前，先执行 workspace\n中其他仓库的构建：\n\n\n\n在 packages/app/vercel.json 文件中添加以下内容：\n\n\n\n提交你的代码，使用 Vercel 平台部署即可。","routePath":"/guides/basic-features/deploy","lang":"zh","toc":[{"text":"构建部署产物","id":"构建部署产物","depth":2,"charIndex":188},{"text":"Node.js","id":"nodejs","depth":2,"charIndex":366},{"text":"单仓库项目","id":"单仓库项目","depth":3,"charIndex":377},{"text":"Monorepo","id":"monorepo","depth":3,"charIndex":708},{"text":"Netlify","id":"netlify","depth":2,"charIndex":1018},{"text":"纯前端项目","id":"纯前端项目","depth":3,"charIndex":1135},{"text":"全栈项目","id":"全栈项目","depth":3,"charIndex":1228},{"text":"Monorepo 项目","id":"monorepo-项目","depth":3,"charIndex":1406},{"text":"Vercel","id":"vercel","depth":2,"charIndex":1790},{"text":"纯前端项目","id":"纯前端项目-1","depth":3,"charIndex":1912},{"text":"全栈项目","id":"全栈项目-1","depth":3,"charIndex":2040},{"text":"Monorepo 项目","id":"monorepo-项目-1","depth":3,"charIndex":2356}],"domain":"","frontmatter":{"sidebar_position":15},"version":""},{"id":542,"title":"环境变量","content":"#\n\nModern.js 提供了对环境变量的支持，包含内置的环境变量和自定义的环境变量。\n\n\n内置的环境变量#\n\n\nASSET_PREFIX#\n\n表示当前资源文件的路径前缀，是只读的的环境变量。\n\n\nNODE_ENV#\n\n表示当前的执行环境，是只读的的环境变量，其值在不同的执行命令下具有不同的值：\n\n * production：执行 modern build、modern serve 命令时的默认值。\n * development：执行 modern dev 命令时的默认值，同时也是其他所有情况下的默认值。\n\n\nMODERN_ENV#\n\n手动设置当前的执行环境。除了上述 NODE_ENV 对应的值之外，这里支持自定义环境名称，例如 staging、boe 等。\n\nTIP\n\nMODERN_ENV 的优先级高于 NODE_ENV。\n\n\nMODERN_TARGET#\n\n使用 @modern-js/runtime 时，Modern.js 会自动注入 MODERN_TARGET，用于区分 SSR 与 CSR 环境。\n\n你可以在代码中通过 process.env.MODERN_TARGET 来判断环境，并执行相应的逻辑。\n\n\n\n在开发环境构建完成后，可以看到 SSR 产物和 CSR 产物如下：\n\n\n\n\n\n这种方式可以针对不同客户端提供不同的产物，保证代码体积最小化；也便于处理不同环境下代码中的一些副作用。\n\n死代码移除\n\n在生产环境，Terser 和 SWC 等代码压缩工具会分析代码，并将 dead code 移除，从而减少产物体积，这个过程被称为死代码移除（DCE）。\n\n例如，上述 if (false) 语句包含的代码会被移除，而 if (true) 包含的代码将被保留。\n\n如果你未按照上述写法来使用 process.env.MODERN_TARGET，代码压缩工具可能会无法分析出 dead code，从而导致产物体积增大。\n\n\n自定义环境变量#\n\n环境变量支持通过 shell 和 .env 文件两种方式指定。\n\n\n通过 shell 指定#\n\n在命令前添加自定义环境变量：\n\n\n\n\n通过 .env 文件指定#\n\n在项目根目录创建 .env 文件，并添加自定义环境变量，这些环境变量会默认添加到启动项目的 Node.js 进程中，例如：\n\n\n\n.env 文件遵循以下规则加载规则：\n\n * .env：默认加载。\n * .env.{ MODERN_ENV | NODE_ENV }：针对具体环境设置环境变量，会覆盖 .env 中的设置。\n\n当需要根据环境使用不同的配置时，可以把环境变量定义到对应环境名称的 .env 文件中，并在启动项目时手动设置执行环境。例如使用以下命令启动项目时，将会加载\n.env 和 .env.staging:\n\n\n\n\n使用环境变量#\n\n\n约定命名#\n\n在前端代码中可以直接使用 NODE_ENV 环境变量。另外，以 MODERN_ 开头的自定义环境变量，也可以在代码中直接使用。\n\n例如:\n\n\n\n执行 pnpm run dev 命令之后可以看到如下构建产物：\n\n\n\n同样在自定义的 HTML 模板中，也可以直接使用这类环境变量。如 config/html/head.html:\n\n\n\n\n任意命名#\n\n如果需要在代码中使用任意名称的环境变量，可以在 source.globalVars 配置指定, 例如：\n\n\n\n此时，在代码中的 process.env.VERSION，将会被替换为环境变量中 VERSION 的值。\n\nNOTE\n\nsource.globalVars 也支持将其他表达式或字符串替换为指定的值，不仅限于环境变量。\n\n\n使用全局替换#\n\n除了环境变量，Modern.js 也支持将代码中的变量替换成其它值或者表达式，可以用于在代码逻辑中区分开发环境与生产环境等场景。\n\n例如将代码中的 TWO 转换为 1 + 1 的表达式：\n\n\n\n\n\n在大多数情况下，source.globalVars 已经能满足替换变量的需求。但 source.globalVars 传入的值都会默认被 JSON\n序列化，因此无法做出像上面例子中 1 + 1 的替换，此时就需要使用 source.define。","routePath":"/guides/basic-features/env-vars","lang":"zh","toc":[{"text":"内置的环境变量","id":"内置的环境变量","depth":2,"charIndex":46},{"text":"ASSET_PREFIX","id":"asset_prefix","depth":3,"charIndex":57},{"text":"NODE_ENV","id":"node_env","depth":3,"charIndex":99},{"text":"MODERN_ENV","id":"modern_env","depth":3,"charIndex":258},{"text":"MODERN_TARGET","id":"modern_target","depth":3,"charIndex":370},{"text":"自定义环境变量","id":"自定义环境变量","depth":2,"charIndex":823},{"text":"通过 `shell` 指定","id":"通过-shell-指定","depth":3,"charIndex":-1},{"text":"通过 `.env` 文件指定","id":"通过-env-文件指定","depth":3,"charIndex":-1},{"text":"使用环境变量","id":"使用环境变量","depth":2,"charIndex":1180},{"text":"约定命名","id":"约定命名","depth":3,"charIndex":1190},{"text":"任意命名","id":"任意命名","depth":3,"charIndex":1364},{"text":"使用全局替换","id":"使用全局替换","depth":2,"charIndex":1537}],"domain":"","frontmatter":{"sidebar_position":7},"version":""},{"id":543,"title":"HTML 模板","content":"以下为构建时传过来的参数：\n\n\nentryName: sub\n\n\ntitle:\n\n\nrootId: root\n\n\nbottom","routePath":"/guides/basic-features/html","lang":"zh","toc":[{"text":"JSX 语法","id":"jsx-语法","depth":2,"charIndex":-1},{"text":"HTML 组件","id":"html-组件","depth":3,"charIndex":-1},{"text":"模板参数","id":"模板参数","depth":3,"charIndex":-1},{"text":"基础示例","id":"基础示例","depth":3,"charIndex":-1},{"text":"Scripts 组件示例","id":"scripts-组件示例","depth":3,"charIndex":-1},{"text":"HTML 语法","id":"html-语法","depth":2,"charIndex":-1},{"text":"自定义 HTML 片段","id":"自定义-html-片段","depth":3,"charIndex":-1},{"text":"完全自定义 HTML 模板","id":"完全自定义-html-模板","depth":3,"charIndex":-1},{"text":"模板参数","id":"模板参数-1","depth":3,"charIndex":-1},{"text":"按入口设置","id":"按入口设置","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"title":"HTML 模板","sidebar_position":9},"version":""},{"id":544,"title":"引用 JSON 文件","content":"#\n\nModern.js 支持在代码中引用 JSON 文件，也支持引用 YAML 和 TOML 文件并将其转换为 JSON 格式。\n\n\nJSON 文件#\n\n你可以直接在 JavaScript 文件中引用 JSON 文件。\n\n\n示例#\n\n\n\n\n\n\n具名引用#\n\nModern.js 暂不支持通过 named import 来引用 JSON 文件：\n\n\n\n\nYAML 文件#\n\nYAML 是一种数据序列化语言，通常用于编写配置文件。\n\n你可以直接在 JavaScript 中引用 .yaml 或 .yml 文件，它们会被自动转换为 JSON 格式。\n\n\n示例#\n\n\n\n\n\n\n添加类型声明#\n\n当你在 TypeScript 代码中引用 YAML 文件时，请在项目中创建 src/global.d.ts 文件，并添加相应的类型声明：\n\n\n\n\nTOML 文件#\n\nTOML 是一种语义明显、易于阅读的配置文件格式。\n\n你可以直接在 JavaScript 中引用 .toml 文件，它会被自动转换为 JSON 格式。\n\n\n示例#\n\n\n\n\n\n\n添加类型声明#\n\n当你在 TypeScript 代码中引用 TOML 文件时，请在项目中创建 src/global.d.ts 文件，并添加相应的类型声明：\n\n","routePath":"/guides/basic-features/json-files","lang":"zh","toc":[{"text":"JSON 文件","id":"json-文件","depth":2,"charIndex":67},{"text":"示例","id":"示例","depth":3,"charIndex":112},{"text":"具名引用","id":"具名引用","depth":3,"charIndex":122},{"text":"YAML 文件","id":"yaml-文件","depth":2,"charIndex":176},{"text":"示例","id":"示例-1","depth":3,"charIndex":274},{"text":"添加类型声明","id":"添加类型声明","depth":3,"charIndex":284},{"text":"TOML 文件","id":"toml-文件","depth":2,"charIndex":366},{"text":"示例","id":"示例-2","depth":3,"charIndex":454},{"text":"添加类型声明","id":"添加类型声明-1","depth":3,"charIndex":464}],"domain":"","frontmatter":{"sidebar_position":12},"version":""},{"id":545,"title":"数据模拟（Mock）","content":"#\n\nModern.js 提供了快速生成 Mock 数据的功能，能够让前端独立自主开发，不被后端接口阻塞。\n\n\n启用 Mock#\n\n约定当 config/mock 目录下存在 index.[jt]s 时，会自动开启 Mock 功能，如下：\n\n\n\n\n编写 Mock 文件#\n\nconfig/mock/index.ts 文件只需要导出一个包含所有 Mock API 的对象，对象的属性由请求配置 method 和 url\n组成，对应的属性值可以为 Object、Array、Function：\n\n\n\n代码中访问 http://localhost:8080/api/getInfo 时，接口会返回 JSON 格式数据：{ \"data\": [1, 2, 3, 4]\n}。\n\n\n返回随机数据#\n\n可以在 config/mock/index.js 中自主引入 Mock.js 等库生成随机数据，例如：\n\n\n\n更多随机数据生成库\n * Chancejs\n * Mock\n\n\n延迟响应#\n\n * 可以使用浏览器「 弱网模拟 」的功能实现。\n * 可以通过 setTimeout 为单个接口设置延迟，例如：\n\n\n\n\n按需使用 Mock 服务#\n\nconfig/mock/index.ts 下还可以到处 config 对象，更精细的控制 Mock 服务。\n\n\n\n目前仅支持 enable 配置，开发者可以通过该配置控制是否执行 Mock。\n\nNOTE\n\n修改 config 后无需重启服务，即刻生效。","routePath":"/guides/basic-features/mock","lang":"zh","toc":[{"text":"启用 Mock","id":"启用-mock","depth":2,"charIndex":55},{"text":"编写 Mock 文件","id":"编写-mock-文件","depth":2,"charIndex":123},{"text":"返回随机数据","id":"返回随机数据","depth":2,"charIndex":333},{"text":"延迟响应","id":"延迟响应","depth":2,"charIndex":429},{"text":"按需使用 Mock 服务","id":"按需使用-mock-服务","depth":2,"charIndex":498}],"domain":"","frontmatter":{"sidebar_position":5},"version":""},{"id":546,"title":"构建产物目录","content":"#\n\n本章节主要介绍构建产物的目录结构，以及如何控制不同类型产物的输出目录。\n\n\n默认产物目录#\n\n下面是最基础的产物目录结构，默认情况下，构建产物会生成在当前项目的 dist 目录下。\n\n\n\n最常见的产物是 HTML 文件、JS 文件和 CSS 文件：\n\n * HTML 文件：默认输出到 html 目录。\n * JS 文件：默认输出到 static/js 目录，\n * CSS 文件：默认输出到 static/css 目录。\n\n此外，JS 文件和 CSS 文件有时候会生成一些相关产物：\n\n * License 文件：包含开源许可证信息，默认输出到 JS 文件的同级目录，并添加 .LICENSE.txt 后缀。\n * Source Map 文件：包含保存源代码映射关系，默认输出到 JS 文件和 CSS 文件的同级目录，并添加 .map 后缀。\n\n在产物的文件名称中，[name] 表示这个文件对应的入口名称，比如 index, main。[hash] 则是基于该文件的内容生成的哈希值。\n\n\n修改产物目录#\n\nBuilder 提供了多个配置项来修改产物目录和产物名称，你可以：\n\n * 通过 output.filename 来修改产物的文件名。\n * 通过 output.distPath 来修改产物的输出路径。\n * 通过 output.legalComments 来修改 License 文件的生成方式。\n * 通过 output.disableSourceMap 来移除 Source Map 文件。\n * 通过 html.disableHtmlFolder 移除 HTML 产物对应的文件夹。\n\n\n静态资源#\n\n当你在代码中引用图片、SVG、字体、媒体等类型的静态资源时，它们也会被输出到 dist/static 目录下，并根据静态资源类型来自动分配到对应的子目录：\n\n\n\n你可以通过 output.distPath 配置项将这些静态资源统一输入到单个目录下，比如输出到 assets 目录：\n\n\n\n上方的配置会生成以下目录结构：\n\n\n\n\nNode.js 产物目录#\n\n当你在 Modern.js 中开启了 SSR 或 SSG 等服务端功能时，Modern.js 会在构建后生成一份 Node.js 产物，并输出到 bundles\n目录下：\n\n\n\nNode.js 产物通常只包含 JS 文件，不包含 HTML、CSS 等文件。此外，Node 产物的 JS 文件名称也不会自动生成哈希值。\n\n你可以通过 output.distPath.server 配置项来修改 Node 产物的输出路径。\n\n比如，将 Node.js 产物输出到 server 目录：\n\n\n\n\n扁平化产物目录#\n\n有时候你不想产物目录有太多层级，可以将目录设置为空字符串，使生成的产物目录扁平化。\n\n参考下方的例子：\n\n\n\n上方的配置会生成以下目录结构：\n\n\n\n\n产物不写入磁盘#\n\n默认情况下，Builder 会将构建产物写入磁盘，以方便开发者查看产物的内容，或是配置静态资源的代理规则。\n\n在开发环境，你可以选择将构建产物保存在 Dev Server 的内存中，从而减少文件操作产生的开销。\n\n将 dev.writeToDisk 配置项设置为 false 即可：\n\n","routePath":"/guides/basic-features/output-files","lang":"zh","toc":[{"text":"默认产物目录","id":"默认产物目录","depth":2,"charIndex":40},{"text":"修改产物目录","id":"修改产物目录","depth":2,"charIndex":449},{"text":"静态资源","id":"静态资源","depth":2,"charIndex":706},{"text":"Node.js 产物目录","id":"nodejs-产物目录","depth":2,"charIndex":877},{"text":"扁平化产物目录","id":"扁平化产物目录","depth":2,"charIndex":1137},{"text":"产物不写入磁盘","id":"产物不写入磁盘","depth":2,"charIndex":1222}],"domain":"","frontmatter":{"sidebar_position":10},"version":""},{"id":547,"title":"网络代理","content":"#\n\n\n本地代理#\n\nModern.js 在 tools.devServer 中提供了配置开发环境代理的方式。例如，将本地开发接口，代理到线上某个地址：\n\n\n\n请求 http://localhost:8080/go/api 时，会从 http://www.example.com/ 返回响应内容。\n\n补充信息\n\n配置格式可参考：http-proxy-middleware。\n\n\n全局代理#\n\nWARNING\n\n@modern-js/plugin-proxy 已不再维护，后续将不再发布新版本。请迁移到其他代理工具，比如 whistle。\n\nModern.js 提供了开箱即用的全局代理插件 @modern-js/plugin-proxy，该插件底层基于 whistle，可用来查看、修改\nHTTP/HTTPS 的请求和响应，也可作为 HTTP 代理服务器使用。\n\n\n设置代理规则#\n\n引入代理插件并填写规则后，执行 pnpm run dev，Modern.js 会在开发服务器启动之后，自动启用代理服务器。\n\n具体代理规则，可通过 dev.proxy 选项或 config/proxy.js 文件进行设置。\n\n\n代理服务器 UI 界面#\n\n安装代理插件并配置代理规则后， 执行 pnpm run dev 命令：\n\n\n\n在控制台中可以看到代理服务器成功启动。\n\n访问 http://localhost:8899，显示下图所示的 UI 界面后，即可通过界面设置规则。\n\n","routePath":"/guides/basic-features/proxy","lang":"zh","toc":[{"text":"本地代理","id":"本地代理","depth":2,"charIndex":3},{"text":"全局代理","id":"全局代理","depth":2,"charIndex":188},{"text":"设置代理规则","id":"设置代理规则","depth":3,"charIndex":382},{"text":"代理服务器 UI 界面","id":"代理服务器-ui-界面","depth":3,"charIndex":505}],"domain":"","frontmatter":{"sidebar_position":6},"version":""},{"id":548,"title":"路由方案","content":"#\n\nModern.js 的路由基于 React Router 6，并提供了多种类型的路由模式。根据不同 入口\n类型，将路由分为三种模式，分别是约定式路由，自控式路由和其他路由方案。\n\nNOTE\n\n本小节提到的路由，都是客户端路由，即 SPA 路由。\n\n\n约定式路由#\n\n以 routes/ 为约定的入口，Modern.js 会自动基于文件系统，生成对应的路由结构。\n\nModern.js 支持了业界流行的约定式路由模式：嵌套路由，使用嵌套路由时，页面的路由 与 UI 结构是相呼应的，我们将会详细介绍这种路由模式。\n\n\n\n\n路由文件约定#\n\n在routes/ 目录下，目录名会作为路由 url 的映射，Modern.js 有两个文件约定 layout.[jt]sx 和\npage.[jt]sx（后面简写为 .tsx）。这两个文件决定了应用的布局层次，其中 layout.tsx 中作为布局组件，page.tsx\n作为内容组件，是整条路由的叶子节点（一条路由有且仅有一个叶子节点，且必须以叶子节点结尾）。\n\n例如以下目录结构：\n\n\n\n会产出下面两条路由：\n\n * /\n * /user\n\n当添加 layout.tsx 后， 假设有以下目录\n\nINFO\n\n这里 routes/layout.tsx 会作为 / 路由下所有组件的布局组件使用， routes/user/layout.tsx 会作为 /user\n路由下所有路由组件的布局组件使用。\n\n\n\n当路由为 / 时，会有以下 UI 布局：\n\n\n\n同样，routes/user/layout.tsx 会作为 /user 路由下所有组件的布局组件使用。当路由为 /user 时， 会有以下 UI 布局：\n\n\n\nLayout#\n\n组件是指 routes/ 目录下所有 layout.tsx 文件，它们表示对应路由片段的布局，使用 表示子组件。\n\n\n\nNOTE\n\n是 React Router 6 中新的 API，详情可以查看 Outlet.\n\n为了方便介绍 与 的关系，以下面的文件目录举例：\n\n\n\n 1. 当路由为 / 时，routes/layout.tsx 中的 代表的是 routes/page.tsx 中导出的组件，生成以下 UI 结构：\n\n\n\n 2. 当路由为 /blog 时，routes/layout.tsx 中的 代表的是 routes/blog/page.tsx 中导出的组件，生成以下 UI\n    结构：\n\n\n\n 3. 当路由为 /user 时，routes/layout.tsx 中的 代表的是 routes/user/layout.tsx\n    中导出的组件。routes/user/layout.tsx 中的 代表的是 routes/user/page.tsx 中导出的组件。生成以下 UI\n    结构：\n\n\n\n总结而言，如果子路由的文件目录下存在 layout.tsx，上一级 layout.tsx 中的 即为子路由文件目录下的 layout.tsx\n，否则为子路由文件目录下的 page.tsx。\n\nPage#\n\n所有的路由，理论上都应该由 组件结束。在 page.tsx 文件内，如果开发者引入 组件，不会有任何效果。\n\nConfig#\n\n每个 Layout, $ 或 Page 文件都可以定义一个自己的 config 文件，如 page.config.ts，该文件中我们约定了一个具名导出\nhandle， 这个字段中你可以定义任意属性：\n\n\n\n定义的这些属性可以通过 useMatches hook 获取：\n\n\n\n\n动态路由#\n\n通过 [] 命名的文件目录，生成的路由会作为动态路由。例如以下文件目录：\n\n\n\nroutes/[id]/page.tsx 文件会转为 /:id 路由。除了可以确切匹配的 /blog 路由，其他所有 /xxx 都会匹配到该路由。\n\n在组件中，可以通过 useParams 获取对应命名的参数。\n\n在 loader 中，params 会作为 loader 的入参，通过 params.xxx 可以获取。\n\n\n动态可选路由#\n\n通过 [$] 命名的文件目录，生成的路由会作为动态可选路由。例如以下文件目录：\n\n\n\nroutes/user/[id$]/page.tsx 文件会转为 /user/:id? 路由。/user 下的所有路由都会匹配到该路由，并且 id\n参数可选存在。通常在区分创建与编辑时，可以使用该路由。\n\n在组件中，可以通过 useParams 获取对应命名的参数。\n\n在 loader 中，params 会作为 loader 的入参，通过 params.xxx 可以获取。\n\n\n通配路由#\n\n如果在 routes 目录下创建 $.tsx 文件，该文件会作为通配路由组件，当没有匹配的路由时，会渲染该路由组件。\n\nNOTE\n\n$.tsx 可以认为是一种特殊的 page 路由组件，当前目录下有 layout 组件时，$.tsx，会作为 layout 的子组件渲染。\n\n例如以下目录结构：\n\n\n\n当访问任何匹配不到的路径时(如 /blog/a)，都会渲染 routes/blog/$.tsx 组件，因为这里有 layout.tsx，渲染的 UI 如下：\n\n\n\n如果希望访问 /blog 时，也匹配到 blog/$.tsx 文件，需要删除同目录下的 blog/layout.tsx 文件，同时保证 blog\n下面没有其他子路由。\n\n同样，$.tsx 中可以使用 useParams 捕获 url 的剩余部分。\n\n\n\n$.tsx 可以加入到 routes 目录下的任意目录中，一个常见的使用示例是添加 routes/$.tsx 文件去定制任意层级的 404 内容。\n\n\n无路径布局#\n\n当目录名以 __ 开头时，对应的目录名不会转换为实际的路由路径，例如以下文件目录：\n\n\n\nModern.js 会生成 /login 和 /sign 两条路由，__auth/layout.tsx 组件会作为 login/page.tsx 和\nsignup/page.tsx 的布局组件，但__auth 不会作为路由路径片段。\n\n当需要为某些类型的路由，做独立的布局，或是想要将路由做归类时，这一功能非常有用。\n\n\n无布局路径#\n\n有些情况下，项目需要较为复杂的路由，但这些路由又不存在独立的 UI 布局，如果像普通文件目录那边创建路由会导致目录层级较深。\n\n因此 Modern.js 支持了通过 . 来分割路由片段，代替文件目录。例如，当需要 /user/profile/2022/edit 时，可以直接创建如下文件：\n\n\n\n访问路由时，将得到如下 UI 布局：\n\n\n\n\nLoading (Experimental)#\n\nroutes/ 下每一层目录中，开发者可以创建 loading.tsx 文件，默认导出一个 组件。\n\n当路由目录下存在该组件和 layout 组件时，这一级子路由下所有的路由切换时，都会以该 组件作为 JS Chunk 加载时的 Fallback\nUI。例如以下文件目录：\n\n\n\n当定义 loading.tsx 时，就相当于以下布局：\n\n\n\n\n\n\n\nINFO\n\n当目录的 Layout 组件不存在时，该目录下的 Loading 组件也不会生效。\n\nModern.js 建议必须有根 Layout 和根 Loading。\n\n当路由从 / 跳转到 /blog 时，如果 blog/page 组件的 JS Chunk 还未加载，则会先展示 loading.tsx 中导出的组件 UI。\n\n同理，当路由从 / 或者 /blog 跳转到 /blog/123 时，如果 blog/[id]/page 组件的 JS Chunk 还未加载，也会先展示\nloading.tsx 中导出的组件 UI。\n\n\n路由重定向#\n\n可以使用 Data Loader 文件做路由的重定向。如有文件 routes/user/page.tsx，想对这个文件对应的路由做重定向，可以创建\nroutes/user/page.data.ts 文件：\n\n\n\n在组件内做重定向，则可以通过 useNavigate hook，示例如下：\n\n\n\n\n错误处理#\n\nroutes/ 下每一层目录中，开发者同样可以定义一个 error.tsx 文件，默认导出一个 组件。\n\n当有路由目录下存在该组件时，组件渲染出错会被 ErrorBoundary 组件捕获。当目录未定义 layout.tsx 文件时， 组件不会生效。\n\n可以返回出错时的 UI 视图，当前层级未声明\n组件时，错误会向上冒泡到更上层的组件，直到被捕获或抛出错误。同时，当组件出错时，只会影响捕获到该错误的路由组件及子组件，其他组件的状态和视图不受影响，可以继续交\n互。\n\n在 组件内，可以使用 useRouteError 获取的错误的具体信息：\n\n\n\n\n运行时配置#\n\n在每个根 Layout 组件中(routes/layout.ts)，可以动态地定义运行时配置：\n\n\n\n\n渲染前的钩子#\n\n在有些场景下，需要在应用渲染前做一些操作，可以在 routes/layout.tsx 中定义 init 钩子，init\n在客户端和服务端均会执行，基本使用示例如下：\n\n\n\n通过 init 钩子可以挂载一些全局的数据，在应用的其他地方可以访问 runtimeContext 变量：\n\nNOTE\n\n该功能在应用需要页面前置的数据、自定义数据注入或是框架迁移（如 Next.js）时会非常有用。\n\n\n\n\n\n配合 SSR 功能时，浏览器端可以获取到 SSR 时 init 返回的数据，开发者可以自行判断是否要在浏览器端重新获取数据来覆盖 SSR 数据，例如：\n\n\n\n\n预加载#\n\n在约定式路由下， Modern.js\n会根据路由，自动地对路由进行分片。当用户访问具体的路由时，会自动加载对应的分片，这样可以有效地减少首屏加载的时间。但这也带来了一个问题，当用户访问一个路由时，如\n果该路由对应的分片还未加载完成，就会出现白屏的情况。 这种情况下你可以通过定义 Loading 组件，在静态资源加载完成前，展示一个自定义的 Loading\n组件。\n\n为了进一步提升用户体验，减少 loading 的时间，Modern.js 支持在 Link 组件上定义 prefetch\n属性，可以提前对静态资源和数据进行加载：\n\n\n\nINFO\n * 该功能目前仅在 Webpack 项目中支持，Rspack 项目暂不支持。\n * 对数据的预加载目前只会预加载 SSR 项目中 Data Loader 中返回的数据。\n\nprefetch 属性有三个可选值：\n\n * none， 默认值，不会做 prefetch，没有任何额外的行为。\n * intent，这是我们推荐大多数场景下使用的值，当你把鼠标放在 Link 上时，会自动开始加载对应的分片和 Data Loader\n   中定义的数据，当鼠标移开时，会自动取消加载。在我们的测试中，即使是快速点击，也能减少大约 200ms 的加载时间。\n * render，当 Link 组件渲染时，就会加载对应的分片和 Data Loader 中定义的数据。\n\n常见问题#\n\n 1. 使用 render 和不根据路由做静态资源分片的区别？\n\n * 使用 render 可以指定哪些路由在首屏时，进行加载，同时你可以通过对渲染的控制，仅当 Link 组件进入到可视区域时，才对 Link 组件进行渲染。\n\n * 使用 render，仅在空闲时对静态资源进行加载，不会与首屏静态资源抢占网络。\n\n * 在 SSR 场景下，也会对数据进行预取。\n\n\n自控式路由#\n\n以 src/App.tsx 为约定的入口，Modern.js 不会对路由做额外的操作，开发者可以自行使用 React Router 6 的 API\n进行开发，例如：\n\n\n\nNOTE\n\nModern.js 默认对约定式路由做了一系列资源加载及渲染上的优化，并且提供了开箱即用的 SSR\n能力。而在使用自控路由时，这些能力都需要开发者自行封装。我们推荐开发者使用约定式路由。\n\n\n其他路由方案#\n\n默认情况下，Modern.js 会开启内置的路由方案，即 React Router。\n\n\n\n如上述配置，当开启 runtime.router 配置时，Modern.js 会从 @modern-js/runtime/router 命名空间导出 React\nRouter 的 API 供开发者使用，保证开发者和 Modern.js 中使用同一份代码，并自动根据 router 配置包裹 Provider\n组件。另外，这种情况下，React Router 的代码会被打包到 JS 产物中。\n\n如果项目已经有自己的路由方案，或者不需要使用客户端路由，可以关闭这个功能。\n\n\n\n如上述配置， 如果关闭了 runtime.router 配置，并直接使用 react-router-dom 进行项目路由管理时，还需要根据 React\nRouter 文档自行包裹 Provider。","routePath":"/guides/basic-features/routes","lang":"zh","toc":[{"text":"约定式路由","id":"约定式路由","depth":2,"charIndex":127},{"text":"路由文件约定","id":"路由文件约定","depth":3,"charIndex":262},{"text":"Layout","id":"layout","depth":4,"charIndex":727},{"text":"Page","id":"page","depth":4,"charIndex":1289},{"text":"Config","id":"config","depth":4,"charIndex":1351},{"text":"动态路由","id":"动态路由","depth":3,"charIndex":1499},{"text":"动态可选路由","id":"动态可选路由","depth":3,"charIndex":1708},{"text":"通配路由","id":"通配路由","depth":3,"charIndex":1950},{"text":"无路径布局","id":"无路径布局","depth":3,"charIndex":2392},{"text":"无布局路径","id":"无布局路径","depth":3,"charIndex":2606},{"text":"Loading (Experimental)","id":"loading-experimental","depth":3,"charIndex":2785},{"text":"路由重定向","id":"路由重定向","depth":3,"charIndex":3253},{"text":"错误处理","id":"错误处理","depth":3,"charIndex":3409},{"text":"运行时配置","id":"运行时配置","depth":3,"charIndex":3692},{"text":"渲染前的钩子","id":"渲染前的钩子","depth":3,"charIndex":3752},{"text":"预加载","id":"预加载","depth":3,"charIndex":4041},{"text":"常见问题","id":"常见问题","depth":4,"charIndex":4650},{"text":"自控式路由","id":"自控式路由","depth":2,"charIndex":4841},{"text":"其他路由方案","id":"其他路由方案","depth":2,"charIndex":5037}],"domain":"","frontmatter":{"sidebar_position":2},"version":""},{"id":549,"title":"引用静态资源","content":"#\n\nModern.js 支持在代码中引用图片、字体、媒体类型的静态资源。\n\n什么是静态资源\n\n静态资源是指 Web 应用中不会发生变化的文件。常见的静态资源包括图片、字体、视频、样式表和 JavaScript 文件。这些资源通常存储在服务器或 CDN\n上，当用户访问 Web 应用时会被传送到用户的浏览器。由于它们不会发生变化，静态资源可以被浏览器缓存，从而提高 Web 应用的性能。\n\n\n静态资源格式#\n\n以下是 Modern.js 默认支持的静态资源格式：\n\n * 图片：png、jpg、jpeg、gif、svg、bmp、webp、ico、apng、avif、tiff。\n * 字体：woff、woff2、eot、ttf、otf、ttc。\n * 媒体：mp4、webm、ogg、mp3、wav、flac、aac、mov。\n\n如果你需要引用其他格式的静态资源，请参考 扩展静态资源类型。\n\nSVG 图片\n\nSVG 图片是一种特殊情况，Modern.js 提供了 SVG 转 React 组件的能力，对 SVG 进行单独处理，详见 引用 SVG 资源。\n\n\n在 JS 文件中引用#\n\n在 JS 文件中，可以直接通过 import 的方式引用相对路径下的静态资源：\n\n\n\n也支持使用路径别名来引用：\n\n\n\n\n在 CSS 文件中引用#\n\n在 CSS 文件中，可以引用相对路径下的静态资源：\n\n\n\n也支持使用路径别名来引用：\n\n\n\n\n引用结果#\n\n引用静态资源的结果取决于文件体积：\n\n * 当文件体积大于 10KB 时，会返回一个 URL，同时文件会被输出到构建产物目录下。\n * 当文件体积小于 10KB 时，会自动被内联为 Base64 格式。\n\n\n\n关于资源内联的更详细介绍，请参考 静态资源内联 章节。\n\n\n构建产物#\n\n当静态资源被引用后，会自动被输出到构建产物的目录下，你可以：\n\n * 通过 output.filename 来修改产物的文件名。\n * 通过 output.distPath 来修改产物的输出路径。\n\n请阅读 构建产物目录 来了解更多细节。\n\n\nURL 前缀#\n\n引用静态资源后返回的 URL 中会自动包含路径前缀：\n\n * 在开发环境下，通过 dev.assetPrefix 设置路径前缀。\n * 在生产环境下，通过 output.assetPrefix 设置路径前缀。\n\n比如将 output.assetPrefix 设置为 https://modern.com：\n\n\n\n\n添加类型声明#\n\n当你在 TypeScript 代码中引用静态资源时，TypeScript 可能会提示该模块缺少类型定义：\n\n\n\n此时你需要为静态资源添加类型声明文件，请在项目中创建 src/global.d.ts 文件，并添加相应的类型声明。以 png 图片为例，需要添加以下声明：\n\n\n\n添加类型声明后，如果依然存在上述错误提示，请尝试重启当前 IDE，或者调整 global.d.ts 所在的目录，使 TypeScript 能够正确识别类型定义。\n\n\n扩展静态资源类型#\n\n如果 Modern.js 内置的静态资源类型不能满足你的需求，那么你可以通过 tools.bundlerChain 来修改内置的 webpack /\nRspack 配置，并扩展你需要的静态资源类型。\n\n比如，你需要把 *.pdf 文件当做静态资源直接输出到产物目录，可以添加以下配置：\n\n\n\n添加以上配置后，你就可以在代码里引用 *.pdf 文件了，比如：\n\n\n\n关于以上配置的更多介绍，请参考：\n\n * Rspack 文档 - Asset modules\n * webpack 文档 - Asset modules\n\n\n图片格式#\n\n在使用图片资源时，你可以根据下方表格中图片的优缺点以及适用场景，来选择合适的图片格式。\n\n格式     优点                                      缺点                    适用场景\nPNG    无损压缩，不会丢失图片细节，不失真，支持半透明                 不适合色表复杂的图片            适合颜色数量少，边界层次分明的图片，适合用在 logo、icon、透明图等场景\nJPG    颜色丰富                                    有损压缩，会导致图片失真，不支持透明度   适合颜色数量多，颜色带有渐变、过度复杂的图片，适合用在人像照片、风景图等场景\nWebP   同时支持有损压缩与无损压缩，支持透明度，体积比 PNG 和 JPG 小很多   iOS 兼容性不好             几乎任何场景的像素图片，支持 WebP 的宿主环境，都应该首选 WebP 图片格式\nSVG    无损格式，不失真,支持透明度                          不适合复杂图形               适合矢量图,适合用于 icon","routePath":"/guides/basic-features/static-assets","lang":"zh","toc":[{"text":"静态资源格式","id":"静态资源格式","depth":2,"charIndex":195},{"text":"在 JS 文件中引用","id":"在-js-文件中引用","depth":2,"charIndex":479},{"text":"在 CSS 文件中引用","id":"在-css-文件中引用","depth":2,"charIndex":553},{"text":"引用结果","id":"引用结果","depth":2,"charIndex":614},{"text":"构建产物","id":"构建产物","depth":2,"charIndex":756},{"text":"URL 前缀","id":"url-前缀","depth":2,"charIndex":885},{"text":"添加类型声明","id":"添加类型声明","depth":2,"charIndex":1051},{"text":"扩展静态资源类型","id":"扩展静态资源类型","depth":2,"charIndex":1280},{"text":"图片格式","id":"图片格式","depth":2,"charIndex":1552}],"domain":"","frontmatter":{"sidebar_position":10},"version":""},{"id":550,"title":"引用 SVG 资源","content":"#\n\nModern.js 支持在代码中引用 SVG 资源，并将 SVG 图片转换为 React 组件或 URL。\n\n什么是 SVG\n\nSVG 是 Scalable Vector Graphics 的缩写，意为可伸缩矢量图形。SVG 是一种用来描述二维矢量图形的 XML-based\n格式，可以用来创建可以无限放大或缩小而不失真的图像。因为 SVG 图形是由矢量图形元素组成的，所以可以轻松地在各种尺寸和分辨率下渲染。\n\n\n在 JS 文件中引用#\n\n\n默认导入#\n\n如果你使用默认导入来引用 SVG，它会被当做静态资源来处理，你会得到一个 URL 字符串：\n\n\n\n\n转换 React 组件#\n\n在 JS 文件中引用 SVG 资源时，如果导入的路径包含 ?react 后缀，Modern.js 会调用 SVGR，将 SVG 图片转换为一个 React\n组件：\n\n\n\nTIP\n\nModern.js >= 2.48.3 版本支持上述用法。\n\nModern.js 也支持以下用法，通过具名导入 ReactComponent 来转换 SVG 为 React 组件：\n\n\n\n\n修改默认导出#\n\n你可以通过 output.svgDefaultExport 配置项来修改 SVG 文件默认导出的内容，比如把默认导出的内容设置为 React 组件：\n\n\n\n此时再使用默认导入，你会得到一个 React 组件，而不是 URL：\n\n\n\n\n在 CSS 文件中引用#\n\n在 CSS 文件中引用 SVG 资源时，SVG 会被当做一个普通的静态资源来处理，你会得到一个 URL：\n\n\n\n\n静态资源处理#\n\n当 SVG 不是作为 React 组件，而是作为一个普通的静态资源被引用时，它的处理逻辑和其他静态资源完全一致，也会受到静态资源内联、URL 前缀等规则的影响。\n\n请阅读 引用静态资源 章节来了解静态资源的处理规则。\n\n\n禁用 SVGR 处理#\n\n默认情况下，在 JS 文件中引用 SVG 资源时，Modern.js 会调用 SVGR，将 SVG 图片转换为一个 React 组件。\n\n如果你确定项目内的所有 SVG 资源都没有当成 React 组件使用时，可以通过将 disableSvgr 设置为 true 来关闭此项转换，以提升构建性能。\n\n\n\n\n添加类型声明#\n\n当你在 TypeScript 代码中引用 SVG 资源时，TypeScript 可能会提示该模块缺少类型定义：\n\n\n\n此时你需要为 SVG 资源添加类型声明文件，请在项目中创建 src/global.d.ts 文件，并添加相应的类型声明：\n\n\n\n如果你将 svgDefaultExport 设置为 'component'，则将类型声明修改为：\n\n\n\n添加类型声明后，如果依然存在上述错误提示，请尝试重启当前 IDE，或者调整 global.d.ts 所在的目录，使 TypeScript 能够正确识别类型定义。\n\n\n修改 SVGR 配置#\n\n当启用 SVGR 时，其默认配置如下：\n\n\n\n如果需要修改 SVGR 配置，可通过如下方式：\n\n","routePath":"/guides/basic-features/svg-assets","lang":"zh","toc":[{"text":"在 JS 文件中引用","id":"在-js-文件中引用","depth":2,"charIndex":210},{"text":"默认导入","id":"默认导入","depth":3,"charIndex":224},{"text":"转换 React 组件","id":"转换-react-组件","depth":3,"charIndex":281},{"text":"修改默认导出","id":"修改默认导出","depth":2,"charIndex":480},{"text":"在 CSS 文件中引用","id":"在-css-文件中引用","depth":2,"charIndex":606},{"text":"静态资源处理","id":"静态资源处理","depth":2,"charIndex":677},{"text":"禁用 SVGR 处理","id":"禁用-svgr-处理","depth":2,"charIndex":797},{"text":"添加类型声明","id":"添加类型声明","depth":2,"charIndex":963},{"text":"修改 SVGR 配置","id":"修改-svgr-配置","depth":2,"charIndex":1230}],"domain":"","frontmatter":{"sidebar_position":11},"version":""},{"id":551,"title":"引用 Wasm 资源","content":"#\n\nModern.js 支持在代码引用 WebAssembly 资源。\n\n什么是 WebAssembly\n\nWebAssembly（缩写为 wasm）是一种可移植、高性能的字节码格式，被设计用来在现代 Web 浏览器中执行 CPU 密集型计算任务，为 Web\n平台带来了接近本地编译代码的性能和可靠性。\n\n\n引用方式#\n\n你可以直接在 JavaScript 文件中引用一个 WebAssembly 模块：\n\n\n\n也可以通过 dynamic import 来引用 WebAssembly 模块：\n\n\n\n还可以通过 new URL 语法来获取 WebAssembly 模块的路径：\n\n\n\n\n输出目录#\n\n当 .wasm 资源被引用后，默认会被 Modern.js 输出到 dist/static/wasm 目录下。\n\n你可以通过 output.distPath 配置项来修改 .wasm 产物的输出目录。\n\n\n\n\n添加类型声明#\n\n当你在 TypeScript 代码中引用 Wasm 文件时，通常需要添加相应的类型声明。\n\n比如 add.wasm 文件导出了 add() 方法，那么你可以在同级目录下创建一个 add.wasm.d.ts 文件，并添加相应的类型声明：\n\n","routePath":"/guides/basic-features/wasm-assets","lang":"zh","toc":[{"text":"引用方式","id":"引用方式","depth":2,"charIndex":154},{"text":"输出目录","id":"输出目录","depth":2,"charIndex":293},{"text":"添加类型声明","id":"添加类型声明","depth":2,"charIndex":405}],"domain":"","frontmatter":{"sidebar_position":13},"version":""},{"id":552,"title":"构建工具","content":"#\n\nModern.js 内部基于 Rsbuild 封装了自身的构建工具（Modern.js Builder），并支持在 Webpack 和 Rspack\n两种打包工具间无缝切换。\n\n什么是 Rsbuild\n\nRsbuild 是基于 Rspack 的构建工具，是一个增强版的 Rspack CLI，更易用、开箱即用。\n\n\n构建架构#\n\n从构建的角度看，Modern.js 分为三层架构，从上到下依次是：\n\n * 研发框架：Modern.js（开源）和 EdenX（内部）。\n * 构建工具：Rsbuild。\n * 打包工具：Webpack 和 Rspack。\n\n\n构建文档#\n\nRsbuild 的文档地址为：https://rsbuild.dev/\n\n在该文档中，你可以了解到 Rsbuild 的详细介绍，同时也可以找到各个构建能力的完整使用指南。\n\n如果你想要了解某些构建配置的使用，建议你优先阅读 Modern.js 文档，因为 Modern.js 中的构建配置和默认值与 Rsbuild 并不完全相同。\n\n\n构建插件#\n\n在 Modern.js 中，你可以注册 Webpack 插件、Rspack 插件或 Rsbuild 插件：\n\n * Webpack / Rspack 插件：通过 tools.bundlerChain 配置。\n * Rsbuild 插件：通过 builderPlugins 配置。\n\n\n构建能力#\n\nRsbuild 提供了丰富的构建能力，包括 JavaScript 编译、CSS 编译、静态资源处理、代码热更新、代码压缩、TS 类型检查等几十种能力。\n\n我们推荐你阅读 「Rsbuild - 功能导航」 来了解 Rsbuild 提供的所有构建能力。","routePath":"/guides/concept/builder","lang":"zh","toc":[{"text":"构建架构","id":"构建架构","depth":2,"charIndex":160},{"text":"构建文档","id":"构建文档","depth":2,"charIndex":281},{"text":"构建插件","id":"构建插件","depth":2,"charIndex":456},{"text":"构建能力","id":"构建能力","depth":2,"charIndex":605}],"domain":"","frontmatter":{"sidebar_position":2},"version":""},{"id":553,"title":"页面入口","content":"#\n\n通过本章节，你可以了解到 Modern.js 中的入口约定，以及如何自定义入口。\n\n\n什么是入口#\n\n入口（Entry）指的是一个页面的起始模块。\n\n在 Modern.js 项目中，每一个入口对应一个独立的页面，也对应一条服务端路由。默认情况下，Modern.js\n会基于目录约定来自动确定页面的入口，同时也支持通过配置项来自定义入口。\n\nModern.js 提供的很多配置项都是以入口为维度进行划分的，比如页面标题、HTML 模板、页面 Meta 信息、是否开启 SSR/SSG、服务端路由规则等。\n\n\n单入口与多入口#\n\nModern.js 初始化的项目是单入口的（SPA），项目结构如下：\n\n\n\n在 Modern.js 项目中，你可以很方便的将单入口切换成多入口，直接在项目下执行 pnpm run new，根据提示创建入口即可：\n\n\n\n执行后，Modern.js 会自动生成一个新的入口目录，此时可以看到 src/ 目录变成如下结构：\n\n\n\n原本的入口代码被移动到了和 package.json 中 name 同名的目录下，并创建了 new-entry 入口目录。\n\n你可以执行 pnpm run dev 启动开发服务，此时可以看到新增了一条名为 /new-entry 的路由，并且原有页面的路由并未发生变化。\n\nTIP\n\nModern.js 会将与 package.json 文件中 name 字段同名的入口作为主入口，主入口的路由为 /，其他入口的路由为\n/{entryName}。\n\n比如，package.json 中的 name 为 myapp 时，src/myapp 会作为项目的主入口。\n\n\n入口类型#\n\n不同的入口类型具有不同的编译和运行时行为。\n\n默认情况下，Modern.js 启动项目前会对 src/ 下的文件进行扫描，识别入口，并生成对应的服务端路由。\n\nTIP\n * 你可以通过 source.entriesDir 修改页面入口的识别目录。\n * 如果你需要自定义入口，请参考 自定义入口。\n\n并非 src/ 下所有的一级目录都会成为项目入口, 入口所在目录必须满足以下五个条件之一：\n\n 1. 具有 routes/ 目录。\n\n 2. 具有 App.[jt]sx? 文件。\n\n 3. 具有 entry.[jt]sx? 文件 (需要开启 source.enableCustomEntry 使用)。\n\n 4. 具有 index.[jt]sx? 文件（即将废弃）。\n\n 5. 具有 pages/ 目录（兼容 Modern.js 1.0）(即将废弃)。\n\n当 src/ 目录满足入口特征时，Modern.js 会认为当前项目为单入口应用。\n\nTIP\n\n在单入口应用中，默认的入口名为 main。\n\n当项目不是单入口应用时，Modern.js 会进一步查看 src/ 下的一级目录。\n\n\n框架模式入口#\n\n框架模式指的是需要使用 Modern.js\n的框架能力，例如嵌套路由、SSR、一体化调用等。这类入口约定下，开发者定义的入口并不是真正的编译入口。Modern.js 在启动时会生成一个封装过的入口，可以在\nnode_modules/.modern/[entryName]/index.js 找到真正的入口。\n\n约定式路由#\n\n如果入口中存在 routes/ 目录，Modern.js 会在启动时扫描 routes/\n下的文件，基于文件约定，自动生成客户端路由（react-router）。例如：\n\n\n\n上述目录中，layout.tsx 中导出的组件会作为最外层的组件，page.tsx 中导出的组件会作为 / 路由的组件。\n\n详细内容可以参考路由方案。\n\n自控式路由#\n\n如果入口中存在 App.[jt]sx? 文件，开发者可以在这个文件中通过代码的方式，设置客户端路由，或者不设置客户端路由。\n\n\n\n详细内容可以参考路由方案。\n\n自定义入口#\n\n如果入口中存在 entry.[jt]sx 文件，需要开发者在 entry.[jt]sx 文件中调用 createRoot 和 render\n函数，完成项目入口逻辑。\n\nINFO\n\n使用该文件需要开启 source.enableCustomEntry。\n\n\n\n比如在 render 执行前，需要做一些其他操作，可以这样实现：\n\n\n\n自定义 Bootstrap#\n\nWARNING\n\n即将废弃，推荐使用自定义入口\n\n如果入口中存在 index.[jt]sx 文件，并且当文件默认导出函数时，Modern.js 会将默认的 bootstrap\n函数作为入参传入，并用导出的函数替代默认的 bootstrap，这样开发者可以自定义将组件挂载到 DOM 节点上，或在挂载前添加自定义行为。例如：\n\n\n\n\n构建模式入口#\n\n构建模式指的是不使用 Modern.js 提供的 Runtime 能力，而是完全由开发者自行定义页面的入口。\n\n当入口目录中存在 index.[jt]sx(即将废弃) 并且没有通过 export default 导出函数或者入口目录存在 entry.[jt]sx\n并且未安装 @modern-js/runtime 依赖时，对应文件就会被识别为 webpack 或 Rspack 的 entry 模块。\n\nINFO\n\n使用 entry.[jt]sx 文件需要开启 source.enableCustomEntry。\n\n此时 Modern.js 不会自动生成入口代码，因此需要你自行将组件挂载到 DOM 节点上，例如:\n\n\n\n这种方式等价于开启 Modern.js 的 source.entries.disableMount 选项。当你使用这种方式时，将无法使用 Modern.js\n框架的运行时能力，比如 modern.config.js 文件中的 runtime 配置将不会再生效。\n\n\n自定义入口配置#\n\n在某些情况下，你可能需要自定义入口配置，而不是使用 Modern.js 提供的入口约定。\n\n比如你需要将一个非 Modern.js 项目迁移到 Modern.js，它并不是按照 Modern.js 的目录结构来搭建的。如果你要将它改成\nModern.js 约定的目录结构，可能会存在一定的迁移成本。这种情况下，你就可以使用自定义入口。\n\nModern.js 提供了以下配置项，你可以在 modern.config.ts 中配置它们：\n\n * source.entries：用于设置自定义的入口对象。\n * source.disableDefaultEntries：用于关闭 Modern.js\n   默认的入口扫描行为。当你使用自定义入口时，项目的部分结构可能会恰巧命中 Modern.js 约定的目录结构，但你可能不希望 Modern.js\n   为你自动生成入口配置，开启该选项可以避免这个问题。\n\n\n示例#\n\n下面是一个自定义入口的例子，你也可以查看相关配置项的文档来了解更多用法。\n\n\n\n注意，当你开启 disableMount 时，将无法使用 Modern.js 框架的运行时能力，比如 modern.config.ts 文件中的 runtime\n配置将不会再生效。","routePath":"/guides/concept/entries","lang":"zh","toc":[{"text":"什么是入口","id":"什么是入口","depth":2,"charIndex":45},{"text":"单入口与多入口","id":"单入口与多入口","depth":2,"charIndex":255},{"text":"入口类型","id":"入口类型","depth":2,"charIndex":708},{"text":"框架模式入口","id":"框架模式入口","depth":3,"charIndex":1207},{"text":"约定式路由","id":"约定式路由","depth":4,"charIndex":1371},{"text":"自控式路由","id":"自控式路由","depth":4,"charIndex":1544},{"text":"自定义入口","id":"自定义入口","depth":4,"charIndex":1632},{"text":"自定义 Bootstrap","id":"自定义-bootstrap","depth":4,"charIndex":1805},{"text":"构建模式入口","id":"构建模式入口","depth":3,"charIndex":1987},{"text":"自定义入口配置","id":"自定义入口配置","depth":2,"charIndex":2440},{"text":"示例","id":"示例","depth":3,"charIndex":2853}],"domain":"","frontmatter":{"sidebar_position":1},"version":""},{"id":554,"title":"已下线功能","content":"#\n\n本文将介绍 Modern.js 之前支持，但是现在已下线的功能及推荐替代方案。\n\n\n使用 @modern-js/create 创建 Monorepo#\n\nModern.js 之前提供的 Monorepo 方案是基于 pnpm Workspace 实现的，并未提供实质性的 Monorepo 管理能力。在\nv2.53.0 版本中，移除了使用 @modern-js/create 创建 Monorepo 项目的功能。推荐直接使用社区提供的 Monorepo 方案。\n\n\nnew 命令开启 test 能力#\n\nModern.js 之前提供的测试能力是基于 Jest 的简单封装。该封装导致 Jest 配置不直观、用户配置更加复杂等问题。在 v2.53.0\n版本中，移除了在应用项目和模块项目中开启 test 功能的选项。推荐直接使用社区提供的测试方案。","routePath":"/guides/deprecat","lang":"zh","toc":[{"text":"使用 @modern-js/create 创建 Monorepo","id":"使用-modern-jscreate-创建-monorepo","depth":2,"charIndex":44},{"text":"new 命令开启 test 能力","id":"new-命令开启-test-能力","depth":2,"charIndex":235}],"domain":"","frontmatter":{"sidebar_position":10},"version":""},{"id":555,"title":"名词解释","content":"#\n\n\nBFF#\n\nBFF 是 \"Backend For Frontend\"（前端的后端） 的缩写。它是一种架构模式，表示为前端应用程序创建一个专门的后台服务。\n\nBFF 服务作为前端应用程序和服务端 API 之间的中介，可以为前端提供定制的 API\n供其使用。这允许前端开发者对需要的数据和功能有更多的控制，而不必依赖后端服务提供相应的能力。\n\n\nBundler#\n\n指 webpack、Rspack 等模块打包工具。\n\n打包工具的主要目标是将 JavaScript、CSS 等文件打包在一起，打包后的文件可以在浏览器、Node.js 等环境中使用。当 Bundler 处理 Web\n应用时，它会构建一个依赖关系图，其中包含应用需要的各个模块，然后将所有模块打包成一个或多个 bundle。\n\n\nBuilder#\n\nModern.js Builder 指的是 Modern.js 的构建层，它的目标是为 Modern.js 用户提供开箱即用的构建能力，并支持在 webpack\n和 Rspack 间无缝切换。\n\nModern.js MAJOR_VERSION.46.0 之前版本使用的是 @modern-js/builder, 从 MAJOR_VERSION.46.0\n开始升级为 Rsbuild。\n\n\nCSR#\n\nCSR 是 \"Client-Side Rendering\"（客户端渲染）的缩写。它表示页面是在浏览器中通过 JavaScript\n渲染的，数据获取、模板和路由等逻辑都在浏览器端完成，而不是在服务器上。\n\n在 CSR 中，服务器会向浏览器端发送一个空的 HTML 外壳和一些 JavaScript 脚本，然后由浏览器端从服务器的 API\n中拉取数据，并将动态内容渲染到页面中。\n\n\nGarfish#\n\nGarfish 是一套微前端解决方案，主要用于解决 web 应用的跨团队协作、技术体系多样化等问题。\n\n它从架构层面出发，将多个独立交付的前端应用组成整体，这些前端应用能够独立开发、独立测试、独立部署，但是在用户视角仍然是内聚的单个产品。\n\n\nMicro-frontend#\n\n微前端（Micro-frontend，简称\nMFE）是一种类似于微服务的架构，是一种由独立交付的多个前端应用组成整体的架构风格，它将前端应用分解成一些更小、更简单的能够独立开发、测试、部署的应用，而在用户\n看来仍然是内聚的单个产品。\n\n它主要解决了两个问题：\n\n * 随着项目迭代应用越来越庞大，难以维护。\n\n * 跨团队或跨部门协作开发项目导致效率低下的问题。\n\n\nModule Federation#\n\n模块联邦（Module Federation，简称 MF）是 Webpack 的一个特性。它允许 JavaScript\n应用从另一个应用动态加载代码，并在此过程中共享依赖关系。如果使用联邦模块的应用缺少联邦代码所需的依赖项，Webpack 将从该联邦的构建源下载缺失的依赖项。\n\n这使得可以创建微前端风格的应用程序，多个系统可以共享代码，并在不需要重新构建整个应用程序的情况下进行动态更新。\n\nModern.js 提供了一个 Module Federation 的示例项目，请参考 module-federation-examples -\nmodernjs。\n\n你也可以阅读 webpack Module Federation 文档 来了解更多概念。\n\n\nRsbuild#\n\nRsbuild 是一个基于 Rspack 的 web 构建工具，它的目标是为 Rspack 用户提供开箱即用的构建能力，使开发者能够在零配置的情况下启动一个\nweb 项目。\n\nRsbuild 集成了社区中基于 Rust 的高性能工具，包括 Rspack 和 SWC，以提供一流的构建速度和开发体验。\n\n\nRspack#\n\nRspack 是一个基于 Rust 的高性能 Web 构建工具，具备与 webpack 生态系统的互操作性，可以被 webpack\n项目低成本集成，并提供更好的构建性能。\n\n相较于 webpack，Rspack 的构建性能有明显提升，除了 Rust 带来的语言优势，这也来自于它的并行架构和增量编译等特性。经过 benchmark\n验证，Rspack 可以带来 5 ～ 10 倍编译性能的提升。\n\n\nSSR#\n\nSSR 是 \"Server-Side Rendering\"（服务器端渲染）的缩写。它表示由服务器生成网页的 HTML，并将其发送给客户端，而不是只发送一个空的\nHTML 外壳，并依赖 JavaScript 来生成页面内容。\n\n在传统的客户端渲染中，服务器会向客户端发送一个空的 HTML 外壳和一些 JavaScript 脚本，然后从服务器的 API\n中获取数据，并用动态内容填充页面。这会导致页面的初始加载时间较慢，不利于用户体验和 SEO。\n\n使用 SSR 后，服务器会生成已经包含动态内容的 HTML，并将其发送给客户端。这使得首屏加载速度更快，并对 SEO\n更加友好，因为搜索引擎可以爬取到渲染后的页面。\n\n\nSSG#\n\nSSG 是 \"Static Site Generation\"（静态网站生成）的缩写。它表示网页被预先渲染成静态的\nHTML，然后直接提供给客户端，而不需要服务器实时生成 HTML。\n\n在传统的 SSR 中，每当用户请求一个页面时，服务器就会实时生成 HTML。有了 SSG，HTML 可以在构建过程中被提前生成，并被托管在 CDN\n或其他静态资源服务中。\n\n与传统的 SSR 相比，SSG 可以提供更快的加载速度以及更少的服务端开销，因为不需要维护一个服务器来实时生成 HTML。然而，SSG\n不适合需要动态内容的网站，因为 HTML 是在构建过程中生成的，不支持实时更新。\n\n\nSWC#\n\nSWC (Speedy Web Compiler) 是基于 Rust 语言编写的高性能 JavaScript 和 TypeScript 转译和压缩工具。在\nPolyfill 和语法降级方面可以和 Babel 提供一致的能力，并且性能比 Babel 高出一个数量级。\n\nModern.js 提供了开箱即用的 SWC 插件，可以为你的 Web 应用提供语法降级、Polyfill 以及压缩，并且移植了一些额外常见的 Babel\n插件。","routePath":"/guides/get-started/glossary","lang":"zh","toc":[{"text":"BFF","id":"bff","depth":2,"charIndex":3},{"text":"Bundler","id":"bundler","depth":2,"charIndex":174},{"text":"Builder","id":"builder","depth":2,"charIndex":348},{"text":"CSR","id":"csr","depth":2,"charIndex":552},{"text":"Garfish","id":"garfish","depth":2,"charIndex":748},{"text":"Micro-frontend","id":"micro-frontend","depth":2,"charIndex":880},{"text":"Module Federation","id":"module-federation","depth":2,"charIndex":1081},{"text":"Rsbuild","id":"rsbuild","depth":2,"charIndex":1429},{"text":"Rspack","id":"rspack","depth":2,"charIndex":1591},{"text":"SSR","id":"ssr","depth":2,"charIndex":1800},{"text":"SSG","id":"ssg","depth":2,"charIndex":2115},{"text":"SWC","id":"swc","depth":2,"charIndex":2411}],"domain":"","frontmatter":{"sidebar_position":4},"version":""},{"id":556,"title":"介绍","content":"#\n\nModern.js 是字节跳动 Web 工程体系的开源版本，它提供多个解决方案，来帮助开发者解决不同研发场景下的问题。\n\n目前 Modern.js 包含两个解决方案，分别面向 Web 应用开发场景 和 npm 包开发场景：\n\n\n关于文档#\n\n当前文档站对应的是 Modern.js 框架，适用于开发 Web 应用。\n\n * 如果你需要开发一个 npm 包，请移步 Modern.js Module 文档。\n * 如果你需要一个构建工具来打包 Web 应用，请移步 Rsbuild 文档。\n * 如果你需要开发一个文档站点，推荐使用 Rspress 文档。\n\nTIP\n\n由于 Modern.js 框架的使用最为广泛，在本文档站中，我们会省略「框架」，直接称其为 Modern.js。\n\n\nModern.js 框架#\n\nModern.js 框架是一个基于 React 的渐进式 Web 开发框架。在字节跳动内部，我们将 Modern.js 封装为上层框架，并支撑了数千个 Web\n应用的研发。\n\nModern.js 能为开发者提供极致的开发体验（Development Experience），让应用拥有更好的用户体验（User Experience）。\n\n在开发 React 应用过程中，开发者通常需要去为某些功能去设计实现方案，或是使用其他的库、框架来解决这些问题。Modern.js 支持 React\n应用所需要的所有配置和工具，并内置额外的功能和优化。开发者可以使用 React 构建应用的 UI，然后逐步采用 Modern.js\n的功能来解决常见的应用需求，如路由、数据获取、状态管理等。\n\n它主要包含以下特性：\n\n * 🚀 Rust 构建：提供双构建工具支持，轻松切换到 Rspack 构建工具，编译飞快。\n * 🪜 渐进式：使用最精简的模板创建项目，通过生成器逐步开启插件功能，定制解决方案。\n * 🏠 一体化：开发与生产环境 Web Server 唯一，CSR 和 SSR 同构开发，函数即接口的 API 服务调用。\n * 📦 开箱即用：默认 TS 支持，内置构建、ESLint、调试工具，全功能可测试。\n * 🌏 周边生态：自研状态管理、微前端、模块打包等周边需求。\n * 🕸 多种路由模式：包含自控路由、基于文件约定的路由（嵌套路由）等。\n\n\n和其他框架的对比#\n\n\nNext.js#\n\nNext.js 是社区中最流行的 React 框架之一，由 Vercel 开发。\n\nNext.js 默认使用了 React Server Components，这意味着你需要在服务端渲染你的 Web 应用，并为服务器产生的开销付费；并且\nServer Components 目前不是一项稳定的技术，社区中很多流行的 React 库尚未完成对 RSC 的适配。在目前阶段，你可能需要使用\nNext.js 旧版的 Pages Router 来避免 Server Components 带来的问题。\n\n当你想构建一个单页面应用（SPA），并通过客户端渲染时，Next.js 可能不是一个好的选择，因为它的很多功能都是围绕 Server\n优先来设计的。如果你需要使用客户端渲染，只能通过 Next.js 提供的 \"static exports\" 来使用有限的功能。\n\n而 Modern.js 将客户端渲染（CSR）和服务端渲染（SSR）视为同样重要的场景。当你创建一个 Modern.js\n应用时，它默认是在客户端渲染的，你不需要了解 Server Components 的用法和局限性。你也可以在任何有需要的时候开启\nSSR，甚至可以为一部分页面开启 SSR，整个过程是完全渐进式的。请注意，Modern.js 目前不支持 Server\nComponents，我们会持续观察它的潜力，并在合适的时候支持它。\n\n\nUmi#\n\nUmi 是中文社区中非常流行的 React 框架，也是蚂蚁集团的底层前端框架。Modern.js 和 Umi\n有许多相似之处，比如都支持插件系统、约定式路由、微生成器等。\n\nModern.js 和 Umi 的主要区别在于构建优化方式不同。Umi 采用了 MFSU 技术来提升构建速度，而 Modern.js 则使用 Rspack\n来提升 5 ~ 10 倍构建速度。在我们看来，类似 Rspack 这样的 Rust\n工具更符合前端工具链的长期发展趋势，它可以在性能、稳定性和生态兼容性之间取得较好的平衡。\n\n此外，Modern.js 的服务端能力更加丰富，包括完备的 SSR 能力、一体化 BFF 开发能力和自定义 Web Server\n支持。这些能力经过了字节跳动大量线上应用的验证，可以直接用于生产环境。\n\n\nRemix#\n\n请参考 Modern.js vs Remix。\n\n\n下一步#\n\n如果你希望了解如何使用 Modern.js 框架，可以尝试 创建第一个应用，或是阅读 快速上手。","routePath":"/guides/get-started/introduction","lang":"zh","toc":[{"text":"关于文档","id":"关于文档","depth":2,"charIndex":116},{"text":"Modern.js 框架","id":"modernjs-框架","depth":2,"charIndex":345},{"text":"和其他框架的对比","id":"和其他框架的对比","depth":2,"charIndex":988},{"text":"Next.js","id":"nextjs","depth":3,"charIndex":1000},{"text":"Umi","id":"umi","depth":3,"charIndex":1613},{"text":"Remix","id":"remix","depth":3,"charIndex":1975},{"text":"下一步","id":"下一步","depth":2,"charIndex":2009}],"domain":"","frontmatter":{"title":"介绍","sidebar_position":1},"version":""},{"id":557,"title":"快速上手","content":"#\n\n\n环境准备#\n\n\nNode.js#\n\n在开始使用前，你需要安装 Node.js，并保证 Node.js 版本不低于 16.2.0，我们推荐使用 Node.js 18 的 LTS 版本。\n\n你可以通过以下命令检查当前使用的 Node.js 版本：\n\n\n\n如果你当前的环境中尚未安装 Node.js，或是安装的版本低于 16，可以通过 nvm 或 fnm 安装需要的版本。\n\n下面是通过 nvm 安装 Node.js 18 LTS 版本的例子：\n\n\n\nnvm 和 fnm\n\nnvm 和 fnm 都是 Node.js 版本管理工具。相对来说，nvm 较为成熟和稳定，而 fnm 是使用 Rust 实现的，比 nvm 提供了更好的性能。\n\n此外，在安装 nvm 或 fnm 后，然后只要仓库根目录下有内容为 lts/hydrogen 的 .nvmrc 文件，进入这个仓库时就会自动安装或切换到正确的\nNode.js 版本。\n\n\npnpm#\n\n推荐使用 pnpm 来管理依赖：\n\n\n\nNOTE\n\nModern.js 同样支持使用 yarn、npm 进行依赖管理。\n\n\n安装#\n\nModern.js 提供了 @modern-js/create 工具来创建项目，不需要全局安装，直接使用 npx 按需运行即可。\n\n你可以在已有的空目录来创建项目：\n\n\n\n也可以直接用新目录创建项目：\n\n\n\n\n初始化项目#\n\n@modern-js/create 会提供一个可交互的问答界面，根据结果初始化项目，按照默认的选择进行初始化：\n\n\n\n在生成项目后，Modern.js 会自动安装依赖、创建 git 仓库。\n\n\n\n现在，项目结构如下：\n\n\n\n\n启动项目#\n\n在项目中执行 pnpm run dev 即可启动项目：\n\n\n\n在浏览器中打开 http://localhost:8000/，可以看到页面内容。\n\n\n使用配置#\n\n通过 @modern-js/create 创建的 Modern.js 项目中，会默认生成 modern.config.ts 文件。\n\n你可以通过该配置文件修改配置，覆盖 Modern.js 的默认行为。例如添加如下配置，开启 SSR：\n\n\n\n重新执行 pnpm run dev，在浏览器 Network 菜单中，可以发现项目已经在服务端完成了页面渲染。\n\n\n核心 npm 包#\n\n在新创建的工程中，默认会安装 @modern-js/app-tools npm 包，它是 Modern.js 框架的核心包，主要提供以下能力：\n\n * 提供 modern dev, modern build 等常用的 CLI 命令。\n * 集成 Modern.js Core，提供配置解析、插件加载等能力。\n * 集成 Modern.js Builder，提供构建能力。\n * 集成 Modern.js Server，提供开发和生产服务器相关能力。\n * 集成一些最为常用的插件，比如 plugin-lint、plugin-data-loader 等。\n\n@modern-js/app-tools 是基于 Modern.js 的插件体系实现的，本质上是一个插件，因此你需要在配置文件的 plugins 字段中注册\nappTools：\n\n\n\n\n构建项目#\n\n在项目中执行 pnpm run build 即可构建项目生产环境产物：\n\n\n\n构建产物默认生成到 dist/，目录结构如下：\n\n\n\n> 如果你需要自定义构建产物的目录，请参考 构建产物目录。\n\n\n本地验证#\n\n在项目中执行 pnpm run serve 即可在本地验证构建产物是否正常运行：\n\n\n\n在浏览器中打开 http://localhost:8000/，内容应该和 pnpm run dev 时一致。\n\n\n部署#\n\n本地验证完成后，可以将 dist/ 下的产物整理成服务器需要的结构，进行部署。","routePath":"/guides/get-started/quick-start","lang":"zh","toc":[{"text":"环境准备","id":"环境准备","depth":2,"charIndex":3},{"text":"Node.js","id":"nodejs","depth":3,"charIndex":11},{"text":"pnpm","id":"pnpm","depth":3,"charIndex":412},{"text":"安装","id":"安装","depth":2,"charIndex":481},{"text":"初始化项目","id":"初始化项目","depth":2,"charIndex":591},{"text":"启动项目","id":"启动项目","depth":2,"charIndex":712},{"text":"使用配置","id":"使用配置","depth":2,"charIndex":793},{"text":"核心 npm 包","id":"核心-npm-包","depth":2,"charIndex":979},{"text":"构建项目","id":"构建项目","depth":2,"charIndex":1361},{"text":"本地验证","id":"本地验证","depth":2,"charIndex":1466},{"text":"部署","id":"部署","depth":2,"charIndex":1574}],"domain":"","frontmatter":{"title":"快速上手","sidebar_position":2},"version":""},{"id":558,"title":"技术栈","content":"#\n\nModern.js 框架默认集成了一些社区中流行的库和开发工具。\n\n在这篇文档中，你可以了解到 Modern.js 框架涉及的主要技术栈，以及一些可选的库和工具。\n\n\nUI 库#\n\nModern.js 使用 React 18 来构建用户界面，同时也兼容 React 17。\n\nModern.js 底层的 Rsbuild 支持构建 Vue 应用，如果你需要使用 Vue，可以参考「Rsbuild - Vue」。\n\n\n路由#\n\nModern.js 的路由基于 React Router 6，同时也兼容 React Router 5。\n\nModern.js 支持约定式路由、自控式路由或其他路由方案，请参考「路由方案」 进行选择。\n\n\n微前端#\n\nModern.js 提供对 Garfish 微前端框架开箱即用的支持。\n\n同时，我们也正在与 Module Federation 的作者 Zack Jackson 合作，以提供更完整的解决方案。\n\n\n状态管理#\n\nModern.js 可以与社区中任意的状态管理库搭配使用，比如 Redux、Jotai、Zustand、Valtio 等。\n\nModern.js 也基于 Redux 封装了 Reduck 状态管理库，你可以参考 「Reduck 状态管理」来使用。\n\n\n包管理器#\n\nModern.js 可以与社区中任意的包管理器搭配使用，比如 npm、yarn、pnpm 或 Bun。\n\n我们推荐使用 pnpm 来获得更快的安装速度。\n\n\n打包工具#\n\nModern.js 使用 Webpack 5 或 Rspack 来打包你的 Web 应用。\n\n默认使用的打包工具为 Webpack 5，你可以参考「使用 Rspack」 来切换到更快的 Rspack。\n\n\n转译工具#\n\nModern.js 使用 Babel、SWC 或 esbuild 作为 JS 转译工具，将 TypeScript 或 JSX 转义为可以在浏览器上运行的\nJavaScript 代码，并进行语法降级。\n\n * 使用 Webpack 打包时，默认为 Babel，支持切换到 SWC 或 esbuild。\n * 使用 Rspack 打包时，默认为 SWC，支持切换到 Babel。\n\n\n压缩工具#\n\n在生产环境构建时，Modern.js 使用 Terser、SWC 或 esbuild 来压缩 JavaScript 代码，使用 cssnano 来压缩 CSS\n代码。\n\n * 使用 Webpack 打包时，默认使用 Terser 压缩 JS 代码，支持切换到 SWC 或 esbuild。\n * 使用 Rspack 打包时，默认使用 SWC 压缩 JS 代码，暂不支持切换到其他工具。\n\n\nCSS 转换#\n\nModern.js 使用 PostCSS 来转换 CSS 代码，并默认开启 autoprefixer 来补全 CSS 前缀。\n\nModern.js 支持「启用 Tailwind CSS」，并同时兼容 Tailwind CSS v2 和 v3 版本。\n\n\nCSS 预处理器#\n\nModern.js 支持 Sass、Less 和 Stylus 三种 CSS 预处理器：\n\n * 默认支持 Sass 和 Less，开箱即用。\n * 可选支持 Stylus，请参考「Stylus 插件」 来使用。\n\n\nCSS Modules#\n\nModern.js 对 CSS Modules 提供了开箱即用的支持，内部基于 css-loader 实现。\n\n请参考「使用 CSS Modules」 来使用。\n\n\nCSS-in-JS#\n\nModern.js 支持使用 styled-components，请参考「使用 CSS-in-JS」 来使用。\n\n如果你需要使用其他 CSS-in-JS 方案，可以自行集成到你的项目中。\n\n\n组件库#\n\nModern.js 可以与社区中任意的 React 组件库搭配使用，比如 MUI、Ant Design、Arco Design、Semi\nDesign、Radix UI 等。\n\n同时，Modern.js 内置了对 Ant Design 和 Arco Design 的 按需引入 支持。\n\n\n组件开发#\n\nModern.js 支持使用 Storybook 来开发 UI 组件。该功能为可选功能，请参考「使用 Storybook」 启用。\n\n\nNode.js 框架#\n\nModern.js 支持 Express.js 和 Koa.js 作为可选的 BFF 运行时框架，请参考「BFF - 运行时框架」。","routePath":"/guides/get-started/tech-stack","lang":"zh","toc":[{"text":"UI 库","id":"ui-库","depth":2,"charIndex":86},{"text":"路由","id":"路由","depth":2,"charIndex":209},{"text":"微前端","id":"微前端","depth":2,"charIndex":317},{"text":"状态管理","id":"状态管理","depth":2,"charIndex":423},{"text":"包管理器","id":"包管理器","depth":2,"charIndex":556},{"text":"打包工具","id":"打包工具","depth":2,"charIndex":642},{"text":"转译工具","id":"转译工具","depth":2,"charIndex":752},{"text":"压缩工具","id":"压缩工具","depth":2,"charIndex":949},{"text":"CSS 转换","id":"css-转换","depth":2,"charIndex":1151},{"text":"CSS 预处理器","id":"css-预处理器","depth":2,"charIndex":1287},{"text":"CSS Modules","id":"css-modules","depth":2,"charIndex":1407},{"text":"CSS-in-JS","id":"css-in-js","depth":2,"charIndex":1504},{"text":"组件库","id":"组件库","depth":2,"charIndex":1612},{"text":"组件开发","id":"组件开发","depth":2,"charIndex":1763},{"text":"Node.js 框架","id":"nodejs-框架","depth":2,"charIndex":1838}],"domain":"","frontmatter":{"sidebar_position":4},"version":""},{"id":559,"title":"版本升级","content":"#\n\n\n通过命令行升级#\n\nModern.js 提供了 upgrade 命令支持项目升级到最新的 Modern.js 版本。\n\n在项目中执行 upgrade 命令：\n\n\n\n可以看到项目 package.json 中的依赖已经更改到最新。\n\nTIP\n\n如果项目的 package.json 中没有声明 upgrade 命令，你可以执行 npx modern upgrade，效果是等价的。\n\n\n指定版本升级#\n\nModern.js 所有的官方包目前都使用统一版本号进行发布。\n\n根据官网 Release Note，开发者也可以手动将项目升级到想要的版本。\n\nTIP\n\n当升级时，需要对 Modern.js 官方提供的所有包做统一升级，而不是升级单个依赖。\n\n\n锁定子依赖#\n\n当项目某个子依赖出现问题，而 Modern.js 无法立即更新时，可以使用包管理器锁定子依赖版本。\n\n\npnpm#\n\n对于使用 pnpm 的项目，请在项目根目录的 package.json 中添加以下配置，然后重新执行 pnpm install：\n\n\n\n\nYarn#\n\n对于使用 Yarn 的项目，请在项目根目录的 package.json 中添加以下配置，然后重新执行 yarn install：\n\n\n\n\nNpm#\n\n对于使用 Npm 的项目，请在项目根目录的 package.json 中添加以下配置，然后重新执行 npm install：\n\n\n\nINFO\n\n对于 Monorepo 仓库，只能在项目根目录的 package.json 中锁定依赖版本，并且会影响 Monorepo 中的所有 package。","routePath":"/guides/get-started/upgrade","lang":"zh","toc":[{"text":"通过命令行升级","id":"通过命令行升级","depth":2,"charIndex":3},{"text":"指定版本升级","id":"指定版本升级","depth":2,"charIndex":195},{"text":"锁定子依赖","id":"锁定子依赖","depth":2,"charIndex":328},{"text":"pnpm","id":"pnpm","depth":3,"charIndex":388},{"text":"Yarn","id":"yarn","depth":3,"charIndex":464},{"text":"Npm","id":"npm","depth":3,"charIndex":540}],"domain":"","frontmatter":{"sidebar_position":3},"version":""},{"id":560,"title":"扩展插件 Hook","content":"#\n\n本小节介绍如何通过动态注册 Hook 模型 的方式来扩展插件 Hook。\n\n\n示例#\n\n这里我们用一个简单的例子演示一下。假设我们要添加一些管理控制台输出信息的 Hook。\n\n首先我们初始化一个空的项目文件，并添加基础依赖：\n\n\n\n\n创建 Hook#\n\n我们先创建一个 Hook 模型：\n\n\n\n然后注册它：\n\n\n\n添加 Hook 类型：\n\n\n\n\n使用 Hook#\n\n创建插件，通过 commands Hook 函数，添加命令处理逻辑：\n\n\n\n最后 config/plugin/myPlugin.ts 的状态是：\n\n\n\n然后在 modern.config.ts 中添加这个插件：\n\n\n\n这时运行 npx modern message 就会执行相关逻辑，但由于没有收集到任何信息，所以控制台输出为空。\n\n那这里我们添加一个：\n\n\n\n将它添加到配置中：\n\n\n\n这时运行 npx modern message 就可以在控制台看到信息了：\n\n\n\n以上面这种方式就可以扩展出拥有各种能力的插件 Hook。","routePath":"/guides/topic-detail/framework-plugin/extend","lang":"zh","toc":[{"text":"示例","id":"示例","depth":2,"charIndex":41},{"text":"创建 Hook","id":"创建-hook","depth":3,"charIndex":119},{"text":"使用 Hook","id":"使用-hook","depth":3,"charIndex":175}],"domain":"","frontmatter":{"sidebar_position":5},"version":""},{"id":561,"title":"Hook 列表","content":"#\n\nModern.js 工程体系中包含三类插件：CLI、Runtime、Server，每一类插件可以使用不同的 Hooks。\n\n在本章节中，罗列了所有可用的 Hooks，你可以根据自己的需求来使用对应的 Hook。\n\n\nCLI Common Hooks#\n\n以下是通用的 CLI Hooks，可以在 Modern.js Framework 以及 Modern.js Module 中使用。\n\n\nbeforeConfig#\n\n * 功能：运行收集配置前的任务\n * 执行阶段：收集配置前\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow\n * 使用示例：\n\n\n\n\nconfig#\n\n * 功能：收集配置\n * 执行阶段：解析完 modern.config.ts 中的配置之后\n * Hook 模型：ParallelWorkflow\n * 类型：ParallelWorkflow\n * 使用示例：\n\n\n\n如果你需要设置 Modern.js Framework 的配置，请使用 @modern-js/app-tools 导出的 CliPlugin 类型：\n\n\n\n插件在 config hook 中返回的配置信息，会被 Modern.js 统一收集与合并，最终生成一份\nNormalizedConfig。在进行配置合并时，优先级由高到低依次为：\n\n 1. 用户在 modern.config.* 文件里定义的配置\n 2. 插件通过 config hook 定义的配置\n 3. Modern.js 默认配置。\n\n\nprepare#\n\n * 功能：运行主流程的前置准备流程\n * 执行阶段：校验完配置之后\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow\n * 使用示例：\n\n\n\n\nafterPrepare#\n\n * 功能：运行前置准备流程的之后的任务\n * 执行阶段：前置准备流程之后\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow\n * 使用示例：\n\n\n\n\ncommands#\n\n * 功能：为 commander 添加新的 CLI 命令\n * 执行阶段：prepare Hook 运行完成之后\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow<{ program: Command; }, void>\n * 使用示例：\n\n\n\n将上面这个插件添加到 modern.config.ts 中：\n\n\n\n运行 modern foo 就可以看到控制台输出：\n\n\n\n\nbeforeExit#\n\n * 功能：在退出进程前，重置一些文件状态\n * 执行阶段：进程退出之前\n * Hook 模型：Workflow\n * 类型：Workflow\n * 使用示例：\n\n\n\nTIP\n\n由于 Node.js 中退出进程时的回调函数是同步的，所以 beforeExit Hook 的类型是 Workflow，不能执行异步操作。\n\n\nCLI Framework Hooks#\n\n以下是框架的 CLI Hooks，只能在 Modern.js Framework 中使用，不能在 Modern.js Module 中使用。\n\n你需要从 @modern-js/app-tools 中导入 CliPlugin 和 AppTools 类型，以获得准确的 Hooks 类型提示。\n\n\nbeforeDev#\n\n * 功能：运行 dev 主流程的之前的任务\n * 执行阶段：dev 命令运行时，项目开始启动前执行\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow\n * 使用示例：\n\n\n\n\nafterDev#\n\n * 功能：运行 dev 主流程的之后的任务\n * 执行阶段：运行 dev 命令时，每一次编译完成后执行\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow<{ isFirstCompile: boolean }, unknown>\n * 使用示例：\n\n\n\nafterDev 会在每一次编译完成后执行，你可以通过 isFirstCompile 参数来判断是否为首次编译：\n\n\n\n\nbeforeBuild#\n\n * 功能：在执行生产环境构建前触发的回调函数，你可以通过 bundlerConfigs 参数获取到底层打包工具的最终配置数组。\n   * 如果当前打包工具为 webpack，则获取到的是 webpack 配置数组。\n   * 如果当前打包工具为 Rspack，则获取到的是 Rspack 配置数组。\n   * 配置数组中可能包含一份或多份配置，这取决于你是否开启了 SSR 等功能。\n * 执行阶段：运行 build 命令后，在开始构建前执行\n * Hook 模型：AsyncWorkflow\n * 类型：\n\n\n\n * 使用示例：\n\n\n\n\nafterBuild#\n\n * 功能：在执行生产环境构建后触发的回调函数，你可以通过 stats 参数获取到构建结果信息。\n   * 如果当前打包工具为 webpack，则获取到的是 webpack Stats。\n   * 如果当前打包工具为 Rspack，则获取到的是 Rspack Stats。\n * 执行阶段：运行 build 命令运行后，在项目构建完成之后执行\n * Hook 模型：AsyncWorkflow\n * 类型：\n\n\n\n * 使用示例：\n\n\n\n\nbeforeCreateCompiler#\n\n * 功能：在创建底层 Compiler 实例前触发的回调函数，并且你可以通过 bundlerConfigs 参数获取到底层打包工具的最终配置数组：\n   * 如果当前打包工具为 webpack，则获取到的是 webpack 配置数组。\n   * 如果当前打包工具为 Rspack，则获取到的是 Rspack 配置数组。\n   * 配置数组中可能包含一份或多份配置，这取决于你是否开启了 SSR 等功能。\n * 执行阶段：在执行 dev 或 build 命令时，创建 Compiler 实例之前执行\n * Hook 模型：AsyncWorkflow\n * 类型：\n\n\n\n * 使用示例：\n\n\n\n\nafterCreateCompiler#\n\n * 功能：在创建 Compiler 实例后、执行构建前触发的回调函数，并且你可以通过 compiler 参数获取到 Compiler 实例对象：\n   * 如果当前打包工具为 webpack，则获取到的是 webpack Compiler 对象。\n   * 如果当前打包工具为 Rspack，则获取到的是 Rspack Compiler 对象。\n * 执行阶段：创建 Compiler 对象之后执行\n * Hook 模型：AsyncWorkflow\n * 类型：\n\n\n\n * 使用示例：\n\n\n\n\nbeforePrintInstructions#\n\n * 功能：在中间件函数中可以拿到即将打印的日志信息，并对其进行修改\n * 执行阶段：打印日志信息之前执行\n * Hook 模型：AsyncWaterfall\n * 类型：AsyncWaterfall<{ instructions: string }>\n * 使用示例：\n\n\n\n\nmodifyFileSystemRoutes#\n\n * 功能：用于修改生成前端页面路由文件中的内容，内容都是需要可序列化的\n * 执行阶段：生成前端路由文件之前，prepare 阶段触发\n * Hook 模型：AsyncWaterfall\n * 类型：AsyncWaterfall<{ entrypoint: Entrypoint; routes: Route[]; }>\n * 使用示例：\n\n\n\n这样就为前端新增了一个页面路由。\n\n\nmodifyServerRoutes#\n\n * 功能：用于修改生成服务器路由中的内容\n * 执行阶段：生成 Server 路由文件之前，prepare 阶段触发\n * Hook 模型：AsyncWaterfall\n * 类型：AsyncWaterfall<{ routes: ServerRoute[]; }>\n * 使用示例：\n\n\n\n\nhtmlPartials#\n\n * 功能：用于定制生成的 HTML 页面模版\n * 执行阶段：prepare 阶段触发\n * Hook 模型：AsyncWaterfall\n * 类型：AsyncWaterfall<{ entrypoint: Entrypoint; partials: HtmlPartials; }>\n * 使用示例：\n\n\n\n这样就为 HTML 模版中新增了一个 Script 标签。\n\n\nRuntime#\n\nNOTE\n\n目前 Runtime 插件还未完全开放，API 不保证稳定，使用需谨慎。\n\nRuntime 插件主要用于开发者自定义应用渲染前行为和修改需要渲染的组件。\n\n\nbeforeRender#\n\n * 功能：在应用渲染之前增加行为\n * 执行阶段：渲染（SSR/CSR）\n * Hook 模型：AsyncWorkflow\n * 类型：AsyncWorkflow\n * 使用示例：\n\n\n\n\nwrapRoot#\n\n * 功能：修改需要渲染的组件\n * 执行阶段：渲染（SSR/CSR）\n * Hook 模型：Waterfall\n * 类型：Waterfall>\n * 使用示例：\n\n","routePath":"/guides/topic-detail/framework-plugin/hook-list","lang":"zh","toc":[{"text":"CLI Common Hooks","id":"cli-common-hooks","depth":2,"charIndex":110},{"text":"`beforeConfig`","id":"beforeconfig","depth":3,"charIndex":-1},{"text":"`config`","id":"config","depth":3,"charIndex":-1},{"text":"`prepare`","id":"prepare","depth":3,"charIndex":-1},{"text":"`afterPrepare`","id":"afterprepare","depth":3,"charIndex":-1},{"text":"`commands`","id":"commands","depth":3,"charIndex":-1},{"text":"`beforeExit`","id":"beforeexit","depth":3,"charIndex":-1},{"text":"CLI Framework Hooks","id":"cli-framework-hooks","depth":2,"charIndex":1279},{"text":"`beforeDev`","id":"beforedev","depth":3,"charIndex":-1},{"text":"`afterDev`","id":"afterdev","depth":3,"charIndex":-1},{"text":"`beforeBuild`","id":"beforebuild","depth":3,"charIndex":-1},{"text":"`afterBuild`","id":"afterbuild","depth":3,"charIndex":-1},{"text":"`beforeCreateCompiler`","id":"beforecreatecompiler","depth":3,"charIndex":-1},{"text":"`afterCreateCompiler`","id":"aftercreatecompiler","depth":3,"charIndex":-1},{"text":"`beforePrintInstructions`","id":"beforeprintinstructions","depth":3,"charIndex":-1},{"text":"`modifyFileSystemRoutes`","id":"modifyfilesystemroutes","depth":3,"charIndex":-1},{"text":"`modifyServerRoutes`","id":"modifyserverroutes","depth":3,"charIndex":-1},{"text":"`htmlPartials`","id":"htmlpartials","depth":3,"charIndex":-1},{"text":"Runtime","id":"runtime","depth":2,"charIndex":3656},{"text":"`beforeRender`","id":"beforerender","depth":3,"charIndex":-1},{"text":"`wrapRoot`","id":"wraproot","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"sidebar_position":8},"version":""},{"id":562,"title":"Hook 模型","content":"#\n\n首先介绍一下 Modern.js 的基础的插件系统中的一些内容，包括 Hook 模型的工作方式、各个 Hook 模型的运行模式、Manager 的工作模式。\n\n每种 Hook 模型都是独立的，可以独立管理运行函数。\n\n\n基础工作方式#\n\n先以 Pipeline 为例，简单介绍一下 Hook 模型的工作方式。先看一个简单的例子：\n\n\n\n在这个例子中，创建了一个 Pipeline 类型的 Pipeline（L3），这意味着运行它的时候，你需要传入一个 number，然后你会得到一个\nnumber，而这个模型管理的函数的类型是：\n\n\n\n这里全是 number，是因为我们创建的是 Pipeline ，如果创建的是 Pipeline 则运行它入参是 number，返回值是\nstring，对应管理的函数的类型会是：\n\n\n\n创建好 Pipeline 之后，可以通过 use 添加函数（L5、L8），需要注意的是，添加的顺序就是他们默认的运行顺序，在这些函数中，你可以对 count\n进行处理、返回一个值，如果你调用了 next 函数，则会运行后面的函数，即如果你添加了三个函数： A、B、C，如果你在 A 中调用 next 那么就会运行\nB，同样的，如果你在 B 中调用 next 那么就会运行 C，而在上面的例子中，添加的第一个函数（L5）就运行了\nnext，所以这里就会运行第二个函数（L8），并且运行的返回值就是 第二个函数的返回值，如果在第一个函数中没有调用 next，直接返回，例如：\n\n\n\n则在运行 Pipeline 的时候就不会运行第二个函数，那么 Pipeline 的运行结果则就是第一个函数的返回值。\n\n最后，运行 Pipeline 的方式也显而易见就是调用 pipeline.run 。\n\n\n不同 Hook 模型的区别#\n\n上面这部分就是 Pipeline 整体的一个工作模式的描述，其他的 Hook 模型的工作模式基本也是这样，主要的区别点，是函数类型、执行顺序，参数。\n\n\nPipeline#\n\n上面的例子就是以 Pipeline 为例描述的，这里就不赘述了，在 Pipeline 这个大类中，提供了两个小类：Sync 和\nAsync，顾名思义，它们的区别就是管理的函数的类型是 Sync 的还是 Async 的。\n\nINFO\n\n当 Pipeline 中没有函数或者所有函数都调用了 next 函数，则就需要在运行的时候提供：\n\n\n\n\nWaterfall#\n\n这种模型顾名思义，他的特点就是参数的顺序递交，即前面一个函数的返回值，将会成为下一个函数的入参，我们也用一个例子来看一下：\n\n\n\n这个例子中，创建了一个类型为 Waterfall ，即这个模型执行的入参和返回值是一样的，这个例子中都是 number，而它管理的函数的类型是：\n\n\n\n可能简单看这个例子感觉和上面的 Pipeline 功能一样，那需要注意的是，首先这里 Waterfall 管理的函数没有 next\n函数作为第二个参数，所以它无法在函数内部通过调用 next 来先运行之后添加的函数，从而修改运行的顺序，其次这里的运行的入参的类型和返回值的类型必须是一样的（而\nPipeline 可以不一样）。\n\n同样的，在 Waterfall 这个大类中，也提供了 Sync 和 Async 的小类，分别对应 Sync 和 Async 的函数。\n\n\nWorkflow#\n\n这种 Hook 模型与上面两种 Hook\n模型的区别是，没有那么强的前后参数返回值递交的概念，在这个模型中，每个函数都是基于同样的入参，相对独立运行的，通过一个例子简单看一下：\n\n\n\n在这个例子中，添加了两个函数，所以运行的结果就是这两个函数运行的结果形成的一个数组。\n\n虽然这种模型中没有那么强的前后参数返回值递交的概念，但依旧有执行顺序的区别，在 Workflow\n这个大类中，提供了三个小类：Sync、Async、Parallel。他们之间的区别就是函数的执行顺序，当然默认的都是按照添加顺序执行，而在 Sync、Async\n则是强制按照添加顺序执行，而 Parallel 则是 Async 模式的一个变体，即它使用的是 Promise.all 来执行所有函数，而 Async 则会\nawait 前面的函数运行结束。\n\n\nHook 模型对比#\n\nWorkflow、Waterfall 其实都是 Pipeline 的变体，Pipeline 可以通过特定的写法来实现\nWorkflow、Waterfall，但都较为麻烦，有许多隐形的约定。为了方便使用，提供了这两种变体来满足这种特殊场景。","routePath":"/guides/topic-detail/framework-plugin/hook","lang":"zh","toc":[{"text":"基础工作方式","id":"基础工作方式","depth":2,"charIndex":112},{"text":"不同 Hook 模型的区别","id":"不同-hook-模型的区别","depth":2,"charIndex":756},{"text":"Pipeline","id":"pipeline","depth":3,"charIndex":849},{"text":"Waterfall","id":"waterfall","depth":3,"charIndex":1030},{"text":"Workflow","id":"workflow","depth":3,"charIndex":1417},{"text":"Hook 模型对比","id":"hook-模型对比","depth":2,"charIndex":1792}],"domain":"","frontmatter":{"sidebar_position":2},"version":""},{"id":563,"title":"如何编写插件","content":"#\n\n上一小节介绍了 Modern.js 插件的 Hook 模型，这一小节介绍如何编写插件。\n\n\n实现插件#\n\nModern.js 插件是一个对象，对象包含以下属性：\n\n * name: 插件的名称，唯一标识符。\n * setup: 插件初始化函数，只会执行一次。setup 函数可以返回一个 Hooks 对象，Modern.js 会在特定的时机执行这些 Hooks。\n\n\n\n另外，在插件中，允许配置与其他插件的执行顺序。详情可以参考插件关系。\n\n\n插件类型#\n\nModern.js 支持多种工程开发，如应用开发（Modern.js Framework）, 模块开发（Modern.js Module）等。\n\n为了兼顾不同工程开发的差异和通性，Modern.js 将插件如下图进行组织:\n\n\n\n从图可以看出，Modern.js 将插件大致分为两类:\n\n 1. 通用插件: 插件只会包含一些基础的 Hooks\n\n 2. 工程插件: 不同的工程开发会在通用插件的基础上扩展出自己的 Hooks, Config 等类型。\n\n使用 TypeScript 时，可以引入内置的 CliPlugin 等类型，为插件提供正确的类型推导。\n\n\n\n上述代码为通用插件，只包含一些基础的 Hooks。 Modern.js 支持通过泛型对插件的定义进行扩展：\n\n\n\n如果仔细观察 AppTools 这个类型，可以发现 AppTools 由 3 种类型构成.\n\n\n\n当编写插件时，插件通过泛型扩展在不同的基础上扩展自己的 Hooks 等类型:\n\n\n\n\n\n详细说明，请参考 扩展 Hook。\n\n\n插件配置项#\n\n建议将插件写成函数的形式，使插件能通过函数入参来接收配置项：\n\n\n\n\n插件 API#\n\n插件的 setup 函数会接收一个 api 入参，你可以调用 api 上提供的一些方法来获取到配置、应用上下文等信息。\n\n\n\n插件 API 的详细说明，请参考 Plugin API。\n\n\n异步 setup#\n\nCLI 插件的 setup 可以是一个异步函数，在初始化过程中执行异步逻辑。\n\n\n\n注意，只有当前插件的 setup 异步函数执行完毕，才会继续执行下一个插件的 setup 函数。因此，你需要避免在 setup\n函数中进行耗时过长的异步操作，防止影响 CLI 启动性能。\n\n\n添加插件#\n\n自定义插件的使用方式可以查看：plugins (框架插件)。下面会介绍 Modern.js 中推荐的插件实现方法。\n\n\n开发本地插件#\n\n本地插件推荐写在 config/plugin 目录下，并通过 export default 导出：\n\n\n\n然后在 modern.config.ts 中注册对应的插件：\n\n\n\n\n在 npm 上发布插件#\n\n如果你需要将 Modern.js 插件发布到 npm，推荐使用 Modern.js Module 来管理和构建。\n\n首先创建一个空的 Modern.js Module 项目，调整 npm 包名称：\n\n\n\n然后新建对应的插件文件：\n\n\n\n发布之后，安装到需要使用的项目 pnpm add my-plugin，这里以一个应用项目为例，然后在 modern.config.ts 中添加：\n\n\n\n如果你发现目前 Modern.js 存在无法满足的场景，欢迎通过编写自定义插件的方式来一起建设 Modern.js 生态。","routePath":"/guides/topic-detail/framework-plugin/implement","lang":"zh","toc":[{"text":"实现插件","id":"实现插件","depth":2,"charIndex":48},{"text":"插件类型","id":"插件类型","depth":3,"charIndex":224},{"text":"插件配置项","id":"插件配置项","depth":3,"charIndex":683},{"text":"插件 API","id":"插件-api","depth":3,"charIndex":726},{"text":"异步 setup","id":"异步-setup","depth":3,"charIndex":829},{"text":"添加插件","id":"添加插件","depth":2,"charIndex":978},{"text":"开发本地插件","id":"开发本地插件","depth":3,"charIndex":1045},{"text":"在 npm 上发布插件","id":"在-npm-上发布插件","depth":3,"charIndex":1142}],"domain":"","frontmatter":{"sidebar_position":3},"version":""},{"id":564,"title":"介绍","content":"#\n\n\nModern.js 插件系统#\n\nModern.js 提供了一套拥有完整生命周期的插件系统。插件可用于扩展项目运行、请求、渲染等不同阶段功能，\n\n\n使用方式#\n\n插件需要在配置文件中显式注册才能够生效，当需要为 Modern.js 添加插件时，可以将它配置到 plugins 字段中：\n\n\n\nNOTE\n\n注意，该配置仅支持添加 Modern.js 插件，无法添加 Webpack 插件。\n\n\n官方插件#\n\nModern.js 提供了一系列官方插件，并与 Modern.js 生成器结合。所有的官方插件功能，都可以通过执行 new 命令开启。例如当需要开启 BFF\n功能时：\n\n\n\n完成选择后，Modern.js 生成器会自动安装对应的插件和三方依赖，安装完成后可以看到：\n\n\n\n此时，可以按照控制台的输出，将插件添加到配置文件中。\n\n\n插件系统组成#\n\nModern.js 插件系统主要分为三个部分：Hook 模型、管理器，上下文共享机制。\n\n * Hook 模型用于确定当前 Hook 的执行逻辑。\n * 管理器用于控制 Hook 的执行与调度。\n * 上下文共享机制用于在不同 Hook 间传递信息。\n\n目前 Modern.js 提供几种不同的 Hook 模型：Pipeline、Waterfall、Workflow。\n\nNOTE\n\n后续章节详细介绍各个模型的执行方式。\n\nModern.js 基于 Hook 模型暴露了三套插件：CLI、Runtime、Server。\n\n其中 CLI 插件是 Modern.js 中主要的运行流程控制模型，Modern.js 中绝大部分功能都是主要通过这一套模型运行的。Runtime\n插件主要负责处理 React 组件渲染逻辑。Server 插件主要用于对服务端的生命周期以及用户请求的控制。\n\n\n插件可以做什么#\n\nModern.js 的所有功能都是通过这套插件实现的，这意味着 Modern.js\n中的所有能力是都对开发者开放的。开发者可以通过编写插件来扩展更多功能，适配复杂场景，包括但不限于：\n\n * 注册命令\n * 修改 Modern.js 配置、配置校验 Schema\n * 修改编译时的 Webpack/Babel/Less/Sass/Tailwind CSS/... 配置\n * 修改运行时需要渲染的 React 组件、Element\n * 修改页面路由\n * 修改服务器路由\n * 自定义控制台输出\n * 自定义动态 HTML 模版\n * 自定义 Node.js 服务器框架\n * 自定义 React 组件客户端/服务器端渲染\n * ...\n\n当 Modern.js 暂时没有覆盖到所需要的功能或场景时，可以开发一个自定义插件，来实现适配特殊场景的相关功能。","routePath":"/guides/topic-detail/framework-plugin/introduction","lang":"zh","toc":[{"text":"Modern.js 插件系统","id":"modernjs-插件系统","depth":2,"charIndex":3},{"text":"使用方式","id":"使用方式","depth":2,"charIndex":77},{"text":"官方插件","id":"官方插件","depth":2,"charIndex":199},{"text":"插件系统组成","id":"插件系统组成","depth":2,"charIndex":371},{"text":"插件可以做什么","id":"插件可以做什么","depth":2,"charIndex":772}],"domain":"","frontmatter":{"sidebar_position":1},"version":""},{"id":565,"title":"生命周期","content":"#\n\nModern.js 应用具有完整的生命周期，包括 CLI、Server Side 和 Runtime 三个阶段。\n\n目前 Modern.js 大致的生命周期如下：\n\nNOTE\n\n其中粉色框的矩形代表 Modern.js 提供的插件钩子，淡黄色底色椭圆代表与下一个阶段的连接点。\n\n","routePath":"/guides/topic-detail/framework-plugin/lifecycle","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_position":1},"version":""},{"id":566,"title":"插件 API","content":"#\n\n插件的 setup 函数会接收一个 api 入参，你可以调用 api 上提供的一些方法来获取到配置、应用上下文等信息。\n\n\n\n\nAPI#\n\n\nuseConfigContext#\n\n用于获取应用原始配置。\n\n\n\n具体配置字段的意义请参考 配置。\n\nTIP\n\n该方法获取到的是只读配置，不可修改。如果需要修改配置，请使用 config hook。\n\n\nuseResolvedConfigContext#\n\n用于获取被解析、合并之后的最终配置。\n\n\n\n配置字段的完整内容请参考 配置。\n\nTIP\n\n该方法获取到的是只读配置，不可修改。如果需要修改配置，请使用 config hook。\n\n\nuseAppContext#\n\n用于获取应用运行上下文。\n\n\n\nTIP\n\nAppContext 中的部分字段是动态设置的，会随着程序的运行而变化。因此，当插件在不同的时机读取字段时，可能会获取到不同的值。\n\n\nuseHookRunners#\n\n用于获取 Hooks 的执行器，并触发特定的 Hook 执行。\n\n\n\nTIP\n\n请尽量避免执行框架内置的 hooks，否则可能会导致框架内部的运行逻辑出错。","routePath":"/guides/topic-detail/framework-plugin/plugin-api","lang":"zh","toc":[{"text":"API","id":"api","depth":2,"charIndex":66},{"text":"useConfigContext","id":"useconfigcontext","depth":3,"charIndex":73},{"text":"useResolvedConfigContext","id":"useresolvedconfigcontext","depth":3,"charIndex":176},{"text":"useAppContext","id":"useappcontext","depth":3,"charIndex":294},{"text":"useHookRunners","id":"usehookrunners","depth":3,"charIndex":399}],"domain":"","frontmatter":{"sidebar_position":6},"version":""},{"id":567,"title":"插件之间的关系","content":"#\n\nModern.js 的插件配置对象提供了一系列的字段，用于控制插件顺序、互斥等能力，可用的字段如下：\n\n * name: string，设置当前插件的名称。\n * pre: string[]，这些插件最终会调整到当前插件前面。\n * post: string[]，这些插件最终会调整到当前插件后面。\n * rivals: string[]，互斥插件，遇到这些插件时会报错。\n * required: string[]，必需插件，插件列表中没有对应的插件时会报错。\n * usePlugin: CliPlugin[]，注册其他插件。\n\n通过以上参数可以实现插件的前置、后置、互斥、必需等逻辑。\n\n\n插件排序#\n\nModern.js 的插件通过 pre、post 参数来实现了插件排序的功能。\n\n\n前置插件#\n\n默认情况下，插件会按照添加顺序依次执行，通过 pre 字段可以声明前置执行的插件。\n\n比如有下面两个插件：\n\n\n\n\n\nbar 插件在 pre 字段中配置了 foo 插件，因此 foo 插件一定会在 bar 插件之前执行。\n\n\n后置插件#\n\n同样的，通过 post 字段可以声明后置执行的插件。\n\n\n\n\n\nbar 插件在 post 字段中配置了 foo 插件，因此 foo 插件一定会在 bar 插件之后执行。\n\n\n互斥插件#\n\n通过 rivals 字段可以声明插件间的互斥关系。\n\n有下面两个插件：\n\n\n\n\n\nbar 插件在 rivals 字段中配置了 foo 插件，因此同时添加了 foo 插件和 bar 插件就会报错。\n\n\n必需插件#\n\n通过 required 字段可以声明插件间的依赖关系。\n\n有下面两个插件：\n\n\n\n\n\nbar 插件在 required 字段中配置了 foo 插件，因此使用 bar 插件时，如果未配置 foo 插件就会报错。\n\n\n注册插件#\n\n当插件之间存在依赖关系时，我们也可以在一个插件中通过 usePlugin 主动注册另一个插件：\n\n\n\n当使用者配置了 bar 插件时，foo 插件也会自动注册生效，使用者就不需要去额外注册 foo 插件了。","routePath":"/guides/topic-detail/framework-plugin/relationship","lang":"zh","toc":[{"text":"插件排序","id":"插件排序","depth":2,"charIndex":300},{"text":"前置插件","id":"前置插件","depth":3,"charIndex":349},{"text":"后置插件","id":"后置插件","depth":3,"charIndex":469},{"text":"互斥插件","id":"互斥插件","depth":2,"charIndex":563},{"text":"必需插件","id":"必需插件","depth":2,"charIndex":670},{"text":"注册插件","id":"注册插件","depth":2,"charIndex":784}],"domain":"","frontmatter":{"sidebar_position":4},"version":""},{"id":568,"title":"配置参数","content":"#\n\n@modern-js/create 提供了 --config 参数，用于提前指定执行过程中交互问题的答案。\n\n这里将介绍不同情况下，可以在 config 中配置的字段及字段值。\n\n\n通用配置#\n\n\nsolution#\n\n问题：请选择你想创建的工程类型\n\n选项：\n\n * Web 应用 -- mwa\n\n * Npm 模块 -- module\n\n * 文档站 -- doc\n\n\nscenes#\n\n问题：请选择项目场景\n\n选项：\n\n使用自定义生成器插件时的插件关键字列表。\n\n\nWeb 应用#\n\n\nlanguage#\n\n问题：请选择开发语言\n\n选项：\n\n * TS -- ts\n\n * ES6+ -- js\n\n\npackageManager#\n\n问题：请选择包管理工具\n\n选项：\n\n * pnpm -- pnpm\n\n * Yarn -- yarn\n\n * npm -- npm\n\n\nbuildTools#\n\n问题：请选择构建工具\n\n选项：\n\n * webpack -- webpack\n\n * Rspack -- rspack\n\n\nNpm 模块#\n\n\npackageName#\n\n问题：请填写项目名称\n\nINFO\n\nNpm 模块的 package.json 的 name 字段值，该配置值为字符串类型。\n\n\nlanguage#\n\n问题：请选择开发语言\n\n选项：\n\n * TS -- ts\n\n * ES6+ -- js\n\n\npackageManager#\n\n问题：请选择包管理工具\n\n选项：\n\n * pnpm -- pnpm\n\n * Yarn -- yarn\n\n * npm -- npm\n\n\n文档站#\n\n\npackageManager#\n\n问题：请选择包管理工具\n\n选项：\n\n * pnpm -- pnpm\n\n * Yarn -- yarn\n\n * npm -- npm","routePath":"/guides/topic-detail/generator/create/config","lang":"zh","toc":[{"text":"通用配置","id":"通用配置","depth":2,"charIndex":93},{"text":"solution","id":"solution","depth":3,"charIndex":101},{"text":"scenes","id":"scenes","depth":3,"charIndex":189},{"text":"Web 应用","id":"web-应用","depth":2,"charIndex":238},{"text":"language","id":"language","depth":3,"charIndex":248},{"text":"packageManager","id":"packagemanager","depth":3,"charIndex":305},{"text":"buildTools","id":"buildtools","depth":3,"charIndex":390},{"text":"Npm 模块","id":"npm-模块","depth":2,"charIndex":465},{"text":"packageName","id":"packagename","depth":3,"charIndex":475},{"text":"language","id":"language-1","depth":3,"charIndex":553},{"text":"packageManager","id":"packagemanager-1","depth":3,"charIndex":610},{"text":"文档站","id":"文档站","depth":2,"charIndex":695},{"text":"packageManager","id":"packagemanager-2","depth":3,"charIndex":702}],"domain":"","frontmatter":{"sidebar_position":3},"version":""},{"id":569,"title":"CLI 参数","content":"#\n\n@modern-js/create 提供了很多配置参数用于配置其执行过程中的行为，可以通过 --help 参数进行查看：\n\n\n\n下面将针对这些参数做详细介绍：\n\n\n[projectDir]#\n\n项目目录名称。\n\n执行 @modern-js/create 时，默认会在当前目录创建 projectDir\n文件夹，并在该文件夹下初始化项目。该参数为空时，将会在当前目录直接生成初始化项目。\n\nINFO\n\n如果 projectDir 所在目录内容不为空，将会提示是否继续创建，推荐在空目录下进行项目初始化操作。\n\n\n--version#\n\n获取 @modern-js/create 工具版本。\n\n\n\n\n--lang #\n\n执行执行语言，支持 zh 和 en。\n\n默认情况下，@modern-js/create 会自动识别用户的系统语言，选择使用中文或者英文，如果识别失败或者不符合使用习惯，可以使用该参数手动指定。\n\n\n-c, --config #\n\n指定项目默认配置。\n\n默认情况下，@modern-js/create 在执行过程中会出现选择语言、包管理工具等交互问题，当需要提前指定这些配置内容时，可以通过该字段传入。\n\n该字段为 JSON 字符串，例如需指定包管理工具时：\n\n\n\nconfig 支持的参数可查看配置参数。\n\n\n-d,--debug#\n\n展示调试日志。\n\n当在使用过程中遇到问题时，可以使用该参数显示调试日志，方便快速定位问题位置及对问题进行排查。\n\n\n--mwa#\n\n快速创建 Web 应用项目。\n\n\n--module#\n\n快速创建 Npm 模块项目。\n\n\n-p, --plugin #\n\n指定生成器插件。\n\n@modern-js/create 支持使用生成器插件定制 Modern.js 默认的工程方案类型或者添加工程方案类型场景，详情可查看开发生成器插件。\n\n\n--generator #\n\n指定微生成器。\n\n@modern-js/create 支持使用微生成器完全定制项目生成流程。\n\n\n--dist-tag #\n\n指定生成器及 Modern.js 相关依赖版本。\n\n@modern-js/create 执行过程中会执行更小的微生成器，默认会使用 latest\n的微生成器版本，使用该参数可以指定执行的微生成器的版本号和对应的安装 Modern.js 相关依赖的版本。\n\n比如使用 next 版本：\n\n\n\n\n--packages #\n\n创建项目是指定特定包版本依赖。\n\n在创建项目时如果有需要指定特定包版本，可以使用该参数。该参数会在项目根目录的 package.json 中配置 pnpm.overrides(包管理工具选择\npnpm) 或者 resolutions 锁定包版本号。\n\n该参数值为 JSON 字符串。\n\n例如指定 react 版本：\n\n\n\n\n--registry #\n\n指定执行子生成器和获取项目依赖版本的 npm registry。\n\n\n--no-need-install#\n\n忽略自动安装依赖。\n\n默认情况下，@modern-js/create 在创建项目完成后会自动安装依赖，使用该参数可以忽略安装依赖步骤。\n\n\nclean-cache#\n\n@modern-js/create 默认会在执行机器的 tmp\n目录生成子生成器缓存用于加快生成器执行速度，在需要刷新缓存或者缓存出现问题时可以使用该命令删除缓存。\n\n","routePath":"/guides/topic-detail/generator/create/option","lang":"zh","toc":[{"text":"[projectDir]","id":"projectdir","depth":2,"charIndex":84},{"text":"--version","id":"--version","depth":2,"charIndex":257},{"text":"--lang <lang>","id":"--lang-lang","depth":2,"charIndex":-1},{"text":"-c, --config <config>","id":"-c---config-config","depth":2,"charIndex":-1},{"text":"-d,--debug","id":"-d--debug","depth":2,"charIndex":565},{"text":"--mwa","id":"--mwa","depth":2,"charIndex":636},{"text":"--module","id":"--module","depth":2,"charIndex":661},{"text":"-p, --plugin <plugin>","id":"-p---plugin-plugin","depth":2,"charIndex":-1},{"text":"--generator <generator>","id":"--generator-generator","depth":2,"charIndex":-1},{"text":"--dist-tag <distTag>","id":"--dist-tag-disttag","depth":2,"charIndex":-1},{"text":"--packages <packages>","id":"--packages-packages","depth":2,"charIndex":-1},{"text":"--registry <registry>","id":"--registry-registry","depth":2,"charIndex":-1},{"text":"--no-need-install","id":"--no-need-install","depth":2,"charIndex":1242},{"text":"clean-cache","id":"clean-cache","depth":2,"charIndex":1332}],"domain":"","frontmatter":{"sidebar_position":2},"version":""},{"id":570,"title":"使用","content":"#\n\nModern.js 提供了 @modern-js/create 工具用于创建 Modern.js 提供的工程方案项目，例如 Web 应用、Npm 模块。\n\n下面将介绍 @modern-js/create 的使用姿势。\n\n\n环境准备#\n\n\nNode.js#\n\n在开始使用前，你需要安装 Node.js，并保证 Node.js 版本不低于 16.2.0，我们推荐使用 Node.js 18 的 LTS 版本。\n\n你可以通过以下命令检查当前使用的 Node.js 版本：\n\n\n\n如果你当前的环境中尚未安装 Node.js，或是安装的版本低于 16，可以通过 nvm 或 fnm 安装需要的版本。\n\n下面是通过 nvm 安装 Node.js 18 LTS 版本的例子：\n\n\n\nnvm 和 fnm\n\nnvm 和 fnm 都是 Node.js 版本管理工具。相对来说，nvm 较为成熟和稳定，而 fnm 是使用 Rust 实现的，比 nvm 提供了更好的性能。\n\n此外，在安装 nvm 或 fnm 后，然后只要仓库根目录下有内容为 lts/hydrogen 的 .nvmrc 文件，进入这个仓库时就会自动安装或切换到正确的\nNode.js 版本。\n\n\npnpm#\n\n推荐使用 pnpm 来管理依赖：\n\n\n\nNOTE\n\nModern.js 同样支持使用 yarn、npm 进行依赖管理。\n\n\n使用 @modern-js/create 创建项目#\n\n不需要全局安装 @modern-js/create，直接使用 npx 执行即可：\n\n\n\nINFO\n\n[projectDir] 为项目目录名称，不填写将会在当前目录创建项目。\n\n执行过程中需要根据提示完成交互，创建符合需求的项目。\n\n\n创建 Web 应用项目#\n\n\n\n\n创建 Npm 模块项目#\n\n","routePath":"/guides/topic-detail/generator/create/use","lang":"zh","toc":[{"text":"环境准备","id":"环境准备","depth":2,"charIndex":113},{"text":"Node.js","id":"nodejs","depth":3,"charIndex":121},{"text":"pnpm","id":"pnpm","depth":3,"charIndex":522},{"text":"使用 `@modern-js/create` 创建项目","id":"使用-modern-jscreate-创建项目","depth":2,"charIndex":-1},{"text":"创建 Web 应用项目","id":"创建-web-应用项目","depth":3,"charIndex":736},{"text":"创建 Npm 模块项目","id":"创建-npm-模块项目","depth":3,"charIndex":753}],"domain":"","frontmatter":{"sidebar_position":1},"version":""},{"id":571,"title":"配置参数","content":"#\n\nnew 命令提供了 --config 参数，用于提前指定执行过程中交互问题的答案。\n\n这里将介绍不同情况下，可以在 config 中配置的字段及字段值。\n\n\n通用配置#\n\n\nactionType#\n\n问题：请选择你想要的操作\n\n选项：\n\n * 创建工程元素 -- element\n\n * 启用可选功能 -- function\n\n * 自动重构 -- refactor\n\n\nWeb 应用#\n\n\nelement#\n\n问题：请选择创建元素类型\n\n选项：\n\n * 新建「应用入口」 -- entry\n\n * 新建「自定义 Web Server」源码目录 -- server\n\n\nname#\n\n问题： 请填写入口名称\n\nINFO\n\n新建应用入口时需要该配置，该配置值为字符串类型。\n\n\nfunction#\n\n问题：请选择功能名称\n\n选项：\n\n * 启用「Rspack 构建」 -- rspack\n\n * 启用 「Tailwind CSS」 支持 -- tailwindcss\n\n * 启用「BFF」功能 -- bff\n\n * 启用「SSG」功能 -- ssg\n\n * 启用「SWC 编译」-- swc\n\n * 启用「微前端」模式 -- micro_frontend\n\n * 启用「基于 UA 的 Polyfill」功能 -- polyfill\n\n * 启用「全局代理」 -- proxy\n\n\nbffType#\n\n问题：请选择 BFF 类型\n\n选项：\n\n * 函数模式 -- func\n\n * 框架模式 -- framework\n\nINFO\n\n启用 BFF 功能时需要该配置。\n\n\nframework#\n\n问题：请选择运行时框架\n\n选项：\n\n * Express -- express\n\n * Koa -- koa\n\nINFO\n\n启用 BFF 功能时需要该配置。\n\n\nrefactor#\n\n问题：请选择重构类型\n\n选项：\n\n * 使用 React Router v5 -- react_router_5\n\n\nNpm 模块#\n\n\nfunction#\n\n问题：启用可选功能\n\n选项：\n\n * 启用 「Tailwind CSS」 支持 -- tailwindcss\n\n * 启用「Storybook」 -- storybook\n\n * 启用「Runtime API」 -- runtime_api","routePath":"/guides/topic-detail/generator/new/config","lang":"zh","toc":[{"text":"通用配置","id":"通用配置","depth":2,"charIndex":81},{"text":"actionType","id":"actiontype","depth":3,"charIndex":89},{"text":"Web 应用","id":"web-应用","depth":2,"charIndex":188},{"text":"element","id":"element","depth":3,"charIndex":198},{"text":"name","id":"name","depth":3,"charIndex":287},{"text":"function","id":"function","depth":3,"charIndex":340},{"text":"bffType","id":"bfftype","depth":3,"charIndex":593},{"text":"framework","id":"framework","depth":3,"charIndex":687},{"text":"refactor","id":"refactor","depth":3,"charIndex":780},{"text":"Npm 模块","id":"npm-模块","depth":2,"charIndex":850},{"text":"function","id":"function-1","depth":3,"charIndex":860}],"domain":"","frontmatter":{"sidebar_position":3},"version":""},{"id":572,"title":"CLI 参数","content":"#\n\nnew 命令提供了很多配置参数用于配置其执行过程中的行为，可以通过 --help 参数进行查看：\n\n\n\n下面将针对这些参数做详细介绍：\n\n\n--lang #\n\n执行执行语言，支持 zh 和 en。\n\n默认情况下，new 命令会自动识别用户的系统语言，选择使用中文或者英文，如果识别失败或者不符合使用习惯，可以使用该参数手动指定。\n\n\n-c, --config #\n\n指定项目默认配置。\n\n默认情况下，new 命令在执行过程中会出现选择操作类型、开启功能等交互问题，当需要提前指定这些配置内容时，可以通过该字段传入。\n\n该字段为 JSON 字符串，例如需指定 BFF 框架时：\n\n\n\nconfig 支持的参数可查看配置参数。\n\n\n-d,--debug#\n\n展示调试日志。\n\n当在使用过程中遇到问题时，可以使用该参数显示调试日志，方便快速定位问题位置及对问题进行排查。\n\n\n--registry #\n\n指定执行子生成器和获取项目依赖版本的 npm registry。\n\n\n--dist-tag #\n\n指定生成器版本。\n\nnew 命令执行过程中会执行更小的微生成器，默认会使用 latest 的微生成器版本，使用该参数可以指定执行的微生成器的版本号的版本。\n\n比如使用 next 版本：\n\n","routePath":"/guides/topic-detail/generator/new/option","lang":"zh","toc":[{"text":"--lang <lang>","id":"--lang-lang","depth":2,"charIndex":-1},{"text":"-c, --config <config>","id":"-c---config-config","depth":2,"charIndex":-1},{"text":"-d,--debug","id":"-d--debug","depth":2,"charIndex":316},{"text":"--registry <registry>","id":"--registry-registry","depth":2,"charIndex":-1},{"text":"--dist-tag <distTag>","id":"--dist-tag-disttag","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"sidebar_position":2},"version":""},{"id":573,"title":"使用","content":"#\n\n在 Web 应用、 Npm 模块中，我们提供了 new 命令用于创建项目元素、开启功能和创建子项目。\n\n\nWeb 应用#\n\nWeb 应用项目通过 @modern-js/app-tools 提供 new 命令。\n\nnew 命令提供了三种操作类型：\n\n * 创建工程元素\n\n * 启用可选功能\n\n * 自动重构\n\n每种操作类型都提供了对应支持的列表，可根据项目情况进行选择。\n\n例如：\n\n创建新的应用入口：\n\n\n\n执行完成后将会在项目 src 目录创建新入口对应名称的文件夹及默认入口文件，并且自动帮忙整理之前 src 下入口文件到 package.json 中 name\n字段对应的文件夹中。\n\n开启 BFF 功能：\n\n\n\n执行完成后将会在项目安装 BFF 相关依赖，并创建 api 目录用于 BFF 模块的开发并提供提示信息用于注册 BFF 插件。\n\nINFO\n\n这里未帮助用户自动注册插件，原因是由于 modern.config.[tj]s\n在项目生命周期中变化比较复杂，可能存在模块之间互相引用问题，让用户手动注册能保证修改配置的正确性。\n\n在后续定制化的开发中，如果有类似的需求，也可以通过提示的方式给到使用方操作指南，让用户对文件进行手动操作。\n\nWARNING\n\n执行 new 命令时可能会出现需要开启的功能不在列表中，需要检查一下项目 package.json 中是否已经安装对应功能的插件，如果仍需使用 new\n命令开启，需要先手动移除对应的插件依赖。\n\n\nNpm 模块#\n\nNpm 模块项目通过 @modern-js/module-tools 提供 new 命令。\n\nnew 命令提供了启用可选功能的能力。\n\n例如：\n\n开启 Storybook 能力：\n\n\n\n执行完成后将会在项目安装 Storybook 插件相关依赖，增加 storybook 命令，创建 stories 目录用于 Storybook\n模块的开发并提供提示信息用于注册 Storybook 插件。","routePath":"/guides/topic-detail/generator/new/use","lang":"zh","toc":[{"text":"Web 应用","id":"web-应用","depth":2,"charIndex":55},{"text":"Npm 模块","id":"npm-模块","depth":2,"charIndex":638}],"domain":"","frontmatter":{"sidebar_position":1},"version":""},{"id":574,"title":"afterForged","content":"#\n\nafterForged 为生成器插件中用于文件操作后其他步骤操作的生命周期函数。\n\n\n类型#\n\n\n\n\nAPI#\n\n下面将分别介绍 api 参数提供的 API。\n\n\nisInGitRepo#\n\n判断当前项目是否为一个 Git 仓库。\n\n\ninitGitRepo#\n\n初始化当前项目为 Git 仓库。\n\n\ngitAddAndCommit#\n\n提交当前仓库变更。\n\n参数：\n\n * commitMessage: commit 信息。\n\n\ninstall#\n\n在项目根目录安装依赖。install 函数中将根据 packageManager 的值使用对应的包管理工具安装依赖。","routePath":"/guides/topic-detail/generator/plugin/api/afterForged","lang":"zh","toc":[{"text":"类型","id":"类型","depth":2,"charIndex":45},{"text":"API","id":"api","depth":2,"charIndex":53},{"text":"isInGitRepo","id":"isingitrepo","depth":3,"charIndex":84},{"text":"initGitRepo","id":"initgitrepo","depth":3,"charIndex":120},{"text":"gitAddAndCommit","id":"gitaddandcommit","depth":3,"charIndex":153},{"text":"install","id":"install","depth":3,"charIndex":218}],"domain":"","frontmatter":{"sidebar_position":3},"version":""},{"id":575,"title":"context","content":"#\n\n生成器插件在 main 文件中默认导出了一个函数，函数参数为 context，生成器插件提供的所有 API 都是由这个 context 提供的。\n\n\n类型#\n\n我们先大概了解一下 context 的类型定义：\n\n\n\ncontext 提供的内容主要分为三类：\n\n * 获取当前生成器执行环境信息\n\n * 操作 input 输入\n\n * 生成器插件生命周期函数\n\n下面将从这三个分类分别介绍生成器插件 API。\n\n\n获取信息#\n\nlocale#\n\n获取生成器插件执行环境的语言。@modern-js/create 提供了 zh 和 en 两种语言，这里即为对应的这两种值。\n\nisFileExist#\n\n判断文件是否存在。我们很多时候需要在定义操作前确认目标项目文件是否已经存在，可以直接通过该 API 获取。\n\n例如我们需要获取 package.json 文件是否存在，然后做相应的操作：\n\n\n\nreadDir#\n\n获取文件夹内文件列表。我们很多时候需要在定义操作前获取目标项目文件夹下面文件列表，可以直接通过该 API 获取。\n\n例如我们需要获取 src 文件夹下所有文件，然后进行相应操作：\n\n\n\n\ninput 操作#\n\ninput 操作中使用的 key 参数可参考配置参数，需要在使用对应工程方案下的 key，即不支持在 solution 和 scenes。\n\ninput 操作中的 input 参数对应的 Schema 类型可参考 Input。\n\naddInputBefore#\n\n在指定的 input key 前添加问题。\n\n例如：\n\n\n\naddInputAfter#\n\n在指定的 input key 后添加问题。\n\n例如：\n\n\n\nINFO\n 1. 添加问题的 key 不能和 Modern.js 提供的工程方案自身的问题的 key 重复。\n 2. 添加问题 addInputAfter 的优先级高于 addInputBefore，当同时对一个 key 添加 After 问题和对其后一个key 添加\n    Before 问题时，After 问题会在 Before 之前。\n 3. 当需要在相同 key 前面或者后面添加多个问题时，可多次调用该方法，问题的顺序会按照调用顺序进行排列。\n\nsetInput#\n\n设置指定 input key 的属性。\n\n例如设置 packageName 的 title 属性：\n\n\n\nINFO\n\n对于 Modern.js 工程方案提供的输入选项，只支持删除，不支持增加，增加会造成代码中的逻辑判断存在问题。\n\nsetInputValue#\n\n设置指定 input key 的选项默认值。\n\n例如设置 packageManager 的默认值：\n\n\n\nINFO\n\n设置完成后，该问题还是需要交互，只是会使用生成器插件配置的默认值。\n\nsetDefaultConfig#\n\n设置指定 input key 的默认值。\n\n例如设置 packageManager 的默认值：\n\n\n\nINFO\n\n设置完成后，将不再展示对应问题，和 @modern-js/create 制定 --config 行为一致。不支持设置 vertical 和\nprojectOrg。\n\nsetGitMessage#\n\n设置 Git 初始提交信息。Modern.js 默认 Git 初始化提交信息为 feat: init，通过该函数可以修改。\n\n\n生命周期函数#\n\n生命周期函数比较复杂，将通过后面两节 onForged 和 afterForged 分别介绍。","routePath":"/guides/topic-detail/generator/plugin/api/context","lang":"zh","toc":[{"text":"类型","id":"类型","depth":2,"charIndex":77},{"text":"获取信息","id":"获取信息","depth":3,"charIndex":208},{"text":"locale","id":"locale","depth":4,"charIndex":215},{"text":"isFileExist","id":"isfileexist","depth":4,"charIndex":288},{"text":"readDir","id":"readdir","depth":4,"charIndex":399},{"text":"input 操作","id":"input-操作","depth":3,"charIndex":503},{"text":"addInputBefore","id":"addinputbefore","depth":4,"charIndex":629},{"text":"addInputAfter","id":"addinputafter","depth":4,"charIndex":676},{"text":"setInput","id":"setinput","depth":4,"charIndex":951},{"text":"setInputValue","id":"setinputvalue","depth":4,"charIndex":1078},{"text":"setDefaultConfig","id":"setdefaultconfig","depth":4,"charIndex":1188},{"text":"setGitMessage","id":"setgitmessage","depth":4,"charIndex":1347},{"text":"生命周期函数","id":"生命周期函数","depth":3,"charIndex":1427}],"domain":"","frontmatter":{"sidebar_position":1},"version":""},{"id":576,"title":"Input","content":"#\n\n生成器插件提供了 Input 的方式完成与用户的问题交互，使用 JSON Schema 的方式进行定义：\n\n例如：\n\n\n\nJSON Schema 的格式参考了开源的 Formily Schema 的格式，下面将对支持的字段进行介绍：\n\n\ntype#\n\n定义当前 Schema 类型，当前支持的类型为 string、number 和 object。字符串输入和下拉选项都需要使用 string 类型。 object\n类型用于实现 Schema 之间嵌套，需要配和 properties 属性使用。\n\n\ntitle#\n\n定义当前 Schema 展示名称。\n\n\ndefault#\n\n定义当前 Schema 的默认值。\n\n\nenum#\n\n当前 Schema 为下列选项时，定义选项内容。\n\n子项支持 string 或者 { label: string; value: string} 类型，当下拉选项中值和展示值相同时，可直接使用 string\n定义。\n\n当需要表示多选选项时，设置 default 字段为 [] 即可。\n\n\nx-validator#\n\n当前 Schema 的校验规则。当 Schema 为输入类型时，在输入完成后会自动完成校验。\n\n这里校验规则支持 Formily 提供的校验规则，例如最大值为 5：\n\n\n\n也支持直接使用验证函数：\n\n\n\n\nx-reactions#\n\n使用 Schema 之间的联动，这里和 Formily 联动规则完全相同。\n\n例如：\n\n\n\n\nproperties#\n\n组织当前 Schema 的结构，定义子表单。properties 为对象，key 为 Schema 关键字，value 为上述描述的 Schema 对象。","routePath":"/guides/topic-detail/generator/plugin/api/input","lang":"zh","toc":[{"text":"type","id":"type","depth":2,"charIndex":121},{"text":"title","id":"title","depth":2,"charIndex":252},{"text":"default","id":"default","depth":2,"charIndex":280},{"text":"enum","id":"enum","depth":2,"charIndex":310},{"text":"x-validator","id":"x-validator","depth":2,"charIndex":461},{"text":"x-reactions","id":"x-reactions","depth":2,"charIndex":578},{"text":"properties","id":"properties","depth":2,"charIndex":639}],"domain":"","frontmatter":{"sidebar_position":4},"version":""},{"id":577,"title":"onForged","content":"#\n\nonForged 为生成器插件中用于文件操作的生命周期函数。\n\n\n类型#\n\n\n\nonForged 参数为一个回调函数，回调函数参数为 api 和 input，分别用于提供该生命周期函数提供的 API 及当前输入信息。\n\n\n概念#\n\n\n文件类型#\n\n生成器插件将文件类型分为四类：\n\n * 文本文件\n\n纯文本内容文件，可使用 Handlebars 或 EJS 进行模板处理的文件。\n\n * 二进制文件\n\n图片、音频、视频等文件。\n\n * JSON 文件\n\nJSON 格式的文件。\n\n * 文本列表文件\n\n文件由行文本组成的文件，例如 .gitignore, .editorconfig, .npmrc。\n\n对应四种文件的类型定义为：\n\n\n\n\nAPI#\n\n下面将分别介绍 api 参数提供的 API。\n\n\naddFile#\n\n添加单个文件。\n\n参数类型：\n\n\n\n * type： 文件类型。\n * file：目标文件路径，相对于目标项目目录的相对路径。\n * template：模板内容，该字段值可直接用于模板渲染文件。优先级低于 templateFile。\n * templateFile：模板文件路径，相对于 templates 目录的相对路径即可。\n * force：是否强制覆盖，当目标文件存在时是否强制覆盖，默认为 false。\n * data：模板渲染数据。\n\nINFO\n\n文本类型文件默认使用 Handlebars 进行处理，当模板文件以 .ejs 结尾的话，会使用 EJS 进行模板渲染。\n\n例如添加模板文件 App.tsx.hanlebars 到 src/App.tsx 中:\n\n\n\n\naddManyFiless#\n\n批量添加文件，一般用于添加多个文件到同一个目标目录。\n\n参数类型：\n\n\n\n * type： 文件类型。\n * destination：目标文件夹，相对于目标项目目录的相对路径。\n * templateFiles：模板文件列表，支持 globby 正则表达式\n * templateBase：模板文件的公共路径，使用该参数时目标文件会自动删除该路径。\n * fileNameFunc：重命名文件函数，添加文件过程中会依次将文件名传入到该函数，可以根据需要进行重命名。\n * data：模板渲染数据。\n\n例如将模板文件 src-ts 目录下所有文件渲染到 src 目录：\n\n\n\n\nupdateJSONFile#\n\n更新 JSON 文件字段。\n\n参数类型：\n\n\n\n * fileName：JSON 文件路径，相对于目标项目的路径。\n * updateInfo：更新信息，嵌套字段更新需要平铺，不然会更新整体造成内容丢失。\n\n例如更新 package.json 的 name 字段：\n\n\n\n例如更新 dependencies 的 react-dom 版本:\n\n\n\n\nupdateTextRawFile#\n\n更新文本列表文件内容。\n\n参数类型：\n\n\n\n * fileName： 文本列表文件路径，相对于目标项目的路径。\n * update：更新函数，参数为当前文件内容以 \\n 进行分割的数组，返回值也为修改完成后的数组，@modern-js/create 会自动以 \\n\n   合并，并写入源文件。\n\n例如 .gitinore 文件中增加 dist 目录：\n\n\n\n\nupdateModernConfig(不推荐)#\n\nModern.js 配置除了可以在 modern.config.[tj]s 中配置外，还支持 package.json 中配置 modernConfig\n配置。该函数用于更新该字段。\n\n参数类型：\n\n\n\n * updateInfo： 更新内容信息。updateModernConfig 是基于 updateJSONFile 的封装，将自动更新到\n   modernConfig 字段下，updateInfo 中只需填写 modernConfig 下的配置字段即可。\n\n例如开启 ssr：\n\n\n\n\nrmFile#\n\n删除文件。\n\n参数类型：\n\n\n\n * fileName：删除的文件路径，相对于目标项目的路径。\n\n\nrmDir#\n\n删除文件夹。\n\n参数类型：\n\n\n\n * dirName：删除的文件夹路径，相对于目标项目的路径。\n\n\naddHelper#\n\n添加 handlebrs 渲染的自定义 Helper。\n\n参数类型：\n\n\n\n * name：Helper 函数名称。\n * fn：Helper 函数实现。\n\n\naddPartial#\n\n添加 Handlebars 渲染的 Partial。\n\n参数类型：\n\n\n\n * name：Partial 名称。\n * str：Partial 的模板字符串。\n\n\ncreateElement#\n\n自动调用 new 命令创建工程元素。\n\n参数类型：\n\n\n\n * element：工程元素类型，新建入口或者新建自定义 Web Server 源码目录。\n * params：对应创建工程元素的其他参数。\n\n\nenableFunc#\n\n自动调用 new 命令开启可选功能。\n\n参数类型：\n\n\n\n * func：开启功能名称。\n * params：对应开启功能的其他参数。\n\nINFO\n\n创建工程元素和开启功能配置可参考配置参数。","routePath":"/guides/topic-detail/generator/plugin/api/onForged","lang":"zh","toc":[{"text":"类型","id":"类型","depth":2,"charIndex":35},{"text":"概念","id":"概念","depth":2,"charIndex":113},{"text":"文件类型","id":"文件类型","depth":3,"charIndex":119},{"text":"API","id":"api","depth":2,"charIndex":322},{"text":"addFile","id":"addfile","depth":3,"charIndex":353},{"text":"addManyFiless","id":"addmanyfiless","depth":3,"charIndex":702},{"text":"updateJSONFile","id":"updatejsonfile","depth":3,"charIndex":1006},{"text":"updateTextRawFile","id":"updatetextrawfile","depth":3,"charIndex":1197},{"text":"updateModernConfig(不推荐)","id":"updatemodernconfig不推荐","depth":3,"charIndex":1397},{"text":"rmFile","id":"rmfile","depth":3,"charIndex":1671},{"text":"rmDir","id":"rmdir","depth":3,"charIndex":1730},{"text":"addHelper","id":"addhelper","depth":3,"charIndex":1789},{"text":"addPartial","id":"addpartial","depth":3,"charIndex":1881},{"text":"createElement","id":"createelement","depth":3,"charIndex":1976},{"text":"enableFunc","id":"enablefunc","depth":3,"charIndex":2095}],"domain":"","frontmatter":{"sidebar_position":2},"version":""},{"id":578,"title":"类型","content":"#\n\n\n介绍#\n\n生成器插件分为两类：\n\n * 扩展：Web 应用( Npm 模块) = Web 应用( Npm 模块) + 生成器插件\n\n * 自定义：新应用(模块) = Web 应用(模块) + 生成器插件\n\n简单理解就是扩展还是使用 Modern.js 原本的工程方案名称，自定义会创建一个新的名称。\n\n\n标识#\n\n生成器插件的类型通过 package.json 中的 meta 字段来提供：\n\n\n扩展#\n\n\n\n\n自定义#\n\n\n\nINFO\n\n自定义类型的 type 支持 custom 类型，custom 为使用 Modern.js 提供的一些项目开发的最佳实践模板，比如\n.gitignore、.editorConfig 等文件，其他业务相关代码模板需要手动通过生成器插件提供。\n\n\n创建初始项目#\n\n\n扩展#\n\n\n\n\n自定义#\n\n\n\n\n执行顺序#\n\n生成器插件支持同时使用多个，也就是执行 @modern-js/create 时支持多个 --plugin 参数。\n\n\n扩展#\n\n扩展生成器插件支持在执行时会按照声明的生成器插件参数的顺序，依次执行对应 extend 的工程方案的生命周期函数。\n\n例如存在 A 和 B 两个生成器插件，A 和 B 都是 extend 的 Web 应用工程方案，A 插件声明添加 a.ts 文件，B 插件声明添加 b.ts\n文件， 执行 npx @modern-js/create@latest --plugin A --plugin B 时，选择 Web 应用工程时，会先生成\nWeb 应用默认的项目文件，然后执行 A 插件创建 a.ts 文件，再执行 B 插件，生成 b.ts 文件。\n\n\n自定义#\n\n自定义生成器插件只支持同一时间运行一个生成器插件，当 @modern-js/create 声明 --plugin\n参数时，会在选择工程方案之后增加选择工程方案场景选项，即为上述 package.json 中定义的新 name，选择对应 name\n的生成器插件，即会在默认工程方案执行完成后，执行对应的生成器插件逻辑。声明 --plugin 参数时，工程方案场景下将会逐一列举出对应的生成器插件名称供选择。","routePath":"/guides/topic-detail/generator/plugin/category","lang":"zh","toc":[{"text":"介绍","id":"介绍","depth":2,"charIndex":3},{"text":"标识","id":"标识","depth":2,"charIndex":155},{"text":"扩展","id":"扩展","depth":3,"charIndex":201},{"text":"自定义","id":"自定义","depth":3,"charIndex":209},{"text":"创建初始项目","id":"创建初始项目","depth":2,"charIndex":345},{"text":"扩展","id":"扩展-1","depth":3,"charIndex":355},{"text":"自定义","id":"自定义-1","depth":3,"charIndex":363},{"text":"执行顺序","id":"执行顺序","depth":2,"charIndex":372},{"text":"扩展","id":"扩展-2","depth":3,"charIndex":438},{"text":"自定义","id":"自定义-2","depth":3,"charIndex":716}],"domain":"","frontmatter":{"sidebar_position":2},"version":""},{"id":579,"title":"Context","content":"#\n\n生成器插件默认会导出一个函数，函数参数为 context，在执行过程中 context 会自动注入到生成器插件中。\n\n\n\ncontext 提供了两类 API，分别用于自定义 Input 和定义生成器插件声明周期逻辑。\n\nINFO\n\n下面只对部分 API 做简单示例讲解，完整的 API 请移步 生成器插件 API 查看。\n\n\n自定义 Input#\n\nModern.js Framework 和 Modern.js Module 都存在一些默认的 Input 交互，使用这里的 API 可以对这些 Input\n进行添加、修改、隐藏、提供默认值等操作。\n\n例如：\n\n * 添加问题\n\n\n\n * 通过设置 config 隐藏问题\n\n\n\n\n生命周期#\n\n生成器插件提供了两个生命周期钩子函数用于定义生成器插件行为：\n\n * onForged：完成文件操作后的生命周期。\n\n * afterForged：onForged 钩子函数执行完成后的生命周期。\n\n\nonForged#\n\n在 Modern.js 工程方案生成器完成文件操作之后的钩子函数，用于完成生成器插件中的文件操作，比如添加模板文件，覆盖现有文件，删除现有文件等。\n\n对于扩展类型同时执行多个生成器插件时，将会按照声明顺序依次执行对应生成器插件的 onForged 操作。\n\nonForged 函数参数为一个回调函数，参数为 api 和 input。\n\n\n\napi 上会提供生成器插件支持的文件操作相关方法。\n\ninput 为当前用户输入内容，包含 --config 参数定义的，默认工程方案交互的及生成器插件定义的用户输入。\n\n当需要添加新的文件模板时，将模板文件定义到 templates 目录，然后通过上述 api 上方法进行操作即可，生成器插件默认对 templates\n目录文件进行操作，无需再声明 templates 路径。\n\n\nafterForged#\n\nonForged 钩子函数执行完成后执行，这里主要用于进行安装依赖，Git 操作等。\n\n默认 Modern.js 工程方案在完成文件操作后会默认执行安装依赖及 Git 初始化，Git 初次提交等，该钩子函数可以不使用。\n\n对于自定义的生成器插件还支持 custom 类型，该类型只提供了少量最佳实践的项目配置，则需要在该钩子函数中完成安装依赖和 Git 初始化等操作。\n\nafterForged 函数参数也为一个回调函数，参数为 api 和 input。\n\n","routePath":"/guides/topic-detail/generator/plugin/context","lang":"zh","toc":[{"text":"自定义 Input","id":"自定义-input","depth":2,"charIndex":165},{"text":"生命周期","id":"生命周期","depth":2,"charIndex":318},{"text":"onForged","id":"onforged","depth":2,"charIndex":426},{"text":"afterForged","id":"afterforged","depth":2,"charIndex":799}],"domain":"","frontmatter":{"sidebar_position":4},"version":""},{"id":580,"title":"介绍及创建项目","content":"#\n\n\n介绍#\n\nModern.js 提供了 Web 应用、Npm 模块等工程方案，并通过使用 @modern-js/create\n工具可以创建工程方案的初始项目模板，初始项目模板会提供基本的代码开发环境、简单的示例代码及配置等。\n\nModern.js 提供的初始化模板具有通用性，能满足一些通用的项目开发需求。\n\n当你深度使用 Modern.js 时，必然会发现每次创建的项目都会进行一些针对自身项目的特定的相似改动，比如修改示例代码、增加一些配置、开启某些功能等。\n\n生成器插件可以帮你将这些针对个人或团队特定的改动沉淀下来，在执行 npx @modern-js/create@latest 只需简单的带上 --plugin\n参数即可避免每次创建完项目都需重复性修改项目的工作。\n\n生成器插件是在 Modern.js 提供的初始化模板项目的基础上，提供对模板进行增加、删除、修改的方法，并通过快捷的方式修改\npackage.json、modernConfig 配置和开启功能等操作。\n\n\n创建项目#\n\n使用 @modern-js/create 可直接创建生成器插件项目：\n\n\n\n创建完成后，我们可以看一下这个项目的目录结构：\n\n\n\n项目是基于 Npm 模块项目创建的，核心是下面几个文件：\n\n\n\n\npackage.json#\n\npackage.json 中除了正常的模块项目的字段外，提供了 meta 字段，用于描述生成器插件的信息。\n\n生成器插件分为两类：扩展和自定义，具体分类定义可查看类型。\n\n\n\n\nsrc/index.ts#\n\n该文件用于完成生成器插件的内容开发。\n\n\n\n该文件默认导出一个函数，函数参数为 context，context 上提供了生成器插件支持的 API 方法，可用于实现生成器插件的逻辑。context\n提供的能力可以参考 context。\n\n\ntemplates#\n\ntemplates 目录存在当前定制化方式的模板文件，支持 Handlebars 和 EJS\n格式，将根据模板文件后缀使用不同的渲染引擎执行渲染，如果无后缀，将会直接复制模板文件到目标目录。\n\n如果模板文件为 js、ts 或者 json 文件，推荐直接使用 .handlebars 或者 .ejs 后缀，可避免项目 eslint 报错和在\nMonorepo 中项目识别问题。\n\n模板中 .gitignore 文件和 .npmrc 文件在发布 npm 包时会自动删除，需要使用 .handlebars 或者 .ejs 后缀将其保留。","routePath":"/guides/topic-detail/generator/plugin/structure","lang":"zh","toc":[{"text":"介绍","id":"介绍","depth":2,"charIndex":3},{"text":"创建项目","id":"创建项目","depth":2,"charIndex":445},{"text":"package.json","id":"packagejson","depth":2,"charIndex":550},{"text":"src/index.ts","id":"srcindexts","depth":2,"charIndex":654},{"text":"templates","id":"templates","depth":2,"charIndex":788}],"domain":"","frontmatter":{"sidebar_position":1},"version":""},{"id":581,"title":"使用","content":"#\n\n@modern-js/create 提供了 --plugin 参数用于运行生成器插件项目。\n\n--plugin 支持三种格式：\n\n\n绝对路径#\n\n适用于本地开发调试，开发完成后，在生成器插件执行 npm run build 构建项目，然后使用下面命令即可进行测试。\n\n\n\n\n相对路径#\n\n适用于本地开发调试或者生成器插件项目和目标创建项目在同一个 Monorepo，无需发布 NPM 包，构建项目后，执行下面命令即可。\n\n\n\n\nnpm 包#\n\n适用于生成器插件发布于 npm 上，共享生成器插件场景。\n\n","routePath":"/guides/topic-detail/generator/plugin/use","lang":"zh","toc":[{"text":"绝对路径","id":"绝对路径","depth":2,"charIndex":68},{"text":"相对路径","id":"相对路径","depth":2,"charIndex":139},{"text":"npm 包","id":"npm-包","depth":2,"charIndex":216}],"domain":"","frontmatter":{"sidebar_position":3},"version":""},{"id":582,"title":"微前端介绍","content":"#\n\n微前端（Micro-frontend，简称\nMFE）是一种类似于微服务的架构，是一种由独立交付的多个前端应用组成整体的架构风格，它将前端应用分解成一些更小、更简单的能够独立开发、测试、部署的应用，而在用户\n看来仍然是内聚的单个产品。\n\n它主要解决了两个问题：\n\n * 随着项目迭代应用越来越庞大，难以维护。\n\n * 跨团队或跨部门协作开发项目导致效率低下的问题。\n\n\n微前端关键词#\n\n在微前端研发模式中，应用会被分成 主应用、和 子应用。\n\n * 主应用：微前端项目的基座工程，所有子应用都会由它来加载。\n * 子应用：独立开发、独立部署的应用，最终会被主应用加载。\n\n\n功能简介#\n\n * 基于 Garfish\n * 生成器支持微前端应用\n * 支持 React 组件式引用微前端子应用\n * 支持 loading\n * 支持主应用线上、子应用线下调试模式\n\n可以在 体验微前端 一节学习如何开发微前端主子应用。","routePath":"/guides/topic-detail/micro-frontend/c01-introduction","lang":"zh","toc":[{"text":"微前端关键词","id":"微前端关键词","depth":2,"charIndex":186},{"text":"功能简介","id":"功能简介","depth":2,"charIndex":289}],"domain":"","frontmatter":{"sidebar_position":1},"version":""},{"id":583,"title":"体验微前端","content":"#\n\n通过本章你可以了解到：\n\n * 如何创建微前端项目的主应用、子应用。\n * 微前端项目开发的基本流程。\n\n\n创建应用#\n\n目前项目的路由模式分为以下三种\n\n * 约定式路由 (设置 router: true 并使用文件路由)\n * 自控式路由 (设置 router: true 并自己创建 BrowserRouter 等)\n * 其他 (设置 router: false 项目内自己安装和使用 react-router-dom)\n\n在本教程中我们会为主应用创建两个子应用 Table 和 Dashboard (Table 为约定式路由，Dashboard 为自控式路由)\n\n\n创建约定式路由主应用#\n\n通过命令行工具初始化项目：\n\n\n\n\n\n完成项目创建后我们可以通过 pnpm run new 来开启 微前端 功能：\n\n\n\n接下来，让我们注册微前端插件并添加开启微前端主应用，并增加子应用列表：\n\n\n\n然后我们在 routes 文件夹下新建两个目录\n\n * table (用于加载约定式路由子应用)\n * dashboard (用于加载自控式路由子应用)\n\n在这两个目录下我们需要新建一个 $.tsx 文件作为主应用约定式路由的入口($ 代表模糊匹配，即 /table 和 /table/test 都会匹配到这个\n$.tsx 作为该路由的入口文件，这会保证在微前端场景下正确加载子应用路由)\n\n加载约定式路由子应用#\n\n\n\n加载自控式路由子应用#\n\n\n\n路由跳转#\n\n此时主应用配置已经完成，通过路由即可加载子应用，修改主应用的 layout.tsx 来跳转路由\n\n\n\n\n创建自控式路由主应用#\n\n通过命令行工具初始化项目：\n\n\n\n\n\n完成项目创建后我们可以通过 pnpm run new 来开启 微前端 功能：\n\n\n\n接下来，让我们注册微前端插件并添加开启微前端主应用，并增加子应用列表：\n\n\n\n由于是自控式路由，我们删除掉 routes 文件夹并在 src 目录下增加 App.tsx 文件，此处如果使用的 非 MApp 组件，需要通过 React\nRouter v6 的 createBrowserRouter API 来创建路由\n\n加载子应用#\n\n\n\n\n创建其他主应用#\n\n项目内自己安装和使用 react-router-dom , 与自控式路由唯一的区别是, 设置 router: false 后 plugin-garfish\n无法获得 useLocation useHref 等 hook 来辅助计算 basename 和主子应用路由同步\n\n\n创建约定式路由子应用#\n\n通过命令行工具初始化项目：\n\n\n\n按照如下选择，生成项目：\n\n\n\n我们执行 pnpm run new 来开启 微前端 功能：\n\n\n\n接下来，让我们注册微前端插件并修改 modern.config.ts，添加微前端子应用的配置 deploy.microFrontend：\n\n\n\n添加 src/routes/page.tsx 代码\n\n\n\n\n创建自控式路由子应用#\n\n通过命令行工具初始化项目：\n\n\n\n按照如下选择，生成项目：\n\n\n\n我们执行 pnpm run new 来开启 微前端：\n\n\n\n接下来，让我们注册微前端插件并修改 modern.config.ts，添加微前端子应用的配置 deploy.microFrontend：\n\n\n\n自控式路由需要删除掉 routes 文件夹并在 src 目录下新建 App.tsx\n\n并在 src/App.tsx 添加代码，注意需要从 props 中解析并传递 basename 给 BrowserRouter\n\n\n\n\n调试#\n\n按顺序在目录执行 pnpm run dev 命令启动应用：\n\n * masterApp 主应用 http://localhost:8080\n * table 子应用(约定式路由) http://localhost:8081\n * dashboard 子应用(自控式路由) http://localhost:8082\n\n访问主应用地址 http://localhost:8080\n\n在完成了微前端整体开发流程的体验后，你可以进一步了解如何 开发主应用\n\n\nModern.js 微前端和直接使用 Garfish 的区别#\n\n使用纯 Garfish API 开发微前端应用时\n\n * 主应用：\n   * 安装 Garfish 依赖并使用 Garfish.run 注册子应用 参考\n   * 提供一个常驻的 DOM 节点供子应用挂载 参考\n * 子应用：\n   * 导出 provider 参考\n   * 设置应用的 basename 参考\n\n区别于直接使用 Garfish 运行时 API 开发微前端项目，Modern.js 的微前端方案更加开箱即用。 使用 pnpm new 启用微前端模式后会自动在\nModern.js 应用中集成 Garfish 插件，在 Garfish 插件的加持下，你只需要\n\n * 主应用：\n   * 配置 runtime.masterApp.apps 参数注册子应用\n   * 使用 useModuleApps API 获取子应用实例并在组件中完成渲染\n * 子应用：\n   * 配置 deploy.microFrontend\n\n所以插件中为你做了如下事情\n\n * 帮助你通过 Garfish 运行时 API 自动注册子应用（主应用）\n * useModulesApps 函数的返回值提供了一个常驻的 DOM 节点供子应用挂载（主应用）\n * 帮助你正确导出了 provider（子应用）\n * 帮助你正确设置了 basename 给 Modern.js 运行时提供 Router 实例，如果是自控式路由或手动引入的 react-router-dom\n   那么需要从 App.tsx 的 props 中获取 basename 手动传递给引入的 Router 实例（子应用）\n\n\n常见问题#\n\n自查手册: https://www.garfishjs.org/issues/","routePath":"/guides/topic-detail/micro-frontend/c02-development","lang":"zh","toc":[{"text":"创建应用","id":"创建应用","depth":2,"charIndex":56},{"text":"创建约定式路由主应用","id":"创建约定式路由主应用","depth":3,"charIndex":290},{"text":"加载约定式路由子应用","id":"加载约定式路由子应用","depth":4,"charIndex":599},{"text":"加载自控式路由子应用","id":"加载自控式路由子应用","depth":4,"charIndex":614},{"text":"路由跳转","id":"路由跳转","depth":4,"charIndex":629},{"text":"创建自控式路由主应用","id":"创建自控式路由主应用","depth":3,"charIndex":688},{"text":"加载子应用","id":"加载子应用","depth":4,"charIndex":922},{"text":"创建其他主应用","id":"创建其他主应用","depth":3,"charIndex":933},{"text":"创建约定式路由子应用","id":"创建约定式路由子应用","depth":3,"charIndex":1080},{"text":"创建自控式路由子应用","id":"创建自控式路由子应用","depth":3,"charIndex":1261},{"text":"调试","id":"调试","depth":2,"charIndex":1520},{"text":"Modern.js 微前端和直接使用 Garfish 的区别","id":"modernjs-微前端和直接使用-garfish-的区别","depth":2,"charIndex":1752},{"text":"常见问题","id":"常见问题","depth":2,"charIndex":2477}],"domain":"","frontmatter":{"sidebar_position":2,"title":"体验微前端"},"version":""},{"id":584,"title":"开发主应用","content":"#\n\n在上一章 体验微前端 通过一个示例演示了如何创建和配置微前端子应用，通过本章你可以进一步了解如何开发主应用，以及它的常见配置。\n\n在通过 @modern-js/create 命令创建 Modern.js 工程后，可以在项目中执行 pnpm run new（实际执行了 modern new\n命令），在选择了「微前端」模式后，会安装微前端依赖依赖，只需手动注册插件即可。\n\n\n\n\n注册子应用信息#\n\n当在 masterApp 配置上提供了信息后，将会认为该应用为主应用，目前存在两种子应用信息的配置方式，这两种方式分别应用于不同的场景。\n\n\n直接注册子应用信息#\n\n可以直接通过配置注册子应用信息：\n\n提示\n\n可以通过 API defineConfig 在运行时进行配置。 当参数为函数时无法被序列化到产物代码，所以在涉及到函数之类的配置时请通过\ndefineConfig 来进行配置\n\n\n\n\n自定义远程应用列表#\n\n通过该函数可以拉取远程的子应用列表，并将其注册至运行时框架：\n\n\n\n\n渲染子应用#\n\n在微前端中分为两种加载子应用的方式：\n\n 1. 子应用组件 获取到每个子应用的组件，之后就可以像使用普通的 React 组件一样渲染微前端的子应用。\n 2. 集中式路由 通过集中式的路由配置，自动根据当前页面 pathname 激活渲染对应的子应用。\n\n\n子应用组件#\n\n开发者使用 useModuleApps 方法可以获取到各个子应用的组件。\n\n再通过 router 组件的结合运用，开发者可以自控式的根据不同的路由渲染不同的子应用。\n\n假设我们的子应用列表配置如下：\n\n\n\n编辑主应用 App.tsx 文件如下：\n\n\n\n这里通过 Route 组件自定义了 Table 的激活路由为 /table， Dashboard 的激活路由为 /dashboard。\n\n\n集中式路由#\n\n集中式路由 是将子应用的激活路由集中配置的方式。我们给子应用列表信息添加 activeWhen 字段来启用 集中式路由。\n\n\n\n然后在主应用中使用 useModuleApp 方法获取 MApp 组件, 并在主应用渲染 MApp。\n\n\n\n这样启动应用后，访问 /table 路由，会渲染 Table 子应用，访问 /dashboard 路由，会渲染 Dashboard 子应用。\n\n\n两种模式混用#\n\n当然 子应用组件 和 集中式路由 是可以混合使用的。\n\n * 一部分子应用作为 子应用组件 激活，另外一部分作为 集中式路由 激活。\n * 一部分子应用既可以作为 集中式路由 激活，也可以作为 子应用组件 激活。\n\n\n添加 loading#\n\n通过配置 loadable 配置，可以为「集中式路由」、「子应用」添加 loading\n组件，并可以考虑错误、超时、闪烁等情况的出现，从而为用户提供更好的用户体验。该功能的设计与实现参考至 react-loadable，基本功能较为相似。\n\n\n\n增加错误状态#\n\n当微前端子应用加载失败或渲染失败时，loading component 将会接收 error 参数（若没有错误时 error 是 null）\n\n\n\n避免 loading 闪退#\n\n有时 loading 组件的显示时间可能小于 200ms，这个时候会出现 loading 组件闪退的情况。许多用户研究证明，loading\n闪退的情况会导致用户感知加载内容的耗时比实际耗时更长，在 loading 小于 200ms 时，不展示内容，用户会认为它更快。\n\n所以 loading 组件还提供了 pastDelay 参数，超过设置的延迟展示时才会为 true，可以通过 delay 参数设置延迟的时长\n\n\n\ndelay 的默认值为 200ms，可以通过 loadable 中的 delay 来设置延迟展示的时间\n\n\n\n增加超时状态#\n\n有时因为网络的原因，从而导致微前端子应用加载失败，从而导致一直展示 loading\n的状态，这对于用户而言非常糟糕，因为他们不知道合适才会获得具体的响应，他们是否需要刷新页面，通过增加超时状态可以很好的解决该问题。\n\nloading 组件在超时时会获得 timeOut 参数，当微前端应用加载超时时将会获得 timeOut 属性值为 true\n\n\n\n超时状态是关闭的，可以通过在 loadable 中设置 timeout 参数开启\n\n","routePath":"/guides/topic-detail/micro-frontend/c03-main-app","lang":"zh","toc":[{"text":"注册子应用信息","id":"注册子应用信息","depth":2,"charIndex":191},{"text":"直接注册子应用信息","id":"直接注册子应用信息","depth":3,"charIndex":272},{"text":"自定义远程应用列表","id":"自定义远程应用列表","depth":3,"charIndex":398},{"text":"渲染子应用","id":"渲染子应用","depth":2,"charIndex":445},{"text":"子应用组件","id":"子应用组件","depth":3,"charIndex":581},{"text":"集中式路由","id":"集中式路由","depth":3,"charIndex":785},{"text":"两种模式混用","id":"两种模式混用","depth":3,"charIndex":984},{"text":"添加 loading","id":"添加-loading","depth":3,"charIndex":1102},{"text":"增加错误状态","id":"增加错误状态","depth":4,"charIndex":1238},{"text":"避免 loading 闪退","id":"避免-loading-闪退","depth":4,"charIndex":1321},{"text":"增加超时状态","id":"增加超时状态","depth":4,"charIndex":1601}],"domain":"","frontmatter":{"sidebar_position":3,"title":"开发主应用"},"version":""},{"id":585,"title":"主子应用通信","content":"#\n\n\nprops 通信#\n\nModern.js 中，会将子应用包裹成一个 React 组件，直接通过给 React 组件传递 props 即可实现主应用和子应用通信的目的。\n\n\n\n\n\n子应用将会打印 {count: 0}，目前尚未支持子应用渲染响应式，及时在主应用上更改 count 的数据也不会触发视图更新\n\n\nchannel 通信#\n\nGarfish.channel 用于应用间的通信。它是 EventEmitter2 的实例\n\n","routePath":"/guides/topic-detail/micro-frontend/c04-communicate","lang":"zh","toc":[{"text":"props 通信","id":"props-通信","depth":2,"charIndex":3},{"text":"channel 通信","id":"channel-通信","depth":2,"charIndex":157}],"domain":"","frontmatter":{"sidebar_position":4,"title":"主子应用通信"},"version":""},{"id":586,"title":"混合技术栈","content":"#\n\nModern.js 微前端方案是基于 Garfish 封装的，提供了一些更开箱即用的使用方式。\n\n当你的主应用和子应用不全是 Modern.js 应用的时候，可以参考这篇文档。\n\n 1. 子应用是 Modern.js，主应用使用的原生 Garfish 微前端。\n 2. 主应用是 Modern.js，子应用有的是其它技术栈。\n\n\n子应用是 Modern.js#\n\nModern.js 子应用编译后会生成标准的 Garfish 子应用导出。 所以可以直接接入标准的微前端主应用。\n\nINFO\n\n子应用是 Modern.js，主应用使用的原生 Garfish 微前端时，子应用调试模式 不可用。\n\n\n主应用是 Modern.js#\n\n主应用是 Modern.js，子应用用的其它技术栈。子应用按照 Garfish 子应用标准 开发即可。","routePath":"/guides/topic-detail/micro-frontend/c05-mixed-stack","lang":"zh","toc":[{"text":"子应用是 Modern.js","id":"子应用是-modernjs","depth":2,"charIndex":167},{"text":"主应用是 Modern.js","id":"主应用是-modernjs","depth":2,"charIndex":300}],"domain":"","frontmatter":{"sidebar_position":5,"title":"混合技术栈"},"version":""},{"id":587,"title":"自动生成 Actions","content":"#\n\n在 快速上手 中，我们实现最简单的计数器 Model 也需要 10 行代码。 实际上，Modern.js 支持根据声明的 state 类型，自动生成常用的\nActions，从而简化模板代码量。当前支持的类型有：\n\n * 原始数据类型\n * 数组类型\n * 简单对象类型（Plain Object）\n\n\n原始数据类型#\n\n\n\n如上我们仅用一行就完成了一个简单的 countModel。使用 Model 的示例代码如下：\n\n\n\n\n数组类型#\n\n当 State 为数组类型时，自动生成 Actions 的示例代码如下：\n\n\n\n我们可以使用 JavaScript Array 对象的方法，修改 State。\n\n\n简单对象类型#\n\n当 State 为简单对象类型时，自动生成 Actions 的示例代码如下：\n\n\n\n根据 a、b、c 三个不同的字段分别生成 setA、setB、setC 三个 Actions。\n\nINFO\n\n当用户自定义的 Action 和 Modern.js 自动生成的 Action 名字一致时，用户自定义的 Action 优先级更高。例如，countModel\n中已经自定义 setA 这个 Action，调用 actions.setA() 时，最终执行的是用户自定义的 setA。\n\n在\n\n补充信息\n\n相关 API 的更多介绍，请参考这里。","routePath":"/guides/topic-detail/model/auto-actions","lang":"zh","toc":[{"text":"原始数据类型","id":"原始数据类型","depth":2,"charIndex":153},{"text":"数组类型","id":"数组类型","depth":2,"charIndex":215},{"text":"简单对象类型","id":"简单对象类型","depth":2,"charIndex":304}],"domain":"","frontmatter":{"sidebar_position":6,"title":"自动生成 Actions"},"version":""},{"id":588,"title":"衍生状态","content":"#\n\n一些场景中，组件需要对 Model 中的 State 进行进一步计算，才能在组件中使用，这部分逻辑可以直接写在组件内部，也可以通过 Model 的衍生状态实现。\n衍生状态定义在 Model 中的 computed 字段下。根据依赖的 Model 的不同、返回类型的不同，衍生状态的定义方法可以分为以下 3 种。\n\n\n只依赖自身的 State#\n\n衍生状态只依赖当前 Model 的 State，State 会作为第一个参数，传入衍生状态的定义函数中。\n\n例如， todo 应用的 State 有 items 和 filter，filter 用于过滤当前页面显示的 todo 项，所以我们定义了一个\nvisibleTodos 的衍生状态可以直接在组件中使用。示例代码如下：\n\n\n\n衍生状态最终会和 Model 的 State 进行合并，因此，可以通过 Model 的 State 对象访问到衍生状态，例如，visibleTodos\n在组件内的使用方式如下：\n\n\n\n\n依赖其他 Model 的 State#\n\n除了依赖当前 Model 的 State，衍生状态还依赖其他 Model 的 State，这时候衍生状态的定义格式为：\n\n\n\n下面的示例，演示了 barModel 的衍生状态 combinedValue 是如何依赖 fooModel 的 State 的。\n\n\n\n\n函数类型的衍生状态#\n\n衍生状态还可以返回一个函数。这时候衍生状态的定义格式为：\n\n\n\n假设，todo 应用的 state 不存储 filter 状态，而是直接在组件中使用，那么 visibleTodos\n可以是一个函数类型的值，这个函数在组件中使用的时候，接收 filter 参数。如下所示：\n\n\n\n更多参考\n\n使用 Model","routePath":"/guides/topic-detail/model/computed-state","lang":"zh","toc":[{"text":"只依赖自身的 State","id":"只依赖自身的-state","depth":2,"charIndex":160},{"text":"依赖其他 Model 的 State","id":"依赖其他-model-的-state","depth":2,"charIndex":434},{"text":"函数类型的衍生状态","id":"函数类型的衍生状态","depth":2,"charIndex":587}],"domain":"","frontmatter":{"sidebar_position":4,"title":"衍生状态"},"version":""},{"id":589,"title":"创建 Model","content":"#\n\n上一节的计数器应用中，我们简单演示了如何创建一个 Model。本节我们将详细介绍 Model 的创建方法。\n\n通过 model API 创建 Model，例如，model('foo') 表示要创建一个名为 foo 的 Model，通过调用 model('foo')\n返回的 define 函数，定义 Model 包含的 State、Actions 等：\n\n\n\nINFO\n * Model 中的 Action 中不能包含有副作用的逻辑，如请求 HTTP 接口，访问 localStorage 等。\n * setValue 内部直接修改了入参 State，看起来是违反了纯函数的定义，实际上 Reduck 内部使用 immer\n   来修改不可变对象，保证了这种写法不会影响对象的不可变性，所以 setValue 仍然是一个纯函数。当然，你也可以直接在 Action\n   中返回一个新对象，不过这样的写法会更加复杂一些。\n\ndefine 接收的参数，只是对 Model 原始结构的描述：内部定义的 State、Actions 等。define 返回值 fooModel\n才是真正创建得到的 Model 对象。例如，虽然 setValue，有 2 个参数，但是当真正调用 setValue 这个 Action 时，我们只需要传入\npayload 一个参数，因为我们调用的是 fooModel 上的 Action 方法，而不是 Model 原始结构上描述的 Action 方法。详细参考使用\nModel。\n\ndefine 除了接收对象类型的参数，还可以接收函数类型的参数。例如：\n\n\n\n通过函数定义 Model 时，函数内部会自动传入 context、utils 2 个参数，context 是 Reduck 的上下文对象，可以获取到 store\n对象，utils 提供了一组工具函数，方便实现 Model 通信等复杂功能需求。\n\nModel 支持复制。例如：\n\n\n\nbarModel 是基于 fooModel 创建出一个的新的 Model 对象，类比面向对象编程语言中的概念，barModel 和 fooModel\n是基于同一个类（Class）创建出的 2 个实例对象。当两个模块的状态管理逻辑相同，例如一个页面中的两个 tab\n模块，使用的数据的结构和逻辑相同，区别只是从不同的接口获取数据，那么可以通过 Model 复制的方式，创建 2 个不同的 Model 对象。\n\n补充信息\n\n本节涉及的 API 的详细定义，请参考这里。","routePath":"/guides/topic-detail/model/define-model","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_position":2,"title":"创建 Model"},"version":""},{"id":590,"title":"常见问题","content":"#\n\n\n浏览器兼容性#\n\nReduck 的编译构建产物默认使用 ES6 语法，如果你需要支持更低版本的浏览器，请将 @modern-js-reduck\n命名空间下的所有包加入到应用的编译过程。\n\n补充信息\n\nReduck 使用的 @babel/preset-env 的详细配置。\n\n\n微前端子应用 Model 访问主应用 Model#\n\n微前端子应用 Model 访问主应用 Model 时，如果该 Model 在主应用尚未挂载，会自动挂载到子应用上。\n\n示例：\n\n\n\n\n\n为了避免意外降级挂载，建议将主应用所需要共享的 Model 预先挂载：\n\n","routePath":"/guides/topic-detail/model/faq","lang":"zh","toc":[{"text":"浏览器兼容性","id":"浏览器兼容性","depth":2,"charIndex":3},{"text":"微前端子应用 Model 访问主应用 Model","id":"微前端子应用-model-访问主应用-model","depth":2,"charIndex":141}],"domain":"","frontmatter":{"sidebar_position":13,"title":"常见问题"},"version":""},{"id":591,"title":"副作用管理","content":"#\n\nModel 中的 Action 必须是一个纯函数，执行过程中不会产生任何副作用。但在真实的业务中，我们会遇到很多副作用场景，如：请求 HTTP\n接口获取状态数据，或者在更新状态的同时修改 localStorage、发送事件等。在 Reduck 中，是通过 Model 的 Effects\n函数管理副作用的。\n\n\n副作用对 State 修改#\n\n副作用修改 State，最常见的场景就是请求 HTTP 接口，更新状态数据。\n\n我们以一个简单的 todoModel 为例。其有一个 load 的副作用函数，请求远端的 TODO 列表，请求成功之后更新 state.items 字段。\n\n\n\n副作用函数统一定义在 effects 字段下。这里我们写了一个 load 函数，它返回一个 Promise，Promise 执行成功后，返回 TODO 列表\n[\"Lerna Modern.js\"]。\n\n副作用函数需要和 actions 配合使用，才能完成状态的修改。因此，我们在 actions 中定义了一个 load（命名需要和 effects\n下的副作用函数的名字保持一致）对象，包含 pending、fulfilled、rejected 3 个 action，分别是对副作用函数 load 返回的\nPromise 的三种状态（ pending、fulfilled、rejected ）的处理：\n\n * pending：接收当前状态 state 作为参数，新的状态中 loading 设为 true。\n * fulfilled：接收当前状态 state 和 Promise fulfilled 状态的值 items 为参数，新的状态中 items 等于参数\n   items、loading 设为 false。\n * rejected：接收当前状态 state 和 Promise rejected 状态的错误 error 为参数，新的状态中 error 等于参数\n   error、loading 设为 false。\n\n组件中如何调用 effects 函数呢？ effects 函数会被合并到 actions 对象上，因此可以通过 actions 对象调用 effects\n函数，如下所示：\n\n\n\n上面的示例中， pending、fulfilled、rejected 3 个 action，对于用于获取数据的 HTTP\n请求场景下，一般都是需要的。Reduck 提供了一个工具函数 handleEffect，用于简化这种场景下的 action 创建。\n\nhandleEffect 约定这种副作用场景下， Model 的 State 结构包含 result、error、pending 3 个字段，初始值为：\n\n\n\n调用 handleEffect 会返回如下数据结构:\n\n\n\n这个数据结构和我们在 actions 下的 load 对象的数据结构是相同的。handleEffect 返回的对象，其实就是对应了 Effects 函数需要的\n3 个 action。\n\n利用 handleEffect，改写 todoModel：\n\n\n\nhandleEffect 接收的参数对象，将 result 设置为 item。因为 todoModel 的 state，使用 items 作为 key 保存\ntodo 列表数据，而不是使用 handleEffect 默认的 result 作为 key，所以这里需要进行配置。\n\n明显可见，通过 handleEffect 实现的 todoModel 比之前的实现有了很大精简。\n\n如果不希望 pending、fulfilled、rejected 3 种状态都被 handleEffect 自动处理，例如 fulfilled\n需要手动处理较复杂的数据类型，但是 pending、rejected 依旧想进行自动化处理，可以参考如下写法：\n\n\n\n补充信息\n\nhandleEffect API。\n\nEffects 函数中，也支持手动调用 Actions，例如：\n\n\n\nINFO\n\n可以使用 use 函数加载其它 Model（包括 Model 自身），实现 Model 间通信。\n\n\n副作用不影响 state#\n\n有些场景下，我们只需要读取 State，执行相关副作用逻辑，副作用不会修改 State。\n\n例如，存储某些 State 到 localStorage：\n\n\n\n或者是向服务端发送数据：\n\n\n\n\n副作用函数返回值#\n\n有时候，我们希望能根据副作用函数的执行结果，直接执行后续逻辑。这时候，就需要使用 Effects 函数的返回。\n\n例如，当点击发送按钮，发送数据成功后，立即关闭当前的弹窗；如果失败，显示错误信息。我们可以通过如下代码实现：\n\n\n\n补充信息\n\n示例代码","routePath":"/guides/topic-detail/model/manage-effects","lang":"zh","toc":[{"text":"副作用对 State 修改","id":"副作用对-state-修改","depth":2,"charIndex":158},{"text":"副作用不影响 state","id":"副作用不影响-state","depth":2,"charIndex":1748},{"text":"副作用函数返回值","id":"副作用函数返回值","depth":2,"charIndex":1859}],"domain":"","frontmatter":{"sidebar_position":5,"title":"副作用管理"},"version":""},{"id":592,"title":"Model 通信","content":"#\n\nModel 通信，既指不同 Model 间的通信，也指同一个 Model 内部 Effects、Actions 之间的通信。\n\n\nModel 间通信#\n\nModel 之间不是孤立的，是可以进行通信的。主要分为两种场景：\n\n 1. 在 Model 中访问其它 Model 的 State 和 Actions。\n 2. 在 Model 中监听其它 Model 变化。\n\n这里将 快速上手 一节的简单计数器应用改造成一个可设置步频的计数器应用。可以通过设置步频，从而影响每次计数器增加的幅度。\n\n我们抽象出两个 Model，分别为 stepModel（步频）、counterModel（计数器）：\n\n\n\nstepModel 只声明一个 state，初始值为 1。\n\ncounterModel 通过 use 函数加载 stepModel，拿到返回的 subscribeStep 函数，用来监听 stepModel 状态的变更。\nonMount 是 Model 挂载完成后的钩子函数，counterModel 挂载完成后开始订阅 stepModel 状态的变更，打印出 stepModel\n的最新值。\n\ncounterModel 通过 use 函数访问 stepModel，在 add 里可以获取到当前 stepModel 的值（步频），以此值来做自增。\n\n注意\n\n当需要访问其他 Model 的 State 时，必须要在当前 Actions 或 Effects 函数（本例中对应 add 函数 ）真正执行的阶段调用\nuse，以保证获取的 State 是最新值。因此，我们虽然在 define 的回调函数中也调用了 use(stepModel)，但是我们并没有解构\nstepModel 的 state 值，因为 define 的回调函数是在 Model 的挂载阶段执行的，这个时候获取到的 stepModel 的 state\n可能和 add 执行时获取到的值是不同的。\n\n修改 App.tsx\n\n\n\n补充信息\n\nModern.js 默认开启 自动生成 actions，所以 stepModel 中虽然没有手动定义 Actions，但可以使用自动生成的 setState。\n\n * 点击 add step 增加步频。\n * 点击 add counter 触发计数器增加。\n\n最终效果如下：\n\n\n\n补充信息\n * 本节完整的示例代码。\n * 相关 API 的更多介绍，请参考：model。\n\n前面 counterModel 的例子，我们是在 Actions 的函数内部调用 use 获取其他 Model 对象的。如果只需要调用其它 Model 的\nActions，因为 Actions 都是函数，不存在值过期问题，所以也可以在 define 的回调函数中调用 use 获取 Model 的\nActions。例如：\n\n\n\n这样，我们不需要在 loadA、loadB 中重复获取 barModel 对象，简化了代码逻辑。\n\n\nModel 内通信#\n\nModel 内通信，也主要分为两种场景：\n\n 1. Effects 函数调用自身 Model 的 Actions 函数、或其他 Effects 函数。\n 2. Actions 函数调用自身 Model 的 其他 Actions 函数。\n\n在 副作用管理 一节，我们演示过 Effects 函数如何调用 Actions 函数。\n\n这里我们再来举一个例子：\n\n\n\n这个例子中，fooModel 的两个 Effects 函数，需要调用自身的 Actions 函数。这里我们在每个 Effects 函数中，都调用了一次\nuse，为什么不能像 Model 间通信的例子中，在 define 的回调函数中，统一调用 use 获取 Model 自身的 Actions 呢？这是因为调用\nuse 获取 Model 时，会先检查这个 Model 是否已经挂载，如果还没有挂载，会先执行挂载逻辑，而 define 的回调函数又是在 Model\n的挂载阶段执行的，这样一来，在挂载阶段调用 use 获取 Model 自身，会出现死循环（代码实际执行过程会抛出错误）。所以，一定不能在 define\n的回调函数中，调用 use 获取 Model 自身对象。\n\n不过，我们可以利用 onMount 这个钩子函数，在 Model 挂载完成后，再通过 use 获取 Model 自身对象：\n\n\n\n这样，我们也可以实现代码的简化。","routePath":"/guides/topic-detail/model/model-communicate","lang":"zh","toc":[{"text":"Model 间通信","id":"model-间通信","depth":2,"charIndex":67},{"text":"Model 内通信","id":"model-内通信","depth":2,"charIndex":1256}],"domain":"","frontmatter":{"sidebar_position":7,"title":"Model 通信"},"version":""},{"id":593,"title":"性能优化","content":"#\n\nReduck 内部已经做了大量性能优化工作，一般情况下不需要考虑性能问题。不过当对性能比较敏感、或者遇到了性能问题，可以考虑从以下 3\n个方面，进行更有针对性的性能优化。\n\n\nModel 拆分#\n\n当 useModel 返回 Model 对象的完整 State 时，State 任意部分的变化都会导致调用了 useModel 的组件重新渲染。\n\n例如：\n\n\n\n组件 ComponentA 虽然只需要使用 a 状态，但当 b 状态发送变化时， ComponentA 仍然会重新渲染。这种情况，我们可以考虑把\nfooModel 拆分，a、b 分别由不同的 Model 负责管理：\n\n\n\n\n状态筛选#\n\nuseModel 支持传入 selector 函数，对返回给组件的 State 和 Actions 做筛选。我们可以通过 selector\n函数，确保返回给组件的 State 是组件直接需要使用的，从而保证组件不会因为其他无关状态的变化而重新渲染。\n\n对于上面同样的例子，我们采用 selector 函数进行性能优化，代码如下：\n\n\n\n\n衍生状态缓存#\n\n当 Model 存在 computed 时，每次调用useModel 都会执行 computed 函数。\n\n考虑如下代码：\n\n\n\nbarModel 的衍生状态 combineA 依赖 barModel 自身状态 和 fooModel 的状态 a，但是即使是 fooModel 的状态 b\n发生了变化，组件重新渲染时， combineA （更准确的说法是 combineA 的最后一个函数类型的元素 ）依然会被调用执行。\n\n一般情况下，computed 函数中的逻辑都是非常轻量的，但当 computed 函数逻辑比较复杂时，我们可以考虑对计算逻辑做缓存。例如，我们使用\nreselect 对 barModel 的 combineA 做缓存：\n\n\n\n我们创建缓存函数 createSelector，仅当 barModel 的状态发生改变或 fooModel 的 a 状态发生改变时，才会重新计算\ncombineA 的值。\n\n补充信息\n\n本节完整的示例代码","routePath":"/guides/topic-detail/model/performance","lang":"zh","toc":[{"text":"Model 拆分","id":"model-拆分","depth":2,"charIndex":90},{"text":"状态筛选","id":"状态筛选","depth":2,"charIndex":294},{"text":"衍生状态缓存","id":"衍生状态缓存","depth":2,"charIndex":470}],"domain":"","frontmatter":{"sidebar_position":8,"title":"性能优化"},"version":""},{"id":594,"title":"快速上手","content":"#\n\nReduck 是 Modern.js 团队开发的遵循 MVC 模式的状态管理库，底层状态存储基于 Redux 实现，同时提供更高层级的抽象，并完全兼容\nRedux 生态。\n\nReduck 的目标是以 MVC 模式组织 React 应用开发结构，将业务逻辑维护在 Model 层，业务逻辑与 UI\n解耦，让开发业务逻辑更集中、更简单，同时通过更高层级的抽象，减少重复工作（样板代码）。\n\nReduck 在 MVC 模式中，扮演 M(Model) 的角色，React UI Component 对应 V(View)，从 Reduck 中获取\nModel 并修改 Model 的 React Container Component 对应 C(View Controller/Container)。\n\nModern.js 的状态管理解决方案，是通过内置 Reduck 实现的。在 Modern.js 中使用 Reduck，不仅免去了手动集成的环节，而且所有\nReduck API 都可以从 Modern.js 的 Runtime 包中直接导入使用，具有更好的一致性体验。\n\nINFO\n 1. Modern.js 中使用 Reduck API，需要先设置 runtime.state 以启用状态管理插件。\n 2. Reduck 也可以脱离 Modern.js 作为状态管理库单独使用。\n\n\n核心概念#\n\nReduck 中的核心概念只有 4 个： Model、State、Actions、Effects。\n\nModel: 对独立模块的逻辑和所需状态的封装，由 State、Actions、Effects 组成。\n\nState: Model 中保存的状态。\n\nActions: 用于修改 State 的纯函数，函数必须是同步的。\n\nEffects: 用于修改 State 的带有副作用的函数，函数可以是异步的。Effects 中可以调用自身或其他 Model 的 Actions 和\nEffects。\n\nReduck 数据流如下图所示：\n\n\n\n\n基本用法#\n\n下来我们以一个简单的 计数器 应用为例，演示 Reduck 的基本用法。\n\n首先，我们定义一个名为 count 的 Model：\n\n\n\n我们使用 API model 创建 countModel，countModel 当前只包含存储计数器值的状态，即代码中的 value。\n\n我们定义一个 action，用于计算器自增加 1：\n\n\n\n在 add action 中，我们可以直接修改 state 的值，进行加 1 操作，而不需要把 state 作为不可变对象进行操作，这是因为 Reduck\n集成了 immer，可以直接修改原 state 对象。\n\n接下来，我们演示如何在组件中使用 Model。\n\n新建一个组件 Counter，在组件内通过 useModel API 使用 countModel：\n\n\n\nuseModel 获取 countModel 的 state 和 actions，组件展示当前计算器的值，点击 add 按钮，计数器自增 1。\n\nINFO\n\n由于使用的案例比较简单，这里并没有严格按照 MVC 模式进行分层，组件 Counter 同时起到了 V 和 C 两层的作用。\n\n最终演示效果如下：\n\n\n\n这样，我们就完了一个简单的计数器应用。本节完整的示例代码可以在这里查看。","routePath":"/guides/topic-detail/model/quick-start","lang":"zh","toc":[{"text":"核心概念","id":"核心概念","depth":2,"charIndex":592},{"text":"基本用法","id":"基本用法","depth":2,"charIndex":868}],"domain":"","frontmatter":{"sidebar_position":1,"title":"快速上手"},"version":""},{"id":595,"title":"Redux 生态集成","content":"#\n\nReduck 基于 Redux 实现，因此可以使用 Redux 生态的库，实现功能增强。通过 Provider 、createApp 和 createStore\n等 API ，可以设置使用 Redux 的 中间件 和 Store Enhancer；使用 createStore 还可以完全掌控 Store 的创建过程。\n\n例如，我们希望使用中间件 redux-logger，示例代码如下：\n\n\n\nCAUTION\n\nReduck 基于 Redux 底层 API 做了上层封装，屏蔽了 Redux 的一些底层概念，如 Reducer 等。Reduck 对于 Model\n是动态挂载的，而 Redux 是在 Store 创建时就会挂载应用所需的全部状态。基于这些实现上的差异，有些 Redux 生态的库是无法直接在 Reduck\n中使用的。","routePath":"/guides/topic-detail/model/redux-integration","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_position":11,"title":"Redux 生态集成"},"version":""},{"id":596,"title":"TS 最佳实践","content":"#\n\nReduck 对 TS 提供了良好的支持，大部分使用场景下，无需任何额外工作，就可以直接获得 API 的 TS\n类型提示。本节，将对其他的一些使用场景，做补充介绍。\n\n\n定义 Model 的 State 类型#\n\n为 Model 的 State 声明类型信息，是在 TS 中使用 Reduck 的最佳实践。\n\n\n\n当为 Model 的 State 声明类型信息后，Model 的 computed、actions\n都能获取正确的类型信息。事实上，上面的示例代码中，即使我们不定义 State 类型信息，也会根据 state 的初始值信息自动推导出 State\n的类型信息。不过，仍然建议你在定义 Model 时，声明 State 的类型信息，因为根据 state 的初始值信息推导出的 State\n类型信息可能不完整(缺少字段或字段的类型信息缺少)，而且当使用函数类型定义 Model 时，State 的类型信息也是无法根据 state\n的初始值信息自动推导的。\n\n\n衍生状态的依赖类型#\n\n当 Model 的衍生状态依赖其他 Model 时，需要手动指定其他 Model 的 State。\n\n\n\n\n获取 Model 类型信息的 Hooks#\n\nReduck 提供了一组用于获取 Model 类型信息的工具类型：\n\n * GetModelState： 获取 Model 的 State（包含衍生状态）类型信息。\n * GetModelActions：获取 Model 的 Actions（包含 Effects 函数）类型信息。\n\n","routePath":"/guides/topic-detail/model/typescript-best-practice","lang":"zh","toc":[{"text":"定义 Model 的 State 类型","id":"定义-model-的-state-类型","depth":2,"charIndex":87},{"text":"衍生状态的依赖类型","id":"衍生状态的依赖类型","depth":2,"charIndex":436},{"text":"获取 Model 类型信息的 Hooks","id":"获取-model-类型信息的-hooks","depth":2,"charIndex":502}],"domain":"","frontmatter":{"sidebar_position":10,"title":"TS 最佳实践"},"version":""},{"id":597,"title":"使用 Model","content":"#\n\n\n在组件内使用#\n\n\n作为全局状态使用#\n\n通过 useModel 可以获取 Model 的 State、Actions 等。当 Model 的 State 通过 Actions\n进行修改后，任何其他使用了该 Model 的组件，都会自动重新渲染。\n\n在 快速上手 的计数器案例中，我们已经演示了 useModel 的使用，不再重复。\n\nuseModel 支持传入多个 Model，多个 Model 的 State 和 Actions 会进行合并后作为返回结果。例如：\n\n\n\nstate 和 actions 的值分别为：\n\n\n\nuseModel 还支持对 State 和 Actions 做 selector 操作，实现对 State 和 Actions 的筛选或重命名，例如：\n\n\n\n我们通过 stateSelector ，把 fooModel 和 barModel 中重名的状态做了命名修改，通过 actionsSelector ，过滤掉了\nbarModel 的 Actions。\n\n如果只需要设置 actionsSelector，可以把 stateSelector 设置为 undefined，作为参数占位。例如：\n\n\n\n\n作为静态状态使用#\n\n通过 useStaticModel 获取 Model ，将 Model 中的状态作为静态状态使用。可以保证组件每次访问到的 Model 的 State\n都是最新值，但是 Model 的 State 的变化，并不会引起当前组件的重新渲染。\n\nINFO\n\nuseStaticModel 的使用方式和 useModel 完全一致。\n\n考虑下面一种场景，有一个组件 Input 负责用户输入，另外一个组件 Search\n负责根据用户的输入信息，在点击查询按钮后执行查询操作，我们不希望用户输入过程中的状态变化引起 Search 重新渲染，这时候就可以使用\nuseStaticModel：\n\n\n\n注意\n\n不要解构 useStaticModel 返回的 state，例如改成如下写法： const [{input}] =\nuseStaticModel(searchModel); 将始终获取到 Input 的初始值。\n\nuseStaticModel 还适合和 react-three-fiber 等动画库一起使用，因为在动画组件 UI\n里绑定会快速变化的状态，容易引起性能问题。这种情况就可以选择使用\nuseStaticModel，它只会订阅状态，但不会引起视图组件的重新渲染。下面是一个简化示例：\n\n\n\n使用 React 的 refs 也可以实现类似效果，其实 useStaticModel 内部也使用到了 refs。不过直接 useStaticModel\n有助于将状态的管理逻辑从组件中解耦，统一收敛到 Model 层。\n\n完整的示例代码可以在这里查看。\n\n\n作为局部状态使用#\n\n通过 useLocalModel 获取 Model ，将 Model 中的状态作为局部状态使用。此时 Model State\n的变化，只会引起当前组件的重新渲染，但是不会引起其他使用了该 Model 的组件重新渲染。效果和通过 React 的 useState\n管理状态类似，但是可以将状态的管理逻辑从组件中解耦，统一收敛到 Model 层。\n\nINFO\n\nuseLocalModel 的使用方式和 useModel 完全一致。\n\n例如，我们修改计数器应用的代码，添加一个有局部状态的计数器组件 LocalCounter：\n\n\n\n分别点击 Counter 和 LocalCounter 的 add 按钮，两者的状态互不影响：\n\n\n\n完整的示例代码可以在这里查看。\n\n\n在组件外使用#\n\n在实际业务场景中，有时候我们需要在 React 组件外使用 Model，例如在工具函数中访问 State、执行 Actions 等。这个时候，我们就需要使用\nStore。 Store 是一个底层概念，一般情况下用户接触不到，它负责存储和管理整个应用的状态。Reduck 的 Store 基于 Redux 的 Store\n实现，增加了 Reduck 特有的 API，如 use 。\n\n首先，在组件内调用 useStore 获取当前应用使用的 store 对象，并挂载到组件外的变量上：\n\n\n\n通过 store.use 可以获取 Model 对象，store.use 的用法同 useModel 相同。以计数器应用为例，我们在组件树外，每 1s\n对计数器值 执行自增操作：\n\n\n\n完整的示例代码可以在这里查看。\n\nINFO\n\n如果是通过 createStore 手动创建的 Store 对象，无需通过 useStore 在组件内获取，即可直接使用。\n\n补充信息\n\n本节涉及的 API 的详细定义，请参考这里。","routePath":"/guides/topic-detail/model/use-model","lang":"zh","toc":[{"text":"在组件内使用","id":"在组件内使用","depth":2,"charIndex":3},{"text":"作为全局状态使用","id":"作为全局状态使用","depth":3,"charIndex":13},{"text":"作为静态状态使用","id":"作为静态状态使用","depth":3,"charIndex":517},{"text":"作为局部状态使用","id":"作为局部状态使用","depth":3,"charIndex":1204},{"text":"在组件外使用","id":"在组件外使用","depth":2,"charIndex":1549}],"domain":"","frontmatter":{"sidebar_position":3,"title":"使用 Model"},"version":""},{"id":598,"title":"单独使用 Reduck","content":"#\n\n在 Modern.js 以外，单独集成 Reduck 使用时，主要需要做以下修改：\n\n 1. 安装 Reduck 相关包\n\n在项目中安装 Reduck 包：@modern-js-reduck/react。\n\n 2. API 导入包名\n\n在 Modern.js 中使用时，Reduck 导出 API 的包名为：@modern-js/runtime/model。单独使用 Reduck\n时，导出包名为：@modern-js-reduck/react。\n\n 3. 包裹 Provider 组件\n\nModern.js 自动在应用的入口组件上，包裹了用于注入 Reduck 全局 Store 的 Provider 组件。单独使用 Reduck\n时，需要手动完成。\n\n示例：\n\n\n\n 4. 功能配置\n\n在 Modern.js 中使用时，可以通过 runtime.state 对 Reduck 功能进行配置。单独使用时，需要通过 Provider 的 config\n或 store 参数配置。\n\n示例：\n\n","routePath":"/guides/topic-detail/model/use-out-of-modernjs","lang":"zh","toc":[],"domain":"","frontmatter":{"sidebar_position":12,"title":"单独使用 Reduck"},"version":""},{"id":599,"title":"构建相关问题","content":"#\n\n如果你遇到了构建相关的问题，可以参考当前文档进行排查。\n\n--------------------------------------------------------------------------------\n\n\nRsbuild FAQ#\n\nModern.js 内部基于 Rsbuild 封装了自身的构建工具，因此你可以直接参考 Rsbuild 的 FAQ 文档：\n\n * Rsbuild - 功能类问题\n * Rsbuild - 异常类问题\n * Rsbuild - 热更新问题\n\n--------------------------------------------------------------------------------\n\n\n如何清空 webpack 编译缓存？#\n\n默认情况下，Modern.js 的 webpack 编译缓存生成在 ./node_modules/.cache/webpack 目录下。\n\n如果需要清空本地的编译缓存，可以执行以下命令：\n\n\n\n--------------------------------------------------------------------------------\n\n\n如何查看最终生成的 webpack / Rspack 配置?#\n\nModern.js 提供 inspect 命令 用于查看项目最终生成的 Modern.js 配置以及 webpack / Rspack 配置。\n\n\n\n--------------------------------------------------------------------------------\n\n\nwebpack 编译出现 'compilation' argument 报错？#\n\n如果编译时出现以下报错，通常是由于项目中安装了错误的 webpack 版本，或者安装了多个 webpack 版本引起：\n\n\n\nwebpack 版本问题有以下几种情况：\n\n 1. 项目的 package.json 中直接声明了 webpack 依赖，并且与 Modern.js 依赖的 webpack\n    版本范围不同，无法匹配到同一个版本。\n 2. 项目里安装的多个 npm 包都依赖了 webpack，并且它们依赖的 webpack 版本范围不同，无法匹配到同一个版本。\n 3. 由于包管理器的 lock 机制，导致 lock 文件中产生了多个 webpack 版本。\n\n如果是第一种情况，建议从项目的 package.json 中移除 webpack 依赖。因为 Modern.js 默认封装了 webpack 相关能力，并且会在\ntools.webpack 配置项中传入 webpack 对象。因此在大多数情况下，不建议在项目中额外安装 webpack 依赖。\n\n如果是第二种情况，建议看看能否升级某个 npm 包，使其依赖的 webpack 版本范围与 Modern.js\n保持一致。也可以通过包管理器的能力来手动统一版本，比如使用 yarn resolutions 或 pnpm overrides。\n\n如果是第三种情况，可以使用第二种情况中提到的两种方法，也可以尝试删除 lock 文件后重新安装来解决。\n\nTIP\n\n删除 lock 文件会使项目中的依赖版本自动升级到指定范围下的最新版，请进行充分的测试。\n\n--------------------------------------------------------------------------------\n\n\n在 Monorepo 中引用其他模块，代码没有被正确编译？#\n\n出于编译性能的考虑，默认情况下，Modern.js 不会编译 node_modules 下的文件，也不会编译当前工程目录外部的文件。\n\n因此，当你引用其他子项目的源代码时，可能会遇到类似 You may need an additional loader to handle the result\nof these loaders. 的报错。\n\n这个问题有以下解决方法：\n\n 1. 你可以开启源码构建模式来编译 monorepo 中的其他子项目，参考「源码构建模式」。\n 2. 你可以添加 source.include 配置项，指定需要额外进行编译的目录或模块，参考 source.include 用法介绍。\n 3. 你可以预先构建需要引用的子项目，生成对应的构建产物，并在当前项目引用构建产物，而不是引用源代码。\n\n--------------------------------------------------------------------------------\n\n\n打开页面后报错，提示 exports is not defined？#\n\n如果编译正常，但是打开页面后出现 exports is not defined 报错，通常是因为在项目中使用 Babel 编译了一个 CommonJS\n模块，导致 Babel 出现异常。\n\n在正常情况下，Modern.js 是不会使用 Babel 来编译 CommonJS 模块的。如果项目中使用了 source.include\n配置项，则可能会把一些 CommonJS 模块加入到 Babel 编译中。\n\n该问题有两种解决方法：\n\n 1. 避免将 CommonJS 模块加入到 Babel 编译中。\n 2. 将 Babel 的 sourceType 配置项设置为 unambiguous，示例如下：\n\n\n\n将 sourceType 设置为 unambiguous 可能会产生一些其他影响，请参考 Babel 官方文档。\n\n--------------------------------------------------------------------------------\n\n\n编译时报错 \"Error: ES Modules may not assign module.exports or exports.*, Use ESM\nexport syntax\"？#\n\n如果编译时出现以下报错，通常也是因为在项目中使用 Babel 编译了一个 CommonJS 模块，解决方法与上述的 exports is not defined\n问题一致。\n\n\n\n更多信息请参考 issue：babel#12731。\n\n--------------------------------------------------------------------------------\n\n\n编译进度条卡死，但终端无 Error 日志？#\n\n当编译进度条卡死，但终端无 Error 日志时，通常是因为编译过程中出现了异常。在某些情况下，当 Error 被 webpack\n或其他模块捕获后，错误日志不会被正确输出。最为常见的场景是 Babel 配置出现异常，抛出 Error 后被 webpack 捕获，而 webpack\n在个别情况下吞掉了 Error。\n\n解决方法：\n\n如果你修改 Babel 配置后出现此问题，建议检查是否有以下错误用法：\n\n 1. 配置了一个不存在的 plugin 或 preset，可能是名称拼写错误，或是未正确安装。\n\n\n\n 2. 是否配置了多个 babel-plugin-import，但是没有在数组的第三项声明每一个 babel-plugin-import 的名称。\n\n\n\n\n\n除了上述原因外，还有一种可能会导致 Babel 编译卡死，就是使用 Babel 编译了一个超过 1 万行的大型 JS 文件（通常是使用\nsource.include 编译了 node_modules 中的某个大文件）。\n\n当 Babel 编译大文件时，Modern.js 内置的 babel-plugin-styled-components 会卡死，社区中已有 相关 issue。\n\n未来 Modern.js 会考虑移除内置的 babel-plugin-styled-components。在当前版本里，你可以将\ntools.styledComponents 设置为 false 来移除该插件。\n\n\n\n--------------------------------------------------------------------------------\n\n\nwebpack 编译缓存未生效，应该如何排查？#\n\nModern.js 默认开启了 webpack 的持久化缓存。\n\n首次编译完成后，会自动生成缓存文件，并输出到 ./node_modules/.cache/webpack\n目录下。执行第二次编译时，会命中缓存，并大幅度提高编译速度。\n\n当 package.json 等配置文件被修改时，缓存会自动失效。\n\n如果项目中 webpack 编译缓存一直未生效，可以添加以下配置进行排查：\n\n\n\n添加以上配置后，webpack 会输出日志用于 debug，请参考 PackFileCacheStrategy 相关的日志来了解缓存失效的原因。\n\n--------------------------------------------------------------------------------\n\n\n从 lodash 中引用类型后出现编译报错？#\n\n当你的项目中安装了 @types/lodash 包时，你可能会从 lodash 中引用一些类型，比如引用 DebouncedFunc 类型：\n\n\n\n上述代码会在编译后产生如下报错：\n\n\n\n这个问题的原因是 Modern.js 默认开启了 babel-plugin-lodash 插件来优化 lodash 产物体积，但 Babel\n无法区别「值」和「类型」，导致编译后的代码出现异常。\n\n解决方法是使用 TypeScript 的 import type 语法，对 DebouncedFunc 类型进行显式声明：\n\n\n\nTIP\n\n在任意情况下，我们都推荐使用 import type 来引用类型，这对于编译器识别类型会有很大帮助。\n\n--------------------------------------------------------------------------------\n\n\n升级 Modern.js 版本后，检查出新的 TypeScript 类型错误？#\n\n从 2.47.0 版本开始，Modern.js 优化了 Type Checker 的检查范围。在之前的版本中，Type Checker 只输出 src\n目录的类型错误，导致其他目录的类型错误无法被正确输出。\n\n在新版本中，Modern.js 的 Type Checker 对齐了原生 tsc 的类型检查范围（即 tsconfig.json 的 include 和\nexclude 字段定义的范围），能够完整输出项目中的类型错误。\n\n如果你希望保持之前的行为，只输出 src 目录的类型错误，可以添加以下配置：\n\n","routePath":"/guides/troubleshooting/builder","lang":"zh","toc":[{"text":"Rsbuild FAQ","id":"rsbuild-faq","depth":3,"charIndex":114},{"text":"如何清空 webpack 编译缓存？","id":"如何清空-webpack-编译缓存","depth":3,"charIndex":332},{"text":"如何查看最终生成的 webpack / Rspack 配置?","id":"如何查看最终生成的-webpack--rspack-配置","depth":3,"charIndex":533},{"text":"webpack 编译出现 'compilation' argument 报错？","id":"webpack-编译出现-compilation-argument-报错","depth":3,"charIndex":724},{"text":"在 Monorepo 中引用其他模块，代码没有被正确编译？","id":"在-monorepo-中引用其他模块代码没有被正确编译","depth":3,"charIndex":1512},{"text":"打开页面后报错，提示 exports is not defined？","id":"打开页面后报错提示-exports-is-not-defined","depth":3,"charIndex":1986},{"text":"编译时报错 \"Error: ES Modules may not assign module.exports or exports.*, Use ESM export syntax\"？","id":"编译时报错-error-es-modules-may-not-assign-moduleexports-or-exports-use-esm-export-syntax","depth":3,"charIndex":-1},{"text":"编译进度条卡死，但终端无 Error 日志？","id":"编译进度条卡死但终端无-error-日志","depth":3,"charIndex":2764},{"text":"webpack 编译缓存未生效，应该如何排查？","id":"webpack-编译缓存未生效应该如何排查","depth":3,"charIndex":3507},{"text":"从 lodash 中引用类型后出现编译报错？","id":"从-lodash-中引用类型后出现编译报错","depth":3,"charIndex":3884},{"text":"升级 Modern.js 版本后，检查出新的 TypeScript 类型错误？","id":"升级-modernjs-版本后检查出新的-typescript-类型错误","depth":3,"charIndex":4307}],"domain":"","frontmatter":{"sidebar_position":3},"version":""},{"id":600,"title":"命令行问题","content":"#\n\n\n使用 pnpm 时无法正确传递命令行参数？#\n\npnpm v6 和 pnpm v7 版本在执行命令时使用姿势不完全一致，需要注意以下事项：\n\npnpm v7：\n\n在使用 pnpm 调用 package.json 中的命令时，如果需要传递参数至 pnpm，需要将参数放到命令前。\n\n例如使用 pnpm --filter 参数执行 prepare 命令：\n\n\n\n如果需要传递参数至命令，需要将参数放到命令后。\n\n例如，在如下 package.json 配置中：\n\n\n\n执行 command 命令时携带参数方式为：\n\n\n\npnpm v6:\n\n在如下 package.json 配置中：\n\n\n\n当需要执行 modern command --option：\n\n使用 pnpm 时，需要执行 pnpm run command -- --option。\n\n这是因为 pnpm 对于命令参数的处理与 Yarn 并不相同，但是与 npm 类似：在不加 -- 字符串的时候，传递的是 pnpm 的参数；在使用 --\n字符串的时候，传递的是执行脚本的参数。\n\n在上述例子里参数 --option 传递给了 modern command。如果执行 pnpm run command --option，则参数\n--option 将传递给 pnpm。\n\n总结来说：\n\n在使用 pnpm v7 时，如果传递参数给 pnpm，需要将参数放置到命令前。\n\n在使用 pnpm v6 时，如果传递的参数给 pnpm，不需要加 --；如果传递的参数是给脚本使用，需要增加 -- 字符串。","routePath":"/guides/troubleshooting/cli","lang":"zh","toc":[{"text":"使用 pnpm 时无法正确传递命令行参数？","id":"使用-pnpm-时无法正确传递命令行参数","depth":3,"charIndex":3}],"domain":"","frontmatter":{"sidebar_position":2},"version":""},{"id":601,"title":"依赖安装问题","content":"#\n\n\n如何查看项目里某个依赖实际安装的版本？#\n\n可以使用包管理器自带的 ls 命令来查看项目里依赖的版本。\n\n下面是一些基本的示例，详细用法请查看各个包管理器的文档。\n\nnpm / yarn\n\n对于使用 npm 或 yarn 的项目，可以使用 npm ls 命令。\n\n比如执行 npm ls @modern-js/core，可以看到如下结果：\n\n\n\npnpm\n\n对于使用 pnpm 的项目，可以使用 pnpm ls 命令。\n\n比如执行 pnpm ls @modern-js/core --depth Infinity，可以看到如下结果：\n\n\n\n--------------------------------------------------------------------------------\n\n\n安装依赖时提示 The engine \"node\" is incompatible？#\n\n安装依赖时如果出现以下报错提示，说明当前环境使用的 Node.js 版本过低，需要升级 Node.js 到更高版本。\n\n\n\n使用 Modern.js 时，建议使用 Node.js 18.x 的最新版本。\n\n如果当前环境的 Node.js 版本低于上述要求的版本，则可以使用 nvm 或 fnm 等工具进行版本切换。\n\n下面是使用 nvm 的示例：\n\n\n\n在本地开发环境推荐使用 fnm，它的用法与 nvm 相似，但拥有比 nvm 更好的性能。\n\n--------------------------------------------------------------------------------\n\n\n升级依赖后出现 ReactNode 类型错误？#\n\n升级项目的依赖后，如果出现以下类型报错，说明项目中安装了错误的 @types/react 版本。\n\n\n\n出现这个问题的原因是 React 18 与 React 16/17 中的 ReactNode 类型定义不同，如果项目中出现多个不同 @types/react\n版本，就会出现 ReactNode 类型冲突，导致以上报错。\n\n解决方法为将项目中的 @types/react 和 @types/react-dom 锁定在统一的版本上，比如 v17。\n\n\n\n关于锁定依赖版本的方法，请参考 锁定子依赖。\n\n--------------------------------------------------------------------------------\n\n\n执行 pnpm install 之后，控制台出现 peer dependencies 相关 warning？#\n\n出现该警告的原因是，某些三方 npm 包声明的 peer dependencies 版本范围与 Modern.js 中安装的版本范围不一致。\n\n绝大多数情况下，peer dependencies 的警告不会影响项目运行，不需要额外进行处理，请忽略相关 warning。\n\n--------------------------------------------------------------------------------\n\n\nModern.js 框架最低支持的 React 版本是多少？#\n\nModern.js 框架推荐使用的 React 版本为 >= 18.0.0，并且不同功能对 React 版本的要求有所不同。\n\n * 如果你在使用 React 17，那么部分框架功能将无法使用，比如 Streaming SSR，因为它依赖 React 18 提供的新特性。\n * 如果你仍然在使用 React 16，那么将无法使用 Modern.js 的运行时或服务端能力。你可以考虑使用 Modern.js 的构建模式，即只使用\n   Modern.js 的构建能力，这种情况可以继续使用 React 16。\n\n在 Modern.js 未来的 major 版本中，我们会逐步移除对 React 16 和 React 17 的支持。因此，请尽快升级到 React 18\n以上版本。\n\n--------------------------------------------------------------------------------\n\n\nModern.js 配置出现类型错误？#\n\n\n\n当你在使用 Modern.js 框架时配置文件出现以上报错，可能是由于 Modern.js 相关包的版本号未统一导致。可以通过 npx modern\nupgrade 命令对 modern.js 依赖进行升级和版本统一。\n\n在 monorepo 中由于不同子项目所用的 Modern.js 框架版本不一致也可能出现以上问题。","routePath":"/guides/troubleshooting/dependencies","lang":"zh","toc":[{"text":"如何查看项目里某个依赖实际安装的版本？","id":"如何查看项目里某个依赖实际安装的版本","depth":3,"charIndex":3},{"text":"安装依赖时提示 The engine \"node\" is incompatible？","id":"安装依赖时提示-the-engine-node-is-incompatible","depth":3,"charIndex":356},{"text":"升级依赖后出现 ReactNode 类型错误？","id":"升级依赖后出现-reactnode-类型错误","depth":3,"charIndex":707},{"text":"执行 pnpm install 之后，控制台出现 peer dependencies 相关 warning？","id":"执行-pnpm-install-之后控制台出现-peer-dependencies-相关-warning","depth":3,"charIndex":1067},{"text":"Modern.js 框架最低支持的 React 版本是多少？","id":"modernjs-框架最低支持的-react-版本是多少","depth":3,"charIndex":1343},{"text":"Modern.js 配置出现类型错误？","id":"modernjs-配置出现类型错误","depth":3,"charIndex":1801}],"domain":"","frontmatter":{"sidebar_position":1},"version":""},{"id":602,"title":"热更新问题","content":"#\n\n\n热更新不生效，如何排查？#\n\n热更新不生效有很多种可能的原因，在这篇文档中会介绍大部分常见的原因，你可以参照以下内容进行排查。\n\n在开始排查之前，请简单了解一下热更新的原理：\n\n热更新原理\n 1. 浏览器和开发服务器建立一个 Web Socket 连接，用于实时通信。\n 2. 当开发服务器每次重新编译完成后，会通过 Web Socket 通知浏览器，浏览器向开发服务器发送 hot-update.xxx\n    请求，从而加载编译后的新模块。\n 3. 当浏览器收到新的模块后，如果是 React 项目，则会通过 React 官方的 React Refresh 来更新 React 组件，其他框架也是类似。\n\n了解完热更新的原理后，你可以按照以下步骤来进行基本的排查：\n\n1. 检查 Web Socket 连接#\n\n打开浏览器的控制台，查看是否有 [HMR] connected. 日志。\n\n * 如果有，说明 Web Socket 连接正常，请继续检查后续步骤。\n * 如果没有，请打开 Chrome 的 Network 面板，查看 ws://[host]:[port]/webpack-hmr\n   的请求状态，若请求异常，说明热更新失败的原因是 Web Socket 请求没有建立成功。\n\nWeb Socket 请求没有建立成功的原因可能有很多种，例如开启了网络代理，导致 Web Socket 请求没有正确发送到开发服务器。你可以检查 Web\nSocket 请求的地址是否为你的开发服务器地址，如果不是，则可以通过 tools.devServer.client 来配置 Web Socket 请求的地址。\n\n2. 检查 hot-update 请求#\n\n当你修改一个模块的代码，并触发重新编译后，浏览器会向开发服务器发送若干个 hot-update.json 和 hot-update.js\n请求，用于获取更新后的代码。\n\n你可以尝试修改一个模块并检查 hot-update.xxx 请求的内容，如果请求的内容是最新的代码，说明热更新的请求正常。\n\n如果请求的内容错误，大概率也是由于开启了网络代理，请检查 hot-update.xxx 请求的地址是否为你的开发服务器地址，如果不是，则需要调整代理规则，将\nhot-update.xxx 请求代理到开发服务器地址。\n\n3. 检查其他原因#\n\n如果以上两个步骤都没有问题，那么可能是其他原因导致的热更新失败，比如没有符合 React 对热更新的要求，你可以参考下列的问题进行排查。\n\n--------------------------------------------------------------------------------\n\n\n打包时 external React 后，热更新不生效？#\n\n为了保证热更新生效，我们需要使用 React 和 ReactDOM 的开发环境产物。\n\n当你将 React 通过 externals 排除后，通常会通过 CDN 等方式注入 React 的生产环境产物，所以热更新会不生效。\n\n\n\n为了解决该问题，你需要引用 React 的开发环境产物，或者在开发环境下不配置 externals。\n\n如果你不确定当前使用的 React 产物类型，可以参考：React 官方文档 - Use the Production Build\n\n--------------------------------------------------------------------------------\n\n\n开发环境设置文件名的 hash 后，热更新不生效？#\n\n通常来说，我们只会在生产环境下设置文件名的 hash 值（即 process.env.NODE_ENV === 'production' 时）。\n\n如果你在开发环境下设置了文件名的 hash，那么可能会导致热更新不生效（尤其是 CSS 文件）。这是因为每次文件内容变化时，都会引起 hash 变化，导致\nmini-css-extract-plugin 等工具无法读取到最新的文件内容。\n\n * 正确用法：\n\n\n\n * 错误用法：\n\n\n\n--------------------------------------------------------------------------------\n\n\nReact 组件的热更新无法生效？#\n\nModern.js 使用 React 官方的 Fast Refresh 能力来进行组件热更新。\n\n如果出现 React 组件的热更新无法生效的问题，或者是热更新后 React 组件的 state 丢失，这通常是因为你的 React 组件使用了匿名函数。在\nReact Fast Refresh 的官方实践中，要求组件不能为匿名函数，否则热更新后无法保留 React 组件的 state。\n\n以下是一些错误用法的例子：\n\n\n\n正确用法是给每个组件函数声明一个名称：\n\n\n\n--------------------------------------------------------------------------------\n\n\n开启 https 后，热更新不生效？#\n\n当开启 https 时，由于证书的问题，可能会出现 HMR 连接失败的情况，此时打开控制台，会出现 HMR connect failed 的报错。\n\n\n\n此问题的解决方法为：点击 Chrome 浏览器问题页面的「高级」->「继续前往 xxx（不安全）」。\n\n\n\n> Tips: 当通过 Localhost 访问页面时，「您的连接不是私密连接」字样可能不会出现，可访问 Network 域名进行处理。","routePath":"/guides/troubleshooting/hmr","lang":"zh","toc":[{"text":"热更新不生效，如何排查？","id":"热更新不生效如何排查","depth":3,"charIndex":3},{"text":"1. 检查 Web Socket 连接","id":"1-检查-web-socket-连接","depth":4,"charIndex":339},{"text":"2. 检查 hot-update 请求","id":"2-检查-hot-update-请求","depth":4,"charIndex":711},{"text":"3. 检查其他原因","id":"3-检查其他原因","depth":4,"charIndex":990},{"text":"打包时 external React 后，热更新不生效？","id":"打包时-external-react-后热更新不生效","depth":3,"charIndex":1155},{"text":"开发环境设置文件名的 hash 后，热更新不生效？","id":"开发环境设置文件名的-hash-后热更新不生效","depth":3,"charIndex":1503},{"text":"React 组件的热更新无法生效？","id":"react-组件的热更新无法生效","depth":3,"charIndex":1832},{"text":"开启 https 后，热更新不生效？","id":"开启-https-后热更新不生效","depth":3,"charIndex":2170}],"domain":"","frontmatter":{"sidebar_position":4},"version":""},{"id":604,"title":"路由鉴权","content":"#\n\nModern.js 默认提供的路由方式是基于 React Router 6 的约定式路由，具体可查看路由方案。\n\n在一个 Web 应用中如果存在多个路由，我们可能需要对部分路由进行鉴权后才能访问。例如下面这个案例：\n\n * 访问 / 路由，无需鉴权，可直接访问。\n\n * 访问 /protected 路由，需要鉴权，如果无，自动跳转到 /login 路由，登录成功后返回 /protected。","routePath":"/tutorials/examples/csr-auth","lang":"zh","toc":[],"domain":"","frontmatter":{"title":"路由鉴权"},"version":""},{"id":605,"title":"创建项目","content":"#\n\n从这一章节开始，我们将进入实战教程部分。在实战教程中，我们将会从环境准备开始，从简单到复杂，一步一步搭建一个真实的项目。\n\n\n环境准备#\n\n\nNode.js#\n\n在开始使用前，你需要安装 Node.js，并保证 Node.js 版本不低于 16.2.0，我们推荐使用 Node.js 18 的 LTS 版本。\n\n你可以通过以下命令检查当前使用的 Node.js 版本：\n\n\n\n如果你当前的环境中尚未安装 Node.js，或是安装的版本低于 16，可以通过 nvm 或 fnm 安装需要的版本。\n\n下面是通过 nvm 安装 Node.js 18 LTS 版本的例子：\n\n\n\nnvm 和 fnm\n\nnvm 和 fnm 都是 Node.js 版本管理工具。相对来说，nvm 较为成熟和稳定，而 fnm 是使用 Rust 实现的，比 nvm 提供了更好的性能。\n\n此外，在安装 nvm 或 fnm 后，然后只要仓库根目录下有内容为 lts/hydrogen 的 .nvmrc 文件，进入这个仓库时就会自动安装或切换到正确的\nNode.js 版本。\n\n\npnpm#\n\n推荐使用 pnpm 来管理依赖：\n\n\n\nNOTE\n\nModern.js 同样支持使用 yarn、npm 进行依赖管理。\n\n\n初始化项目#\n\n我们创建新的目录，通过命令行工具初始化项目：\n\n\n\n@modern-js/create 会提供一个可交互的问答界面，根据结果初始化项目，按照默认的选择进行初始化：\n\n\n\n在生成项目后，Modern.js 会自动安装依赖、创建 git 仓库。\n\n\n\n现在，项目结构如下：\n\n\n\n\n调试项目#\n\n在项目中执行 pnpm run dev 即可启动项目：\n\n\n\n在浏览器中打开 http://localhost:8000/，可以看到页面内容。\n\n\n修改代码#\n\n我们将原本的示例代码删除，替换成一个简单的联系人列表：\n\n\n\n删除多余的 css 文件，保持目录没有多余的文件：\n\n\n\n因为框架默认支持 HMR，可以看到 http://localhost:8080/ 里的内容会自动更新为：\n\n\n\n此刻的页面还没有样式。下一章节将展开这部分的内容。\n\n\n开启 SSR#\n\n接下来，我们修改项目中的 modern.config.ts，开启 SSR 能力：\n\n\n\n重新执行 pnpm run dev，可以发现项目已经在服务端完成了页面渲染。","routePath":"/tutorials/first-app/c01-start","lang":"zh","toc":[{"text":"环境准备","id":"环境准备","depth":2,"charIndex":65},{"text":"Node.js","id":"nodejs","depth":3,"charIndex":73},{"text":"pnpm","id":"pnpm","depth":3,"charIndex":474},{"text":"初始化项目","id":"初始化项目","depth":2,"charIndex":543},{"text":"调试项目","id":"调试项目","depth":2,"charIndex":690},{"text":"修改代码","id":"修改代码","depth":2,"charIndex":771},{"text":"开启 SSR","id":"开启-ssr","depth":2,"charIndex":922}],"domain":"","frontmatter":{"title":"创建项目"},"version":""},{"id":606,"title":"编写 UI 组件","content":"#\n\n上一章节中，我们学习了如何初始化项目，并使用配置修改 Modern.js 的默认行为。\n\n这一章节中，我们继续沿用上一章节的项目代码，继续完善联系人列表。\n\n为了做更好的 UI 展示和交互，我们引入组件库 Antd 来开发，使用 组件来代替原始的列表。先添加依赖：\n\n修改 src/routes/page.tsx，在顶部导入组件：\n\n\n\n修改 组件的实现：\n\n\n\n执行 pnpm run dev，查看运行结果：\n\n\n\n可以看到 Ant Design 导出的组件，已经具备了完整的样式。\n\nINFO\n\nModern.js 会自动按需导入 Ant Design 组件需要的 CSS。\n\nNOTE\n\n我们也可以使用其他组件库来实现同样的功能，例如 Arco Design。","routePath":"/tutorials/first-app/c02-component","lang":"zh","toc":[],"domain":"","frontmatter":{"title":"编写 UI 组件"},"version":""},{"id":607,"title":"添加样式","content":"#\n\n上一章节中，我们学习了如何使用使用三方库中的组件。\n\n这一章节中，我们将学习如何实现 UI 组件。\n\n\n使用 CSS 写 JS 组件#\n\n首先我们希望自己控制联系人头像的展示，实现这种设计稿：\n\n\n\n假设没有现成的组件可以实现，那就需要自己写些 CSS 了，这里我们使用 styled-components，来实现类似的需求。Modern.js 开箱即用的支持\nstyled-components，既不需要安装依赖，也不需要做任何配置。\n\nstyled-components 通过模块化的方式，避免了传统 CSS 写法上的诸多问题。例如直接在元素的 style 属性上写样式，UI 视觉上的细节也会跟\nUI 结构上的细节和业务逻辑混在一起。或是 classname 需要避免全局空间重名，需要用到命名规范的问题。\n\n在 src/routes/page.tsx 里修改顶部的代码：\n\n\n\n添加以下代码：\n\n\n\n修改 List.Item.Meta 的代码：\n\n\n\n执行 pnpm run dev，可以看到预期的运行结果：\n\n\n\n接下来我们做一点重构，为了增强可读性，让代码更容易维护，可以把 Avatar 组件拆分出去。我们在终端执行以下命令，创建新的文件：\n\n把 src/routes/page.tsx 里的 实现删掉，修改为：\n\n\n\nsrc/components/Avatar/index.tsx 的内容，修改为：\n\n\n\n执行 pnpm run dev，运行结果应该是一样的。\n\nINFO\n\n采用目录形式 Avatar/index.tsx 而不是单文件形式 Avatar.tsx\n的原因是，之后可以方便的在目录内部增加子文件，包括专用的资源（图片等）、专用子组件、CSS 文件等。\n\n\n使用 Utility#\n\n我们已经使用 style-components 实现 组件，但当前的 UI 仍然不能让人满意，缺乏专业感，例如列表项内部的布局有点粗糙，很多地方没对齐。\n\n现在，我们自己来实现一个更好的 Item 组件，实现这样的设计稿：\n\n\n\n这次要实现的 UI 更复杂，有内部结构，但另一方面，并没有 组件的很粗的亮蓝色边框这样很特殊的\nUI，都是很常规的水平垂直布局、居中、字体样式等。这种情况下，其实根本没必要写 CSS，有更高效的、跟 styled-components\n互补的实现方式：Utility Class。\n\nModern.js 集成了主流、轻量、通用的 Utility Class 工具库 Tailwind CSS。\n\n执行 pnpm run new，进行如下选择，开启 Tailwind CSS：\n\n\n\n在 modern.config.ts 中注册 Tailwind 插件:\n\n\n\n在 src/routes/page.tsx 顶部引入 Tailwind CSS 的 css 文件，就可以开始快速实现专业的 UI：\n\n\n\n先创建 Item 组件：\n\n修改 src/routes/page.tsx，把 List 的 render 实现交给 Item 组件：\n\n\n\n在父容器的上使用了 Utility Class ，快速实现了最基本的最大宽度、居中等样式。\n\n接下来实现 src/components/Item/index.tsx：\n\n\n\n执行 pnpm run dev，可以看到预期的运行结果：\n\n\n\n我们只使用了少量 Utility Class，比如 Flex、Padding、Margin、Text、Font、Border，不写一行 CSS\n就实现了符合设计稿的专业 UI。\n\n\n自定义 Utility Class#\n\n我们也可以自己实现新的 Utility Class，方便在代码间复用。\n\nUtility Class 本身也是一种面向组件的技术（将不同 class 用在一个组件上，等价于给这个组件设置了一些来自基类的属性），但 Utility\nClass 的 classname 是全局的（因为要用在任意组件/元素上），很适合用独立 CSS 文件来实现。\n\n创建一个新的 CSS 文件：\n\n在 src/routes/page.tsx 里导入 utils.css：\n\n\n\n在 src/routes/styles/utils.css 里实现一个名为 custom-text-gray 的 Utility Class。\n\n\n\nINFO\n\nModern.js 集成了 PostCSS，支持现代 CSS 语法特性，比如 custom properties。\n\n在 src/routes/components/Item/index.tsx 里使用，把：\n\n\n\n改成：\n\n\n\n执行 pnpm run dev，可以看到字体颜色改变了：\n\n\n\nINFO\n\n此处只是为了演示 Utility Class 用法。真实项目中，在有 Tailwind CSS 的情况下，这种 Utility Class\n没什么价值，应该通过配置 Design System 的 theme 来增加字体颜色。\n\nutils.css 也可以写成 utils.scss 或 utils.less，Modern.js 对 SCSS 和 Less 同样提供开箱即用的支持。\n\n不过在 PostCSS 的支持下，现代 CSS 应该足以满足这些开发需求，性能相较于预处理器也更好，建议优先用 .css 文件。","routePath":"/tutorials/first-app/c03-css","lang":"zh","toc":[{"text":"使用 CSS 写 JS 组件","id":"使用-css-写-js-组件","depth":2,"charIndex":54},{"text":"使用 Utility","id":"使用-utility","depth":2,"charIndex":745},{"text":"自定义 Utility Class","id":"自定义-utility-class","depth":2,"charIndex":1502}],"domain":"","frontmatter":{"title":"添加样式"},"version":""},{"id":608,"title":"添加客户端路由","content":"#\n\n上一章节中，我们学习了如何为创建 UI 组件，并添加样式。\n\n这一章节中，我们将会学习如何添加客户端路由。\n\n之前我们已经为联系人列表增加了 Archive 按钮，接下来我们添加一个客户端路由 /archives，访问这个路由时，只显示已存档的联系人，而原有的 /\n继续显示所有联系人。\n\n新建 src/routes/archives/page.tsx 文件：\n\n添加如下代码：\n\n\n\n这里使用了 React Helmet 的 Helmet 组件，在 src/routes/page.tsx 中也添加 Helmet 组件：\n\n\n\nINFO\n\nModern.js 默认集成了 react-helmet，也可以结合 SSR 使用，满足 SEO 需求。\n\n因为现在有多个页面，都需要用到前面的 Utility Class，因此我们需要把样式文件移动到 src/routes/layout.tsx：\n\n\n\n执行 pnpm run dev，访问 http://localhost:8080，可以看到完整的联系人，页面的标题是 All：\n\n\n\n访问 http://localhost:8080/archives，只会看到已存档的联系人，页面的标题是 Archives：\n\n\n\n查看页面 HTML 源码，可以看到两个页面的内容是一样，是在客户端针对不同 URL 渲染不同内容。\n\n接下来我们增加一个简单的导航栏，让用户能在两个列表之间切换。\n\n打开 src/routes/layout.tsx，在顶部导入 Radio 组件：\n\n\n\n然后将 UI 最顶部进行修改，增加一组单选框\n\n\n\n然后我们来实现 currentList 和 handleSetList。\n\n引入三个 React Hook：useState 和 useNavigate 和 useParams，以及 Ant Design 的事件类型定义：\n\n\n\n最后在 Layout 组件里增加局部状态和相关逻辑：\n\n\n\n到这里就已经完成了页面导航栏实现，执行 pnpm run dev 查看效果：\n\n\n\n点击导航栏中 Archives，可以看到单选框的选中状态和 URL 都会变化，页面没有刷新，只发生了 CSR。\n\n通过 URL 访问两个页面，可以看到 HTML 内容是不同的，这是因为在 SSR 阶段页面就执行了客户端路由的逻辑，HTML 里已经包含了最终的渲染结果。","routePath":"/tutorials/first-app/c04-routes","lang":"zh","toc":[],"domain":"","frontmatter":{"title":"添加客户端路由"},"version":""},{"id":609,"title":"添加 Loader","content":"#\n\n上一章节中，我们学习了如何添加客户端路由。\n\n这一章节中，我们将会学习如何为路由组件添加 Loader。\n\n到目前为止，我们都是通过硬编码的方式，为组件提供数据。如果要从远端获取数据，通常情况下会使用 useEffect 来做。但在启用 SSR\n的情况下，useEffect 是不会在服务端执行的，所以这种 SSR 只能渲染很有限的 UI。\n\nModern.js 为提供了 Data Loader 的能力，支持同构的在组件中获取数据，让 SSR 的价值最大化。\n\n下面我们演示如何为路由组件添加 Data Loader，并模拟远端数据获取。我们使用 faker 来 mock 需要的数据，首先安装依赖：\n\n\n\n创建 src/routes/page.data.ts：\n\n\n\nNOTE\n\nData Loader 并非只为 SSR 工作。在 CSR 项目中，Data Loader 也可以避免数据获取依赖 UI\n渲染，解决请求瀑布流的问题。未来，Modern.js 也会为这一特性添加更多能力，例如预获取、数据缓存等。\n\nModern.js 也提供了一个叫 useLoaderData 的 hooks API，我们修改 src/routes/page.tsx 导出的组件：\n\n\n\n重新执行 pnpm run dev，查看 view-source:http://localhost:8080/，或在 devtools 的 Network\n面板里查看 HTML 请求的「 Preview 」，可以看到 SSR 渲染出来的 HTML 已经包含完整的 UI：\n\n","routePath":"/tutorials/first-app/c05-loader","lang":"zh","toc":[],"domain":"","frontmatter":{"title":"添加 Loader"},"version":""},{"id":610,"title":"添加状态管理","content":"#\n\n上一章节中，我们把硬编码的 mockData 改成从 Data Loader 中加载。\n\n这一章节中，我们会进一步实现项目的功能，例如实现 Archive 按钮的功能，把联系人归档。\n\n因此会开始编写一些跟 UI 完全无关的业务逻辑，如果继续写在组件代码中，会产生越来越多的面条式代码。为此，我们引入了一种叫做 业务模型（Model）\n的代码模块，将这些业务逻辑和 UI 解耦。\n\n注意\n\n使用状态管理相关 API，需要先启用配置项 runtime.state：\n\n\n\n\n实现 Model#\n\n创建一个完整的 Model 首先需要定义状态（state），包括状态中数据的名称和初始值。\n\n我们使用 Model 来管理联系人列表的数据，因此定义如下数据状态：\n\n\n\n使用 TS 语法，可以定义更完整的类型信息，比如 items 里每个对象都应该有 name、email 字段。为了实现归档功能，还需要创建 archived\n字段保存这个联系人是否已被归档的状态。\n\n我们还需要一个字段用来访问所有已归档的联系人，可以定义 computed 类型的字段，对已有的数据做转换：\n\n\n\ncomputed 类型字段的定义方式是函数，但使用时可以像普通字段一样通过 state 访问。\n\nINFO\n\nModern.js 集成了 Immer，能够像操作 JS 中常规的可变数据一样，去写这种状态转移的逻辑。\n\n实现 Archive 按钮时，我们需要一个 archive 函数，负责修改指定联系人的 archived 字段，我们把这种函数都叫作 action：\n\n\n\naction 函数是一种纯函数，确定的输入得到确定的输出（转移后的状态），不应该有任何副作用。\n\n函数的第一个参数是 Immer 提供的 Draft State，第二个参数是 action 被调用时传入的参数（后面会介绍怎么调用）。\n\n我们尝试完整实现它们：\n\n\n\n接下来我们把上面的代码连起来，放在同一个 Model 文件里。首先执行以下命令，创建新的文件目录：\n\n\n\n添加 src/models/contacts.ts 的内容：\n\n\n\n我们把一个包含 state，action 等要素的 plain object 称作 Model Spec，Modern.js 提供了 Model\nAPI，可以根据 Model Spec 生成 Model。\n\n\n使用 Model#\n\n现在我们直接使用这个 Model，把项目的逻辑补充起来。\n\n首先修改 src/components/Item/index.tsx，添加 Archive 按钮的 UI 和交互，内容如下：\n\n\n\n接下来，我们修改 src/routes/page.tsx 和 src/routes/page.data.ts，为 组件传递更多参数：\n\n\n\n\n\nuseModel 是 Modern.js 提供的 hooks API。可以在组件中提供 Model 中定义的 state，或通过 actions 调用\nModel 中定义的 side effect 与 action，从而改变 Model 的 state。\n\nModel 是业务逻辑，是计算过程，本身不创建也不持有状态。只有在被组件用 hooks API 使用后，才在指定的地方创建状态。\n\n执行 pnpm run dev，点击 Archive 按钮，可以看到页面 UI 发生了变化。\n\nNOTE\n\n上述例子中，useLoaderData 其实在每次切换路由时都会执行。因为我们在 Data Loader 里使用了 fake\n数据，每次返回的数据是不同的。但我们优先使用了 Model 中的数据，因此切换路由时数据没有发生改变。","routePath":"/tutorials/first-app/c06-model","lang":"zh","toc":[{"text":"实现 Model","id":"实现-model","depth":2,"charIndex":238},{"text":"使用 Model","id":"使用-model","depth":2,"charIndex":1003}],"domain":"","frontmatter":{},"version":""},{"id":611,"title":"添加容器组件","content":"#\n\n上一章节中，我们初步引入业务模型，从 UI 组件中拆分出这部分逻辑。page.tsx 中不再包含 UI 无关的业务逻辑实现细节，只需要使用\nModel，就能实现同样的功能。\n\n这一章节中，我们要进一步利用 Model 中实现的业务逻辑，让 page.tsx 和 archived/page.tsx 获取同一份数据。并实现 Archive\n按钮，点击按钮能把联系人归档，只显示在 Archives 列表里，不显示在 All 列表里。\n\n\n使用完整 Model#\n\n因为两个页面需要共用同一套状态（联系人列表数据、联系人是否被归档），都需要包含加载初始数据的逻辑，因此我们需要在更上一层完成数据获取。\n\nModern.js 支持在 layout.tsx 通过 Data Loader 获取数据，我们先数据获取这部分代码移动到\nsrc/routes/layout.tsx 中：\n\n\n\n\n\n在 src/routes/page.tsx 中，直接使用 Model，获取数据：\n\n\n\n同样在 archived/page.tsx 中，删除原本的 mockData 逻辑，使用 Model 中 computed 的 archived 值作为数据源：\n\n\n\n执行 pnpm run dev，访问 http://localhost:8080/，点击 Archive 按钮后，可以看到按钮置灰：\n\n\n\n接下来点击顶部导航，切换到 Archives 列表，可以发现刚才 Archive 的联系人已经出现在列表当中：\n\n\n\n\n抽离容器组件#\n\n前面章节中，我们把项目中的业务逻辑拆分成了两个 layer，一个是视图组件，另一个是业务模块。前者负责 UI 展示、交互等，后者负责实现 UI\n无关的业务逻辑，专门管理状态。\n\n像 src/routes/page.tsx 和 src/routes/archives/page.tsx 这样使用了 useModel API 的组件，负责把\nView 和 Model 这两个 layer 连接起来，类似传统 MVC 架构中 Controller 的角色，在 Modern.js\n里我们沿用习惯，把它们称作容器组件（Container）。\n\n容器组件推荐放在专门的 containers/ 目录里，我们执行以下命令，创建新的文件：\n\n我们将原本两个 page.tsx 中公共的部分抽离出来，src/containers/Contacts.tsx 的代码如下：\n\n\n\n修改 src/routes/page.tsx 和 src/routes/archives/page.tsx 的代码：\n\n\n\n\n\n重构完成，现在的项目结构是：\n\n\n\ncomponents/ 里的视图组件，都是目录形式，如 Avatar/index.tsx。而 containers/ 里的容器组件，都是单文件形式，如\ncontacts.tsx。这是我们推荐的一种最佳实践。\n\n在 添加 UI 组件（Component） 章节提到过，视图组件用目录形式，是因为视图组件负责实现 UI\n展示和交互细节，可以演变的复杂。用目录形式，可以方便增加子文件，包括专用的资源（图片等）、专用子组件、CSS\n文件等。在这个目录内部可以随意重构，只考虑最小局部。\n\n而容器组件只负责连接，是一个胶水层，复杂的业务逻辑和实现细节都交给 View 层和 Model\n层去实现。容器组件自己应该保持简单清晰，不应该包含复杂实现细节，所以不应该有内部结构。采用单文件形式不但更简洁，也能起到约束作用，提醒开发者不要把容器组件写复杂\n。","routePath":"/tutorials/first-app/c07-container","lang":"zh","toc":[{"text":"使用完整 Model","id":"使用完整-model","depth":2,"charIndex":220},{"text":"抽离容器组件","id":"抽离容器组件","depth":2,"charIndex":651}],"domain":"","frontmatter":{"title":"添加容器组件"},"version":""},{"id":612,"title":"添加应用入口","content":"#\n\n上一个章节中，我们基本完成了联系人列表应用的开发，介绍了 Modern.js 中部分功能的用法，以及推荐的最佳实践。\n\n这一章节中，我们将介绍如何为应用添加新的入口。\n\n\n新建入口#\n\n一个完整的项目可能需要多个入口，Modern.js 支持自动创建新入口，前面的章节中提到过，pnpm run new 可以启用可选功能。\n\n我们也可以通过它来创建新的工程元素，在项目根目录下执行 pnpm run new：\n\n\n\n创建完成，项目会变成这样：\n\n\n\n可以看到联系人列表应用的文件，都被自动重构到 src/myapp/ 里。\n\n同时新建了一个 src/landing-page/，里面同样有 routes/*（pnpm run new\n命令只做了这些事，所以你也可以很容易的手动创建新入口或修改入口）\n\n执行 pnpm run dev，显示：\n\n\n\n访问 http://localhost:8080/，可以像之前一样看到应用程序。\n\n访问 http://localhost:8080/landing-page，可以看到刚创建的新入口 landing-page 的页面（Modern.js\n自动生成的默认页面）。\n\nModern.js 框架的设计原则之一是【约定优于配置（Convention over\nConfiguration）】，多数情况下可以按约定直接写代码，不需要做任何配置，这里 src/ 中的目录结构就是一种约定：\n\nsrc/myapp/ 和 src/landing-page/ 被自动识别为两个应用入口：myapp 和 landing-page。\n\n其中 src/myapp/ 的目录名跟项目名（package.json 里的 name）一致，会被认为是项目主入口，项目 URL 的根路径（开发环境里默认是\nhttp://localhost:8080/）会自动指向主入口。\n\n其他入口的 URL，是在根路径后追加入口名，比如 http://localhost:8080/landing-page。\n\n接下来，我们把 src/myapp/ 重命名为 src/contacts/：\n\n\n\n再次执行 pnpm run dev，结果变成：\n\n\n\n现在不再有主入口，联系人列表现在是一个普通入口，需要用 http://localhost:8080/contacts 访问。\n\n\n按入口修改配置#\n\n我们可以在 Modern.js 配置文件里，自己写代码来控制项目的配置。\n\n现在，修改 modern.config.ts，添加内容：\n\n\n\n执行 pnpm run dev，再用浏览器打开 view-source:http://localhost:8080/landing-page，可以看到\nlanding-page 网页内容是通过 js 动态加载的，且此页面的 SSR 功能被关闭。\n\n如果注释掉 ssrByEntries 和它的值，landing-page 的 SSR 功能就恢复开启了。\n\n还有一些时候，需要一些更复杂的逻辑来做设置，比如需要 JS 变量、表达式、导入模块等，例如在只在开发环境里开启 SSR：\n\n\n\n到底为止，我们的联系人列表应用的雏形就基本完成了 👏👏👏。\n\n\n下一步#\n\n接下来你可以通过了解指南、配置 等更多教程，进一步完善你的应用。","routePath":"/tutorials/first-app/c08-entries","lang":"zh","toc":[{"text":"新建入口","id":"新建入口","depth":2,"charIndex":88},{"text":"按入口修改配置","id":"按入口修改配置","depth":2,"charIndex":992},{"text":"下一步","id":"下一步","depth":2,"charIndex":1349}],"domain":"","frontmatter":{"title":"添加应用入口"},"version":""},{"id":613,"title":"介绍","content":"#\n\n欢迎来到 Modern.js 教程！\n\n阅读本栏目后，你将初步理解 Modern.js，并使用 Modern.js 创建第一个应用。\n\n\nModern.js 是什么#\n\n如果你对 Modern.js 还不了解，可以先阅读 Modern.js 介绍。\n\n\n实战教程#\n\n我们准备了一个创建「联系人列表应用」的实战教程，你可以按照教程一步步创建一个应用，并了解到 Modern.js 中的以下实践：\n\n * 创建项目\n * 使用 antd 组件库\n * 集成 Tailwind CSS\n * 客户端路由\n * 数据获取\n * 状态管理\n * 容器组件\n * 新建入口\n * ...\n\n\n案例#\n\n我们提供了一些在开发过程中常用的案例供你参考，可以在这里找到 Modern.js 提供的一些功能组合的使用方式，我们将持续完善这里的案例。\n\n * 路由鉴权\n\n * ...\n\n下面就让我们从 创建项目 开始吧！","routePath":"/tutorials/foundations/introduction","lang":"zh","toc":[{"text":"Modern.js 是什么","id":"modernjs-是什么","depth":2,"charIndex":71},{"text":"实战教程","id":"实战教程","depth":2,"charIndex":129},{"text":"案例","id":"案例","depth":2,"charIndex":293}],"domain":"","frontmatter":{"title":"介绍","sidebar_position":1},"version":""}]