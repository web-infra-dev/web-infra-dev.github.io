(self.webpackChunk_modern_js_main_doc=self.webpackChunk_modern_js_main_doc||[]).push([["92612"],{87888:function(e,n,t){"use strict";t.r(n),t.d(n,{default:function(){return l}});var o,r=t("15169"),i=t("43932"),a=t("9880"),s=t("23169"),u=t("88617");function c(e){var n=Object.assign({h1:"h1",a:"a",p:"p",ul:"ul",li:"li",code:"code",pre:"pre"},(0,s.useMDXComponents)(),e.components);return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsxs)(n.h1,{id:"route-authorization",children:["Route Authorization",(0,a.jsx)(n.a,{className:"header-anchor","aria-hidden":"true",href:"#route-authorization",children:"#"})]}),"\n",(0,a.jsxs)(n.p,{children:["Modern.js defaults to the convention-based routing based on React Router 6. For more details, please refer to ",(0,a.jsx)(n.a,{href:"/guides/basic-features/routes#routing-scheme",children:"Routing"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"In a web application, if there are multiple routes, we may need to authorize access to some of them before accessing them. For example, in the following scenario:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:["Access to the ",(0,a.jsx)(n.code,{children:"/"})," route does not require authorization and can be accessed directly."]}),"\n",(0,a.jsxs)(n.li,{children:["Access to the ",(0,a.jsx)(n.code,{children:"/protected"})," route requires authorization. If there is no authorization, it will automatically redirect to the ",(0,a.jsx)(n.code,{children:"/login"})," route. After successful login, it returns to ",(0,a.jsx)(n.code,{children:"/protected"}),"."]}),"\n"]}),"\n","\n",(0,a.jsxs)(u.default,{template:"web-app",children:[(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",meta:'title="src/routes/page.tsx"',children:'import { Helmet } from \'@modern-js/runtime/head\';\nimport \'./index.css\';\n\nconst PublicPage = (): JSX.Element => (\n  <div className="container-box">\n    <Helmet>\n      <link\n        rel="icon"\n        type="image/x-icon"\n        href="https://lf3-static.bytednsdoc.com/obj/eden-cn/uhbfnupenuhf/favicon.ico"\n      />\n    </Helmet>\n    <h3>Public</h3>\n  </div>\n);\n\nexport default PublicPage;\n\n'})}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-tsx",meta:'title="src/routes/layout.tsx"',children:"import { Link, Outlet } from '@modern-js/runtime/router';\nimport { AuthProvider, AuthStatus } from './Auth';\n\nexport default function Layout() {\n  return (\n    <AuthProvider>\n      <AuthStatus />\n\n      <ul>\n        <li>\n          <Link to=\"/\">Public Page</Link>\n        </li>\n        <li>\n          <Link to=\"/protected\">Protected Page</Link>\n        </li>\n      </ul>\n\n      <Outlet />\n    </AuthProvider>\n  );\n}\n\n"})}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",meta:'title="src/routes/fakeAuth.ts"',children:"/**\n * This represents some generic auth provider API, like Firebase.\n */\nconst fakeAuthProvider = {\n  isAuthenticated: false,\n  signin(callback: VoidFunction) {\n    fakeAuthProvider.isAuthenticated = true;\n    setTimeout(callback, 100); // fake async\n  },\n  signout(callback: VoidFunction) {\n    fakeAuthProvider.isAuthenticated = false;\n    setTimeout(callback, 100);\n  },\n};\n\nexport { fakeAuthProvider };\n\n"})}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",meta:'title="src/routes/Auth.tsx"',children:"import React from 'react';\nimport { useNavigate, Navigate, useLocation } from '@modern-js/runtime/router';\nimport { fakeAuthProvider } from './fakeAuth';\n\ninterface AuthContextType {\n  user: any;\n  signin: (user: string, callback: VoidFunction) => void;\n  signout: (callback: VoidFunction) => void;\n}\n\nconst AuthContext = React.createContext<AuthContextType>(null!);\n\nexport function AuthProvider({ children }: { children: React.ReactNode }) {\n  const [user, setUser] = React.useState<any>(null);\n\n  const signin = (newUser: string, callback: VoidFunction) =>\n    fakeAuthProvider.signin(() => {\n      setUser(newUser);\n      callback();\n    });\n\n  const signout = (callback: VoidFunction) =>\n    fakeAuthProvider.signout(() => {\n      setUser(null);\n      callback();\n    });\n\n  const value = { user, signin, signout };\n\n  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;\n}\n\nexport function useAuth() {\n  return React.useContext(AuthContext);\n}\n\nexport function AuthStatus() {\n  const auth = useAuth();\n  console.log('auth', auth);\n  const navigate = useNavigate();\n\n  if (!auth.user) {\n    return <p>You are not logged in.</p>;\n  }\n\n  return (\n    <p>\n      Welcome {auth.user}!{' '}\n      <button\n        type=\"button\"\n        onClick={() => {\n          auth.signout(() => navigate('/'));\n        }}\n      >\n        Sign out\n      </button>\n    </p>\n  );\n}\n\nexport function RequireAuth({ children }: { children: JSX.Element }) {\n  const auth = useAuth();\n  const location = useLocation();\n\n  if (!auth.user) {\n    // Redirect them to the /login page, but save the current location they were\n    // trying to go to when they were redirected. This allows us to send them\n    // along to that page after they login, which is a nicer user experience\n    // than dropping them off on the home page.\n    return <Navigate to=\"/login\" state={{ from: location }} replace />;\n  }\n\n  return children;\n}\n\n"})}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",meta:'title="src/routes/protected/page.tsx"',children:"import { RequireAuth } from '../Auth';\n\nexport default function ProtectedPage() {\n  return (\n    <div className=\"container-box\">\n      <RequireAuth>\n        <h3>Protected</h3>\n      </RequireAuth>\n    </div>\n  );\n}\n\n"})}),(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-ts",meta:'title="src/routes/login/page.tsx"',children:"import { useLocation, useNavigate } from '@modern-js/runtime/router';\nimport { useAuth } from '../Auth';\n\nexport default function Login() {\n  const navigate = useNavigate();\n  const location = useLocation();\n  const auth = useAuth();\n\n  const from = location.state?.from?.pathname || '/';\n\n  function handleSubmit(event: React.FormEvent<HTMLFormElement>) {\n    event.preventDefault();\n\n    const formData = new FormData(event.currentTarget);\n    const username = formData.get('username') as string;\n\n    auth.signin(username, () => {\n      // Send them back to the page they tried to visit when they were\n      // redirected to the login page. Use { replace: true } so we don't create\n      // another entry in the history stack for the login page.  This means that\n      // when they get to the protected page and click the back button, they\n      // won't end up back on the login page, which is also really nice for the\n      // user experience.\n      navigate(from, { replace: true });\n    });\n  }\n\n  return (\n    <div>\n      <p>You must log in to view the page at {from}</p>\n\n      <form onSubmit={handleSubmit}>\n        <label>\n          Username: <input name=\"username\" type=\"text\" />\n        </label>{' '}\n        <button type=\"submit\">Login</button>\n      </form>\n    </div>\n  );\n}\n\n"})})]})]})}(o=globalThis).__RSPRESS_PAGE_META||(o.__RSPRESS_PAGE_META={}),globalThis.__RSPRESS_PAGE_META["en%2Ftutorials%2Fexamples%2Fcsr-auth.mdx"]={toc:[],title:"Route Authorization",frontmatter:{title:"Route Authorization"}};var l=function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},n=Object.assign({},(0,s.useMDXComponents)(),e.components).wrapper;return n?(0,a.jsx)(n,(0,i._)((0,r._)({},e),{children:(0,a.jsx)(c,(0,r._)({},e))})):c(e)}}}]);