[{"id":50,"title":"Builder Core","content":"#\n\n本章节描述了 Builder 提供的一些核心方法。\n\n\ncreateBuilder#\n\n创建一个 Builder 实例对象。\n\n使用该方法时，需要搭配 @modern-js/builder-webpack-provider 或\n@modern-js/builder-rspack-provider 使用，Provider 基于特定 bundler 实现了对应的构建能力。\n\n\nbuilderWebpackProvider#\n\n当传入 builderWebpackProvider 时，Builder 会使用 webpack 作为 bundler 进行构建。\n\n\n\n\nbuilderRspackProvider#\n\n当传入 builderRspackProvider 时，Builder 会使用 Rspack 作为 bundler 进行构建。\n\n\n\n\noptions#\n\ncreateBuilder 的第二个参数是一个配置对象，你可以传入以下选项：\n\n\n\n各个选项的作用：\n\n * cwd: 当前执行构建的根路径，默认值为 process.cwd()\n * entry: 构建入口对象\n * target: 构建产物类型，默认值为 ['web']，详见 构建产物类型 章节。\n * framework: 框架的英文名称，唯一标识符，默认值为 'modern.js'\n * configPath: 框架配置文件的路径（绝对路径），该参数影响构建缓存更新\n\n\nmergeBuilderConfig#\n\n合并多份 Builder 配置对象，并返回一个合并后的新对象。\n\n * 类型\n\n\n\n * Example\n\n\n\n> 该方法不会修改传入的 config 对象。\n\n\nwebpack#\n\nwebpack 对象，用于消费 webpack 内置插件或类型定义。\n\n * Example\n\n\n\n> 大部分场景下，推荐从 Builder 中引用 webpack 对象，而不是手动安装一份 \"webpack\" 依赖，这样可以避免出现多实例问题。\n\n\nHtmlWebpackPlugin#\n\nHtmlWebpackPlugin 对象，通常用于实现 HtmlWebpackPlugin 的自定义插件。\n\n * Example\n\n\n\n> 大部分场景下，推荐从 Builder 中引用 HtmlWebpackPlugin 对象，而不是手动安装一份 \"html-webpack-plugin\"\n> 依赖，这样可以避免出现多实例问题。","routePath":"/builder/api/builder-core","lang":"zh","toc":[{"text":"createBuilder","id":"createbuilder","depth":2,"charIndex":30},{"text":"builderWebpackProvider","id":"builderwebpackprovider","depth":3,"charIndex":190},{"text":"builderRspackProvider","id":"builderrspackprovider","depth":3,"charIndex":285},{"text":"options","id":"options","depth":3,"charIndex":377},{"text":"mergeBuilderConfig","id":"mergebuilderconfig","depth":2,"charIndex":629},{"text":"webpack","id":"webpack","depth":2,"charIndex":732},{"text":"HtmlWebpackPlugin","id":"htmlwebpackplugin","depth":2,"charIndex":868}],"domain":"","frontmatter":{"extractApiHeaders":[2]},"version":""},{"id":51,"title":"Builder Instance","content":"#\n\n本章节描述了 Builder 实例对象上所有的属性和方法。\n\n\nbuilder.context#\n\nbuilder.context 是一个只读对象，提供一些上下文信息。\n\n\nbuilder.context.entry#\n\n构建入口对象，对应调用 createBuilder 时传入的 entry 选项。\n\n * 类型\n\n\n\n\nbuilder.context.target#\n\n构建产物类型，对应调用 createBuilder 时传入的 target 选项。\n\n * 类型\n\n\n\n\nbuilder.context.rootPath#\n\n当前执行构建的根路径，对应调用 createBuilder 时传入的 cwd 选项。\n\n * 类型\n\n\n\n\nbuilder.context.srcPath#\n\nsrc 目录的绝对路径。\n\n * 类型\n\n\n\n\nbuilder.context.distPath#\n\n构建产物输出目录的绝对路径，对应 BuilderConfig 中的 output.distPath.root 配置项。\n\n * 类型\n\n\n\n\nbuilder.context.cachePath#\n\n构建过程中生成的缓存文件所在的绝对路径。\n\n * 类型\n\n\n\n\nbuilder.context.configPath#\n\n框架配置文件的绝对路径，对应调用 createBuilder 时传入的 configPath 选项。\n\n * 类型\n\n\n\n\nbuilder.context.tsconfigPath#\n\ntsconfig.json 文件的绝对路径，若项目中不存在 tsconfig.json 文件，则为 undefined。\n\n * 类型\n\n\n\n\nbuilder.context.framework#\n\n框架的英文名称，唯一标识符，默认值为 'modern.js'。\n\n * 类型\n\n\n\n\nbuilder.context.devServer#\n\nDev Server 相关信息，包含了当前 Dev Server 的 hostname 和端口号。\n\n * 类型\n\n\n\n\nbuilder.context.bundlerType#\n\n当前执行构建的构建工具类型。\n\n * 类型\n\n\n\n\nbuilder.build#\n\n调用 build 方法时，会执行一次生产环境构建。\n\n * 类型\n\n\n\n * Example\n\n\n\n\n开发环境构建#\n\n如果需要执行一次开发环境构建，可以将 mode 参数设置为 'development'。\n\n\n\n\n监听文件变化#\n\n如果需要自动监听文件变化并重新执行构建，可以将 watch 参数设置为 true。\n\n\n\n\n自定义 Compiler#\n\n个别情况下，你可能希望使用自定义的 compiler：\n\n\n\n\nbuilder.startDevServer#\n\n启动本地 Dev Server，基于 Modern.js Dev Server 实现。\n\n * 类型\n\n\n\n * Example\n\n启动 Dev Server：\n\n\n\n成功启动 Dev Server 后，可以看到以下日志信息：\n\n\n\nstartDevServer 会返回以下参数：\n\n * urls：访问 Dev Server 的 URLs\n * port 实际监听的端口号\n * server：Server 实例对象\n\n\n\n\n自定义 URL 输出#\n\n将 printURLs 设置为 false 可以禁用默认的 URL 输出，此时你可以输出自定义的日志内容。\n\n\n\n你也可以直接将 printURLs 配置为一个函数来修改 URL，比如给每个 URL 增加一个子路径：\n\n\n\n\n严格限制端口#\n\n当端口被占用时，Builder 会自动递增端口号，直至找到一个可用端口。\n\n如果你希望在端口被占用时抛出异常，可以将 strictPort 设置为 true。\n\n\n\n\n自定义 Compiler#\n\n个别情况下，你可能希望使用自定义的 compiler：\n\n\n\n\n静默获取端口号#\n\n某些情况下，默认启动的端口号已经被占用，此时 Builder 会自动递增端口号，直至找到一个可用端口。这个过程会输出提示日志，如果你不希望这段日志，可以将\ngetPortSliently 设置为 true。\n\n\n\n\n自定义日志输出对象#\n\n默认情况下，Builder 会使用 @modern-js/utils/logger 来输出日志，你可以通过 logger 参数来自定义日志输出对象。\n\n\n\n这样，Builder 会使用你自定义的日志输出对象来输出日志。\n\n\nbuilder.serve#\n\n在本地启动 Server 来预览生产环境构建的产物，需要在 builder.build 方法之后执行。\n\n * 类型\n\n\n\n * Example\n\n启动 Server：\n\n\n\nserve 会返回以下参数：\n\n * urls：访问 Server 的 URLs\n * port 实际监听的端口号\n * server：Server 实例对象\n\n\n\n\nbuilder.createCompiler#\n\n创建一个 compiler 对象。\n\n当 createBuilder 的 target 选项包含一个值时，返回值为 Compiler；当 target 包含多个值时，返回值为\nMultiCompiler。\n\n * 类型\n\n\n\n * Example\n\n\n\n> 大部分场景下，不需要使用该 API，除非需要进行自定义 Dev Server 等高级操作。\n\n\nbuilder.addPlugins#\n\n注册一个或多个 builder 插件，可以被多次调用。\n\n该方法需要在开始编译前调用，如果在开始编译之后调用，则不会影响编译结果。\n\n * 类型\n\n\n\n * Example\n\n\n\n\nbuilder.removePlugins#\n\n移除一个或多个 builder 插件，可以被多次调用。\n\n该方法需要在开始编译前调用，如果在开始编译之后调用，则不会影响编译结果。\n\n * 类型\n\n\n\n * Example\n\n\n\n\nbuilder.isPluginExists#\n\n判断某个插件是否已经被注册。\n\n * 类型\n\n\n\n * Example\n\n\n\n\nbuilder.inspectConfig#\n\n查看 Builder 内部最终生成的 builder 配置和 bundler 配置。\n\nTIP\n\ninspectConfig 方法不支持与 startDevServer / build 方法同时使用。\n\n当你需要在构建过程中查看完整的 builder 和 bundler 配置时，可以使用 调试模式，也可以通过\nonBeforeBuild、onBeforeCreateCompile 等钩子函数来获取。\n\n * 类型\n\n\n\n * Example\n\n拿到字符串格式的 Config 内容：\n\n\n\n直接将配置内容写入到磁盘上：\n\n\n\n\nbuilder.onBeforeCreateCompiler#\n\nonBeforeCreateCompiler 是在创建底层 Compiler 实例前触发的回调函数，当你执行\nbuilder.startDevServer、builder.build 或 builder.createCompiler 时，都会调用此钩子。\n\n你可以通过 bundlerConfigs 参数获取到底层打包工具的最终配置数组：\n\n * 如果当前打包工具为 webpack，则获取到的是 webpack 配置数组。\n * 如果当前打包工具为 Rspack，则获取到的是 Rspack 配置数组。\n * 配置数组中可能包含一份或多份配置，这取决于你是否开启了 SSR 等功能。\n\n你可以通过 bundlerConfigs 参数获取到底层打包工具的最终配置对象。\n\n * 类型\n\n\n\n * Example\n\n\n\n\nbuilder.onAfterCreateCompiler#\n\nonAfterCreateCompiler 是在创建 Compiler 实例后、执行构建前触发的回调函数，当你执行\nbuilder.startDevServer、builder.build 或 builder.createCompiler 时，都会调用此钩子。\n\n你可以通过 compiler 参数获取到 Compiler 实例对象:\n\n * 如果当前打包工具为 webpack，则获取到的是 webpack Compiler 对象。\n\n * 如果当前打包工具为 Rspack，则获取到的是 Rspack Compiler 对象。\n\n * 类型\n\n\n\n * Example\n\n\n\n\nbuilder.onBeforeBuild#\n\nonBeforeBuild 是在执行生产环境构建前触发的回调函数，你可以通过 bundlerConfigs 参数获取到底层打包工具的最终配置数组：\n\n * 如果当前打包工具为 webpack，则获取到的是 webpack 配置数组。\n\n * 如果当前打包工具为 Rspack，则获取到的是 Rspack 配置数组。\n\n * 配置数组中可能包含一份或多份配置，这取决于 Builder 当前 target 配置的值。\n\n * 类型\n\n\n\n * Example\n\n\n\n\nbuilder.onAfterBuild#\n\nonAfterBuild 是在执行生产环境构建后触发的回调函数，你可以通过 stats 参数获取到构建结果信息：\n\n * 如果当前打包工具为 webpack，则获取到的是 webpack Stats。\n\n * 如果当前打包工具为 Rspack，则获取到的是 Rspack Stats。\n\n * 类型\n\n\n\n * Example\n\n\n\n\nbuilder.onBeforeStartDevServer#\n\n在启动开发服务器前调用。\n\n * 类型\n\n\n\n * Example\n\n\n\n\nbuilder.onAfterStartDevServer#\n\n在启动开发服务器后调用，你可以通过 port 参数获得开发服务器监听的端口号。\n\n * 类型\n\n\n\n * Example\n\n\n\n\nbuilder.onDevCompileDone#\n\n在每次开发环境构建结束后调用，你可以通过 isFirstCompile 来判断是否为首次构建。\n\n * 类型\n\n\n\n * Example\n\n\n\n\nbuilder.onExit#\n\n在进程即将退出时调用，这个钩子只能执行同步代码。\n\n * 类型\n\n\n\n * Example\n\n\n\n\nbuilder.getBuilderConfig#\n\n获取 Builder 配置，该方法必须在 modifyBuilderConfig 钩子执行完成后才能被调用。\n\n * 类型\n\n\n\n * Example\n\n\n\n\nbuilder.getNormalizedConfig#\n\n获取归一化后的 Builder 配置，该方法必须在 modifyBuilderConfig 钩子执行完成后才能被调用。\n\n相较于 getBuilderConfig 方法，该方法返回的配置经过了归一化处理，配置的类型定义会得到收敛，比如 config.html 的 undefined\n类型将被移除。\n\n推荐优先使用该方法获取配置。\n\n * 类型\n\n\n\n * Example\n\n\n\n\nbuilder.getHTMLPaths#\n\n获取所有 HTML 产物的路径信息。\n\n该方法会返回一个对象，对象的 key 为 entry 名称，value 为 HTML 文件在产物目录下的相对路径。\n\n * 类型\n\n\n\n * Example\n\n","routePath":"/builder/api/builder-instance","lang":"zh","toc":[{"text":"builder.context","id":"buildercontext","depth":2,"charIndex":34},{"text":"builder.context.entry","id":"buildercontextentry","depth":3,"charIndex":89},{"text":"builder.context.target","id":"buildercontexttarget","depth":3,"charIndex":165},{"text":"builder.context.rootPath","id":"buildercontextrootpath","depth":3,"charIndex":243},{"text":"builder.context.srcPath","id":"buildercontextsrcpath","depth":3,"charIndex":324},{"text":"builder.context.distPath","id":"buildercontextdistpath","depth":3,"charIndex":374},{"text":"builder.context.cachePath","id":"buildercontextcachepath","depth":3,"charIndex":472},{"text":"builder.context.configPath","id":"buildercontextconfigpath","depth":3,"charIndex":532},{"text":"builder.context.tsconfigPath","id":"buildercontexttsconfigpath","depth":3,"charIndex":623},{"text":"builder.context.framework","id":"buildercontextframework","depth":3,"charIndex":726},{"text":"builder.context.devServer","id":"buildercontextdevserver","depth":3,"charIndex":797},{"text":"builder.context.bundlerType","id":"buildercontextbundlertype","depth":3,"charIndex":886},{"text":"builder.build","id":"builderbuild","depth":2,"charIndex":942},{"text":"开发环境构建","id":"开发环境构建","depth":3,"charIndex":1009},{"text":"监听文件变化","id":"监听文件变化","depth":3,"charIndex":1067},{"text":"自定义 Compiler","id":"自定义-compiler","depth":3,"charIndex":1122},{"text":"builder.startDevServer","id":"builderstartdevserver","depth":2,"charIndex":1169},{"text":"自定义 URL 输出","id":"自定义-url-输出","depth":3,"charIndex":1408},{"text":"严格限制端口","id":"严格限制端口","depth":3,"charIndex":1534},{"text":"自定义 Compiler","id":"自定义-compiler-1","depth":3,"charIndex":1627},{"text":"静默获取端口号","id":"静默获取端口号","depth":3,"charIndex":1674},{"text":"自定义日志输出对象","id":"自定义日志输出对象","depth":3,"charIndex":1792},{"text":"builder.serve","id":"builderserve","depth":2,"charIndex":1916},{"text":"builder.createCompiler","id":"buildercreatecompiler","depth":2,"charIndex":2104},{"text":"builder.addPlugins","id":"builderaddplugins","depth":2,"charIndex":2306},{"text":"builder.removePlugins","id":"builderremoveplugins","depth":2,"charIndex":2418},{"text":"builder.isPluginExists","id":"builderispluginexists","depth":2,"charIndex":2533},{"text":"builder.inspectConfig","id":"builderinspectconfig","depth":2,"charIndex":2598},{"text":"builder.onBeforeCreateCompiler","id":"builderonbeforecreatecompiler","depth":2,"charIndex":2888},{"text":"builder.onAfterCreateCompiler","id":"builderonaftercreatecompiler","depth":2,"charIndex":3281},{"text":"builder.onBeforeBuild","id":"builderonbeforebuild","depth":2,"charIndex":3604},{"text":"builder.onAfterBuild","id":"builderonafterbuild","depth":2,"charIndex":3861},{"text":"builder.onBeforeStartDevServer","id":"builderonbeforestartdevserver","depth":2,"charIndex":4052},{"text":"builder.onAfterStartDevServer","id":"builderonafterstartdevserver","depth":2,"charIndex":4123},{"text":"builder.onDevCompileDone","id":"builderondevcompiledone","depth":2,"charIndex":4220},{"text":"builder.onExit","id":"builderonexit","depth":2,"charIndex":4320},{"text":"builder.getBuilderConfig","id":"buildergetbuilderconfig","depth":2,"charIndex":4387},{"text":"builder.getNormalizedConfig","id":"buildergetnormalizedconfig","depth":2,"charIndex":4494},{"text":"builder.getHTMLPaths","id":"buildergethtmlpaths","depth":2,"charIndex":4715}],"domain":"","frontmatter":{"extractApiHeaders":[2]},"version":""},{"id":52,"title":"Builder Types","content":"#\n\n本章节描述了 Builder 提供的一些类型定义。\n\n\nBuilderInstance#\n\nBuilder 实例的类型。\n\n\n\n你可以通过泛型来传入 Provider 的类型，使 Builder 实例获得更准确的类型定义：\n\n\n\n\nBuilderContext#\n\nBuilder 实例中 context 属性的类型定义。\n\n\n\n\nBuilderPlugin#\n\nBuilder 插件的类型，需要配合 provider 中提供的 BuilderPluginAPI 类型来使用。\n\n\n\n\nBuilderTarget#\n\nBuilder 构建产物的类型。\n\n\n\n\nBuilderEntry#\n\n对应 createBuilder 方法的 entry 选项的类型。\n\n\n\n\nCreateBuilderOptions#\n\n对应 createBuilder 方法的入参类型。\n\n","routePath":"/builder/api/builder-types","lang":"zh","toc":[{"text":"BuilderInstance","id":"builderinstance","depth":2,"charIndex":30},{"text":"BuilderContext","id":"buildercontext","depth":2,"charIndex":118},{"text":"BuilderPlugin","id":"builderplugin","depth":2,"charIndex":168},{"text":"BuilderTarget","id":"buildertarget","depth":2,"charIndex":245},{"text":"BuilderEntry","id":"builderentry","depth":2,"charIndex":282},{"text":"CreateBuilderOptions","id":"createbuilderoptions","depth":2,"charIndex":335}],"domain":"","frontmatter":{"extractApiHeaders":[2]},"version":""},{"id":53,"title":"Dev Config","content":"#\n\n本章节描述了 Builder 中与本地开发有关的配置。\n\n\ndev.assetPrefix#\n\n * 类型： boolean | string\n * 默认值： '/'\n\n设置开发环境下的静态资源 URL 前缀。\n\nassetPrefix 会影响构建产物中绝大部分静态资源的 URL，包括 JavaScript 文件、CSS\n文件、图片、视频等。如果指定了一个错误的值，则在加载这些资源时可能会出现 404 错误。\n\n该配置项仅用于开发环境。在生产环境下，请使用 output.assetPrefix 配置项进行设置。\n\n\nBoolean 类型#\n\n如果设置 assetPrefix 为 true，Builder 会使用 http://localhost:port/ 作为 URL 前缀：\n\n\n\n对应 JS 文件在浏览器中加载的地址如下：\n\n\n\n如果设置 assetPrefix 为 false 或不设置，则默认使用 / 作为访问前缀。\n\n\nString 类型#\n\n当 assetPrefix 的值为 string 类型时，字符串会作为前缀，自动拼接到静态资源访问 URL 上：\n\n\n\n对应 JS 文件在浏览器中加载的地址如下：\n\n\n\n\n与原生配置的区别#\n\ndev.assetPrefix 对应以下原生配置：\n\n * webpack 的 output.publicPath 配置。\n * Rspack 的 output.publicPath 配置。\n\n它与原生配置的区别在于：\n\n * dev.assetPrefix 仅在开发环境下生效。\n\n * dev.assetPrefix 默认会自动补全尾部的 /。\n\n * dev.assetPrefix 的值会写入 process.env.ASSET_PREFIX 环境变量。\n\n\ndev.beforeStartUrl#\n\n * 类型： () => Promise | void\n * 默认值： undefined\n\ndev.beforeStartUrl 用于在打开 startUrl 前执行一段回调函数，该配置项需要与 dev.startUrl 一同使用。\n\n\n\n\ndev.hmr#\n\n * 类型： boolean\n * 默认值： true\n\n是否开启 Hot Module Replacement 热更新能力。\n\n当 hmr 设置为 false 时，将不再提供热更新和 react-refresh 功能。\n\n\n\n\ndev.host#\n\n * 类型： string\n * 默认值： 0.0.0.0\n\n指定 dev server 启动时监听的 host。\n\n默认情况下，dev server 会监听 0.0.0.0，这代表监听所有的网络接口，包括 localhost 和公网地址。\n\n如果你希望 dev server 只监听 localhost，可以设置为：\n\n\n\n\ndev.https#\n\n * 类型： boolean | { key: string; cert: string }\n * 默认值： false\n\n配置该选项后，可以开启 Dev Server 对 HTTPS 的支持，同时会禁用 HTTP 服务器。\n\n开启前：\n\n\n\n开启后：\n\n\n\n自动生成证书#\n\n你可以直接将 https 设置为 true，Builder 会基于 devcert 来自动生成 Dev Server 所需的 HTTPS 证书。\n\n使用这种方式时，你需要在当前项目中手动安装 devcert 依赖：\n\n\n\n然后配置 dev.https 为 true 即可：\n\n\n\n该方式有一定局限性，由于 devcert 目前不支持 IP addresses，因此访问 Network 域名时，会遇到「您的连接不是私密连接」的问题。\n\n此问题的解决方法为：点击 Chrome 浏览器问题页面的「高级」->「继续前往 192.168.0.1（不安全）」。\n\nTIP\n\nhttps 代理自动安装证书需要获取 root 权限, 请根据提示输入密码即可。 密码仅在信任证书时使用，不会泄漏或者用于其他环节。\n\n手动设置证书#\n\n你也可以在 dev.https 选项中手动传入 HTTPS 服务器所需要的证书和对应的私钥，这个参数将直接传递给 Node.js 中 https 模块的\ncreateServer。\n\n具体可以参考 https.createServer。\n\n\n\n\ndev.port#\n\n * 类型： number\n * 默认值： 8080\n\n设置 Dev Server 监听的端口号。\n\n默认情况下，Dev Server 会监听 8080 端口，并在端口被占用时自动递增端口号。\n\n\n示例#\n\n将端口设置为 3000：\n\n\n\n\ndev.progressBar#\n\n * 类型：\n\n\n\n * 默认值： true\n\n是否在编译过程中展示进度条。\n\n\n\n如果需要修改进度条左侧显示的文本内容，可以设置 id 选项：\n\n\n\n\ndev.startUrl#\n\n * 类型： boolean | string | string[] | undefined\n * 默认值： undefined\n\ndev.startUrl 用于设置 Dev Server 启动时自动在浏览器中打开的页面 URL。\n\n默认情况下，Dev Server 启动时不会打开任何页面。\n\n你可以设置为如下的值：\n\n\n\n\n端口号占位符#\n\n由于端口号可能会发生变动，你可以使用 占位符来指代当前端口号，Builder 会自动将占位符替换为实际监听的端口号。\n\n\n\n\n打开指定浏览器#\n\n在 MacOS 上，通过设置环境变量 BROWSER，你可以指定 Dev Server 在启动时打开的浏览器，支持如下的值：\n\n * Google Chrome Canary\n * Google Chrome Dev\n * Google Chrome Beta\n * Google Chrome\n * Microsoft Edge\n * Brave Browser\n * Vivaldi\n * Chromium\n\n建议设置在.env.local文件中。","routePath":"/builder/api/config-dev","lang":"zh","toc":[{"text":"dev.assetPrefix","id":"devassetprefix","depth":2,"charIndex":32},{"text":"Boolean 类型","id":"boolean-类型","depth":3,"charIndex":263},{"text":"String 类型","id":"string-类型","depth":3,"charIndex":422},{"text":"与原生配置的区别","id":"与原生配置的区别","depth":3,"charIndex":520},{"text":"dev.beforeStartUrl","id":"devbeforestarturl","depth":2,"charIndex":765},{"text":"dev.hmr","id":"devhmr","depth":2,"charIndex":908},{"text":"dev.host","id":"devhost","depth":2,"charIndex":1033},{"text":"dev.https","id":"devhttps","depth":2,"charIndex":1208},{"text":"自动生成证书","id":"自动生成证书","depth":4,"charIndex":1350},{"text":"手动设置证书","id":"手动设置证书","depth":4,"charIndex":1710},{"text":"dev.port","id":"devport","depth":2,"charIndex":1842},{"text":"示例","id":"示例","depth":3,"charIndex":1952},{"text":"dev.progressBar","id":"devprogressbar","depth":2,"charIndex":1974},{"text":"dev.startUrl","id":"devstarturl","depth":2,"charIndex":2069},{"text":"端口号占位符","id":"端口号占位符","depth":3,"charIndex":2248},{"text":"打开指定浏览器","id":"打开指定浏览器","depth":3,"charIndex":2320}],"domain":"","frontmatter":{"extractApiHeaders":[2]},"version":""},{"id":54,"title":"Experiments Config","content":"#\n\n本章节描述了 Builder 中的一些实验性配置，实验性配置可以开启 Builder 中尚未稳定的功能。\n\n如果你在使用实验性功能时遇到问题，请先关闭对应的配置，并通过 GitHub Issues 进行反馈。\n\n\nexperiments.lazyCompilation#\n\n * 类型：\n\n\n\n * 默认值： false\n * 打包工具： 仅支持 webpack\n\n用于开启延迟编译（即按需编译）的能力。当开启此配置项时，Builder 会进行延迟编译，提升项目的编译启动速度。\n\n延迟编译只在开发环境下生效。\n\n\n延迟编译异步模块#\n\n延迟编译 dynamic import 引入的异步模块：\n\n\n\n开启 imports 选项后，所有的异步模块只有在被请求时才触发编译。如果你的项目是一个单页应用（SPA），并通过 dynamic import\n进行了路由拆分，那么会有明显的编译提速效果。\n\n\n延迟编译入口模块#\n\n除了延迟编译异步模块，你也可以选择同时延迟编译入口模块和异步模块。\n\n\n\n以上配置也可以简化为：\n\n\n\n开启 entries 选项后，当启动编译时，不会编译所有的页面，而是仅在路由跳转到对应的页面时，才对该页面进行编译。\n\n使用延迟编译入口模块时，有以下注意事项：\n\n * 只适用于多页应用（MPA），对单页应用（SPA）没有优化效果。\n * 当你访问一个页面时，由于要等待页面编译完成，会有一段时间的白屏。\n\n\n局限性#\n\n禁用拆包规则#\n\n当你开启延迟编译时，为了保证编译结果正常，Builder\n会在开发环境下禁用拆包规则。这不会影响生产环境的打包产物，但会导致开发环境和生产环境的打包产物有一定差异。\n\n使用代理#\n\nLazy Compilation 依赖 webpack 在本地启动的开发服务器，当你将某个域名代理到 localhost 进行开发时，Lazy\nCompilation 将无法正常工作。因此，如果你需要使用代理时，请禁用 Lazy Compilation。\n\n其他潜在的问题#\n\n考虑到 Lazy Compilation 仍然是 webpack\n的实验性功能，因此你在使用过程中，可能会遇到一些潜在的问题，比如编译产物的行为变化，或是编译出现异常。\n\n当你遇到这些问题时，可以参考 webpack 的 Issues 寻找解决方案，也可以关闭 lazyCompilation 配置项。\n\n\nexperiments.sourceBuild#\n\n * 类型： boolean | PluginSourceBuildOptions\n * 默认值： false\n * 版本： MAJOR_VERSION.46.0\n\n用于开启源码构建的能力。当开启此配置项时，Builder 会读取子项目 package.json 的 source 字段对应的源码文件，并进行编译。\n\n\n\n更多信息可参考「源码构建模式」。\n\n\n选项#\n\nexperiments.sourceBuild 底层基于 Rsbuild 的 Source Build 插件 实现，你可以传入插件选项，比如：\n\n","routePath":"/builder/api/config-experiments","lang":"zh","toc":[{"text":"experiments.lazyCompilation","id":"experimentslazycompilation","depth":2,"charIndex":109},{"text":"延迟编译异步模块","id":"延迟编译异步模块","depth":3,"charIndex":260},{"text":"延迟编译入口模块","id":"延迟编译入口模块","depth":3,"charIndex":401},{"text":"局限性","id":"局限性","depth":3,"charIndex":619},{"text":"禁用拆包规则","id":"禁用拆包规则","depth":4,"charIndex":625},{"text":"使用代理","id":"使用代理","depth":4,"charIndex":718},{"text":"其他潜在的问题","id":"其他潜在的问题","depth":4,"charIndex":854},{"text":"experiments.sourceBuild","id":"experimentssourcebuild","depth":2,"charIndex":1018},{"text":"选项","id":"选项","depth":3,"charIndex":1224}],"domain":"","frontmatter":{"extractApiHeaders":[2]},"version":""},{"id":55,"title":"Html Config","content":"#\n\n本章节描述了 Builder 中与 HTML 有关的配置。\n\n\nhtml.appIcon#\n\n * 类型： string\n * 默认值： undefined\n\n设置 iOS 系统下的 apple-touch-icon 图标的文件路径，可以设置为相对于项目根目录的相对路径，也可以设置为文件的绝对路径。暂不支持设置为\nCDN URL。\n\n配置该选项后，在编译过程中会自动将图标拷贝至 dist 目录下，并在 HTML 中添加相应的 link 标签。\n\n\n示例#\n\n设置为相对路径：\n\n\n\n设置为绝对路径：\n\n\n\n重新编译后，HTML 中自动生成了以下标签：\n\n\n\n\nhtml.crossorigin#\n\n * 类型： boolean | 'anonymous' | 'use-credentials'\n * 默认值： false\n\n用于设置\n\n","routePath":"/builder/api/config-html","lang":"zh","toc":[{"text":"html.appIcon","id":"htmlappicon","depth":2,"charIndex":34},{"text":"示例","id":"示例","depth":3,"charIndex":228},{"text":"html.crossorigin","id":"htmlcrossorigin","depth":2,"charIndex":284},{"text":"示例","id":"示例-1","depth":3,"charIndex":-1},{"text":"可选值","id":"可选值","depth":3,"charIndex":-1},{"text":"html.disableHtmlFolder","id":"htmldisablehtmlfolder","depth":2,"charIndex":-1},{"text":"示例","id":"示例-2","depth":3,"charIndex":228},{"text":"html.favicon","id":"htmlfavicon","depth":2,"charIndex":-1},{"text":"示例","id":"示例-3","depth":3,"charIndex":-1},{"text":"html.faviconByEntries","id":"htmlfaviconbyentries","depth":2,"charIndex":-1},{"text":"示例","id":"示例-4","depth":3,"charIndex":228},{"text":"html.inject","id":"htmlinject","depth":2,"charIndex":-1},{"text":"默认插入位置","id":"默认插入位置","depth":4,"charIndex":-1},{"text":"插入至 body 标签","id":"插入至-body-标签","depth":4,"charIndex":-1},{"text":"html.injectByEntries","id":"htmlinjectbyentries","depth":2,"charIndex":-1},{"text":"示例","id":"示例-5","depth":3,"charIndex":-1},{"text":"html.meta","id":"htmlmeta","depth":2,"charIndex":-1},{"text":"示例","id":"示例-6","depth":3,"charIndex":228},{"text":"html.metaByEntries","id":"htmlmetabyentries","depth":2,"charIndex":-1},{"text":"示例","id":"示例-7","depth":3,"charIndex":-1},{"text":"html.mountId","id":"htmlmountid","depth":2,"charIndex":-1},{"text":"示例","id":"示例-8","depth":3,"charIndex":228},{"text":"注意事项","id":"注意事项","depth":3,"charIndex":-1},{"text":"更新相关代码","id":"更新相关代码","depth":4,"charIndex":-1},{"text":"自定义模板","id":"自定义模板","depth":4,"charIndex":-1},{"text":"html.scriptLoading","id":"htmlscriptloading","depth":2,"charIndex":-1},{"text":"defer","id":"defer","depth":3,"charIndex":-1},{"text":"blocking","id":"blocking","depth":3,"charIndex":-1},{"text":"module","id":"module","depth":3,"charIndex":-1},{"text":"html.tags","id":"htmltags","depth":2,"charIndex":-1},{"text":"对象形式","id":"对象形式","depth":4,"charIndex":-1},{"text":"函数形式","id":"函数形式","depth":4,"charIndex":-1},{"text":"限制","id":"限制","depth":4,"charIndex":-1},{"text":"html.tagsByEntries","id":"htmltagsbyentries","depth":2,"charIndex":-1},{"text":"示例","id":"示例-9","depth":3,"charIndex":-1},{"text":"html.template","id":"htmltemplate","depth":2,"charIndex":-1},{"text":"示例","id":"示例-10","depth":3,"charIndex":228},{"text":"html.templateByEntries","id":"htmltemplatebyentries","depth":2,"charIndex":-1},{"text":"示例","id":"示例-11","depth":3,"charIndex":-1},{"text":"html.templateParameters","id":"htmltemplateparameters","depth":2,"charIndex":-1},{"text":"html.templateParametersByEntries","id":"htmltemplateparametersbyentries","depth":2,"charIndex":-1},{"text":"示例","id":"示例-12","depth":3,"charIndex":228},{"text":"html.title","id":"htmltitle","depth":2,"charIndex":-1},{"text":"html.titleByEntries","id":"htmltitlebyentries","depth":2,"charIndex":-1},{"text":"示例","id":"示例-13","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"extractApiHeaders":[2]},"version":""},{"id":56,"title":"Output Config","content":"+ <%= htmlWebpackPlugin.tags.bodyTags %>","routePath":"/builder/api/config-output","lang":"zh","toc":[{"text":"output.assetPrefix","id":"outputassetprefix","depth":2,"charIndex":-1},{"text":"示例","id":"示例","depth":3,"charIndex":-1},{"text":"与原生配置的区别","id":"与原生配置的区别","depth":3,"charIndex":-1},{"text":"output.assetsRetry","id":"outputassetsretry","depth":2,"charIndex":-1},{"text":"assetsRetry.domain","id":"assetsretrydomain","depth":3,"charIndex":-1},{"text":"assetsRetry.type","id":"assetsretrytype","depth":3,"charIndex":-1},{"text":"assetsRetry.max","id":"assetsretrymax","depth":3,"charIndex":-1},{"text":"assetsRetry.test","id":"assetsretrytest","depth":3,"charIndex":-1},{"text":"assetsRetry.crossOrigin","id":"assetsretrycrossorigin","depth":3,"charIndex":-1},{"text":"assetsRetry.onRetry","id":"assetsretryonretry","depth":3,"charIndex":-1},{"text":"assetsRetry.onSuccess","id":"assetsretryonsuccess","depth":3,"charIndex":-1},{"text":"assetsRetry.onFail","id":"assetsretryonfail","depth":3,"charIndex":-1},{"text":"assetsRetry.inlineScript","id":"assetsretryinlinescript","depth":3,"charIndex":-1},{"text":"注意事项","id":"注意事项","depth":3,"charIndex":-1},{"text":"使用限制","id":"使用限制","depth":3,"charIndex":-1},{"text":"微前端应用","id":"微前端应用","depth":4,"charIndex":-1},{"text":"动态 import 资源","id":"动态-import-资源","depth":4,"charIndex":-1},{"text":"自定义模版中的资源","id":"自定义模版中的资源","depth":4,"charIndex":-1},{"text":"output.charset","id":"outputcharset","depth":2,"charIndex":-1},{"text":"output.cleanDistPath","id":"outputcleandistpath","depth":2,"charIndex":-1},{"text":"output.convertToRem","id":"outputconverttorem","depth":2,"charIndex":-1},{"text":"Boolean 类型","id":"boolean-类型","depth":3,"charIndex":-1},{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":-1},{"text":"示例","id":"示例-1","depth":3,"charIndex":-1},{"text":"output.copy","id":"outputcopy","depth":2,"charIndex":-1},{"text":"output.cssModules","id":"outputcssmodules","depth":2,"charIndex":-1},{"text":"cssModules.auto","id":"cssmodulesauto","depth":3,"charIndex":-1},{"text":"cssModules.exportLocalsConvention","id":"cssmodulesexportlocalsconvention","depth":3,"charIndex":-1},{"text":"output.cssModuleLocalIdentName","id":"outputcssmodulelocalidentname","depth":2,"charIndex":-1},{"text":"默认值","id":"默认值","depth":3,"charIndex":-1},{"text":"模板字符串","id":"模板字符串","depth":3,"charIndex":-1},{"text":"示例","id":"示例-2","depth":3,"charIndex":-1},{"text":"output.dataUriLimit","id":"outputdataurilimit","depth":2,"charIndex":-1},{"text":"示例","id":"示例-3","depth":3,"charIndex":-1},{"text":"output.disableCssExtract","id":"outputdisablecssextract","depth":2,"charIndex":-1},{"text":"示例","id":"示例-4","depth":3,"charIndex":-1},{"text":"output.disableCssModuleExtension","id":"outputdisablecssmoduleextension","depth":2,"charIndex":-1},{"text":"示例","id":"示例-5","depth":3,"charIndex":-1},{"text":"规则","id":"规则","depth":3,"charIndex":-1},{"text":"未开启 disableCssModuleExtension（默认）","id":"未开启-disablecssmoduleextension默认","depth":4,"charIndex":-1},{"text":"开启 disableCssModuleExtension","id":"开启-disablecssmoduleextension","depth":4,"charIndex":-1},{"text":"output.distPath","id":"outputdistpath","depth":2,"charIndex":-1},{"text":"根目录","id":"根目录","depth":3,"charIndex":-1},{"text":"示例","id":"示例-6","depth":3,"charIndex":-1},{"text":"output.disableMinimize","id":"outputdisableminimize","depth":2,"charIndex":-1},{"text":"output.disableSourceMap","id":"outputdisablesourcemap","depth":2,"charIndex":-1},{"text":"output.disableSvgr","id":"outputdisablesvgr","depth":2,"charIndex":-1},{"text":"output.disableTsChecker","id":"outputdisabletschecker","depth":2,"charIndex":-1},{"text":"阻塞编译","id":"阻塞编译","depth":3,"charIndex":-1},{"text":"示例","id":"示例-7","depth":3,"charIndex":-1},{"text":"output.disableFilenameHash","id":"outputdisablefilenamehash","depth":2,"charIndex":-1},{"text":"示例","id":"示例-8","depth":3,"charIndex":-1},{"text":"output.disableInlineRuntimeChunk","id":"outputdisableinlineruntimechunk","depth":2,"charIndex":-1},{"text":"禁用内联","id":"禁用内联","depth":3,"charIndex":-1},{"text":"合并到页面文件中","id":"合并到页面文件中","depth":3,"charIndex":-1},{"text":"output.enableAssetManifest","id":"outputenableassetmanifest","depth":2,"charIndex":-1},{"text":"示例","id":"示例-9","depth":3,"charIndex":-1},{"text":"output.enableAssetFallback","id":"outputenableassetfallback","depth":2,"charIndex":-1},{"text":"示例","id":"示例-10","depth":3,"charIndex":-1},{"text":"output.enableLatestDecorators","id":"outputenablelatestdecorators","depth":2,"charIndex":-1},{"text":"output.enableCssModuleTSDeclaration","id":"outputenablecssmoduletsdeclaration","depth":2,"charIndex":-1},{"text":"Example","id":"example","depth":3,"charIndex":-1},{"text":"output.enableInlineScripts","id":"outputenableinlinescripts","depth":2,"charIndex":-1},{"text":"示例","id":"示例-11","depth":3,"charIndex":-1},{"text":"通过正则匹配","id":"通过正则匹配","depth":3,"charIndex":-1},{"text":"通过函数匹配","id":"通过函数匹配","depth":3,"charIndex":-1},{"text":"output.enableInlineStyles","id":"outputenableinlinestyles","depth":2,"charIndex":-1},{"text":"示例","id":"示例-12","depth":3,"charIndex":-1},{"text":"通过正则匹配","id":"通过正则匹配-1","depth":3,"charIndex":-1},{"text":"通过函数匹配","id":"通过函数匹配-1","depth":3,"charIndex":-1},{"text":"output.externals","id":"outputexternals","depth":2,"charIndex":-1},{"text":"示例","id":"示例-13","depth":3,"charIndex":-1},{"text":"output.filename","id":"outputfilename","depth":2,"charIndex":-1},{"text":"示例","id":"示例-14","depth":3,"charIndex":-1},{"text":"异步模块的文件名","id":"异步模块的文件名","depth":3,"charIndex":-1},{"text":"output.legalComments","id":"outputlegalcomments","depth":2,"charIndex":-1},{"text":"示例","id":"示例-15","depth":3,"charIndex":-1},{"text":"output.overrideBrowserslist","id":"outputoverridebrowserslist","depth":2,"charIndex":-1},{"text":"优先级","id":"优先级","depth":4,"charIndex":-1},{"text":"默认值","id":"默认值-1","depth":4,"charIndex":-1},{"text":"示例","id":"示例-16","depth":3,"charIndex":-1},{"text":"根据产物类型设置","id":"根据产物类型设置","depth":4,"charIndex":-1},{"text":"output.polyfill","id":"outputpolyfill","depth":2,"charIndex":-1},{"text":"配置项","id":"配置项","depth":3,"charIndex":-1},{"text":"entry","id":"entry","depth":4,"charIndex":-1},{"text":"usage","id":"usage","depth":4,"charIndex":-1},{"text":"ua","id":"ua","depth":4,"charIndex":-1},{"text":"off","id":"off","depth":4,"charIndex":-1},{"text":"output.svgDefaultExport","id":"outputsvgdefaultexport","depth":2,"charIndex":-1}],"domain":"","frontmatter":{"extractApiHeaders":[2]},"version":""},{"id":57,"title":"Performance Config","content":"#\n\n本章节描述了 Builder 中与性能有关的配置。\n\n\nperformance.buildCache#\n\n * 类型：\n\n\n\n * 默认值：\n\n\n\n * 打包工具： 仅支持 webpack\n\n控制 Builder 在构建过程中的缓存行为。\n\nBuilder 默认会开启构建缓存来提升二次构建的速度，并默认把生成的缓存文件写到 ./node_modules/.cache/webpack 目录下。\n\n你可以通过 buildCache 配置缓存路径，比如：\n\n\n\n如果不希望缓存，你也可以将 buildCache 置为 false 将其禁用掉：\n\n\n\n\ncacheDigest#\n\ncacheDigest 用来添加一些会对构建结果产生影响的环境变量。Builder 将根据 cacheDigest\n内容和当前构建模式来设置缓存名称，来确保不同的 cacheDigest 可以命中不同的缓存。\n\n示例#\n\n当前项目需要根据不同的 APP_ID 来设置不同的 extensions。默认情况下，由于当前项目的代码 & 配置 & 依赖未发生变化，会命中之前的缓存。\n通过将 APP_ID 添加到 cacheDigest 中，在 APP_ID 变化时会去查找不同的缓存结果，从而避免命中不符合预期的缓存结果。\n\n\n\n\nperformance.bundleAnalyze#\n\n * 类型： Object | undefined\n\n用于开启 webpack-bundle-analyzer 插件来分析产物体积。\n\n默认情况下，Builder 不会开启 webpack-bundle-analyzer。当开启该功能后，内部的默认配置如下:\n\n\n\n\n启用 Bundle Analyze#\n\n你有两种方式开启 webpack-bundle-analyzer 来分析构建产物的体积:\n\n * 添加环境变量 BUNDLE_ANALYZE=true，比如：\n\n\n\n * 配置 performance.bundleAnalyze 来固定开启：\n\n\n\n在启用后，Builder 会生成一个分析构建产物体积的 HTML 文件，并在 Terminal 中打印以下日志：\n\n\n\n手动在浏览器中打开该文件，可以看到打包产物的瓦片图；区块的面积越大，说明该模块的体积越大。\n\n\n\n\n覆盖默认配置#\n\n你可以通过 performance.bundleAnalyze 来覆盖默认配置，比如开启 server 模式：\n\n\n\n\nSize 类型#\n\n在 webpack-bundle-analyzer 的面板中，你可以在左上角控制 Size 类型（默认为 Parsed）：\n\n * Stat：从打包工具的 stats 对象中获取的体积，它反映了代码在压缩之前的体积。\n * Parsed：磁盘上的文件体积，它反映了代码在压缩之后的体积。\n * Gzipped：浏览器里请求的文件体积，它反映了代码在压缩和 gzip 后的体积。\n\n\n生成 stats.json#\n\ngenerateStatsFile 设置为 true 时，将会生成 stats JSON 文件。\n\n\n\n\n注意事项#\n\n 1. 开启 Server 模式会导致 build 进程不能正常退出。\n\n 2. 开启 bundleAnalyzer 会降低构建性能。因此，在日常开发过程中不应该开启此配置项，建议通过 BUNDLE_ANALYZE\n    环境变量来按需开启。\n\n 3. 由于 dev 阶段不会进行代码压缩等优化，无法反映真实的产物体积，因此建议在 build 阶段分析产物体积。\n\n\nperformance.chunkSplit#\n\n * 类型： Object\n * 默认值： { strategy: 'split-by-experience' }\n\nperformance.chunkSplit 用于配置 Builder 的拆包策略。配置项的类型 ChunkSplit 如下:\n\n\n\n\nchunkSplit.strategy#\n\nBuilder 支持设置以下几种拆包策略：\n\n * split-by-experience: 根据经验制定的拆分策略，自动将一些常用的 npm 包拆分为体积适中的 chunk。\n * split-by-module: 按 NPM 包的粒度拆分，每个 NPM 包对应一个 chunk。\n * split-by-size：根据模块大小自动进行拆分。\n * all-in-one: 将所有代码全部打包到一个 chunk 中。\n * single-vendor: 将所有 NPM 包的代码打包到一个单独的 chunk 中。\n * custom: 自定义拆包配置。\n\n\n默认拆包策略#\n\nBuilder 默认采用 split-by-experience 策略，这是我们根据经验制定的策略。具体来说，当你的项目中引用了以下 npm\n包时，它们会自动被拆分为单独的 chunk：\n\n * lib-polyfill.js：包含 core-js，@babel/runtime，@swc/helpers，tslib。\n * lib-react.js：包含 react，react-dom。\n * lib-router.js：包含 react-router，react-router-dom，history，@remix-run/router。\n * lib-lodash.js：包含 lodash，lodash-es。\n * lib-antd.js：包含 antd。\n * lib-arco.js：包含 @arco-design/web-react。\n * lib-semi.js：包含 @douyinfe/semi-ui。\n\nTIP\n\n如果项目中没有安装或引用以上 npm 包，则不会生成相应的 chunk。\n\n如果你想使用其他拆包策略，可以通过 performance.chunkSplit.strategy 配置项来指定。\n\n\nchunkSplit.minSize#\n\n * 类型： number\n * 默认值： 10000\n\n当 performance.chunkSplit.strategy 为 split-by-size 时，可以通过\nperformance.chunkSplit.minSize 配置项来指定 chunk 的最小大小，单位为字节。默认值为 10000。比如:\n\n\n\n\nchunkSplit.maxSize#\n\n * 类型： number\n * 默认值： Infinity\n\n当 performance.chunkSplit.strategy 为 split-by-size 时，可以通过\nperformance.chunkSplit.maxSize 配置项来指定 chunk 的最大大小，单位为字节。默认值为 Infinity。比如:\n\n\n\n\nchunkSplit.forceSplitting#\n\n * 类型： RegExp[] | Record\n * 默认值： []\n\n通过 performance.chunkSplit.forceSplitting 配置项可以将指定的模块强制拆分为一个独立的 chunk。\n\n比如将 node_modules 下的 axios 库拆分到 axios.js 中：\n\n\n\n相比直接配置 webpack 的 splitChunks，这是一个更加简便的方式。\n\nTIP\n\n注意，通过 forceSplitting 配置拆分的 chunk 会通过","routePath":"/builder/api/config-performance","lang":"zh","toc":[{"text":"performance.buildCache","id":"performancebuildcache","depth":2,"charIndex":30},{"text":"cacheDigest","id":"cachedigest","depth":3,"charIndex":277},{"text":"示例","id":"示例","depth":4,"charIndex":397},{"text":"performance.bundleAnalyze","id":"performancebundleanalyze","depth":2,"charIndex":555},{"text":"启用 Bundle Analyze","id":"启用-bundle-analyze","depth":3,"charIndex":717},{"text":"覆盖默认配置","id":"覆盖默认配置","depth":3,"charIndex":972},{"text":"Size 类型","id":"size-类型","depth":3,"charIndex":1041},{"text":"生成 stats.json","id":"生成-statsjson","depth":3,"charIndex":1242},{"text":"注意事项","id":"注意事项","depth":3,"charIndex":1311},{"text":"performance.chunkSplit","id":"performancechunksplit","depth":2,"charIndex":1503},{"text":"chunkSplit.strategy","id":"chunksplitstrategy","depth":3,"charIndex":1655},{"text":"默认拆包策略","id":"默认拆包策略","depth":3,"charIndex":1957},{"text":"chunkSplit.minSize","id":"chunksplitminsize","depth":3,"charIndex":2484},{"text":"chunkSplit.maxSize","id":"chunksplitmaxsize","depth":3,"charIndex":2666},{"text":"chunkSplit.forceSplitting","id":"chunksplitforcesplitting","depth":3,"charIndex":2854},{"text":"chunkSplit.splitChunks","id":"chunksplitsplitchunks","depth":3,"charIndex":-1},{"text":"chunkSplit.override","id":"chunksplitoverride","depth":3,"charIndex":-1},{"text":"performance.dnsPrefetch","id":"performancednsprefetch","depth":2,"charIndex":-1},{"text":"示例","id":"示例-1","depth":3,"charIndex":-1},{"text":"performance.preconnect","id":"performancepreconnect","depth":2,"charIndex":-1},{"text":"示例","id":"示例-2","depth":3,"charIndex":397},{"text":"performance.prefetch","id":"performanceprefetch","depth":2,"charIndex":-1},{"text":"Boolean 类型","id":"boolean-类型","depth":3,"charIndex":-1},{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":-1},{"text":"prefetch.type","id":"prefetchtype","depth":4,"charIndex":-1},{"text":"示例","id":"示例-3","depth":4,"charIndex":-1},{"text":"performance.preload","id":"performancepreload","depth":2,"charIndex":-1},{"text":"Boolean 类型","id":"boolean-类型-1","depth":3,"charIndex":-1},{"text":"Object 类型","id":"object-类型-1","depth":3,"charIndex":-1},{"text":"preload.type","id":"preloadtype","depth":4,"charIndex":-1},{"text":"示例","id":"示例-4","depth":4,"charIndex":397},{"text":"performance.printFileSize","id":"performanceprintfilesize","depth":2,"charIndex":-1},{"text":"示例","id":"示例-5","depth":3,"charIndex":-1},{"text":"performance.profile","id":"performanceprofile","depth":2,"charIndex":-1},{"text":"示例","id":"示例-6","depth":3,"charIndex":397},{"text":"performance.removeConsole","id":"performanceremoveconsole","depth":2,"charIndex":-1},{"text":"移除所有 console","id":"移除所有-console","depth":4,"charIndex":-1},{"text":"移除特定的 console","id":"移除特定的-console","depth":4,"charIndex":-1},{"text":"performance.removeMomentLocale","id":"performanceremovemomentlocale","depth":2,"charIndex":-1},{"text":"performance.transformLodash","id":"performancetransformlodash","depth":2,"charIndex":-1},{"text":"示例","id":"示例-7","depth":3,"charIndex":-1},{"text":"关闭转换","id":"关闭转换","depth":3,"charIndex":-1}],"domain":"","frontmatter":{"extractApiHeaders":[2]},"version":""},{"id":58,"title":"Security Config","content":"#\n\n本章节描述了 Builder 中与安全有关的配置。\n\n\nsecurity.sri#\n\n * 类型：\n\n\n\n * 默认值： undefined\n * 打包工具： 仅支持 webpack\n\n为 HTML 所引入的子资源添加完整性属性 —— integrity，使浏览器能够验证引入资源的完整性，以此防止下载的资源被篡改。\n\n启动该选项后会将 webpack 的 output.crossOriginLoading 配置项设置为 anonymous。\n\nSRI 介绍#\n\n子资源完整性 Subresource Integrity（SRI）是专门用来校验资源的一种方案，它读取资源标签中的 integrity\n属性，将其中的信息摘要值，和资源实际的信息摘要值进行对比，如果发现无法匹配，那么浏览器就会拒绝执行资源。\n\n对于 script 标签来说，结果为拒绝执行其中的代码；对于 CSS link 来说，结果为不加载其中的样式。\n\n关于 SRI 的更多内容，可以查看 Subresource Integrity - MDN。\n\n\n示例#\n\n默认情况下，不会开启 SRI，当开启之后它的默认配置如下：\n\n\n\n你可以按照你自己的需求自定义配置项:\n\n\n\n\nsecurity.checkSyntax#\n\n * 类型：\n\n\n\n * 默认值： false\n\n用于分析构建产物中是否存在当前浏览器范围下不兼容的高级语法。如果存在，会将详细信息打印在终端。\n\n\n启用检测#\n\n你可以将 checkSyntax 设置为 true 来启用语法检测。\n\n\n\n当你开启 checkSyntax 后，Builder\n会在生产环境构建时进行检测，当在构建产物中检测到不兼容的高级语法后，会将错误日志打印在终端，并退出当前构建流程。\n\n\n错误日志#\n\n错误日志的格式如下所示，包含代码来源文件、产物位置、错误原因、源代码等信息：\n\n\n\nTIP\n\n目前语法检测是基于 AST parser\n来实现的，每次检测时，只能找出文件中的第一个不兼容语法。如果一个文件中存在多个不兼容语法，你需要修复已发现的语法，并重新执行检测。output.disableM\ninimize 设置为 true 后再重新构建。\n\n如果日志中没有显示对应的源码位置，可以尝试将\n\n\n解决方法#\n\n当检测到语法错误后，你可以通过以下方式来处理：\n\n * 如果你希望降级该语法，以保证代码具备良好的兼容性，可以通过 source.include 配置来编译相应的模块。\n * 如果你不希望降级该语法，可以调整项目的 browserslist 范围，调整至与该语法相匹配的范围。\n * 如果你不希望对某些产物进行语法检查，可用 checkSyntax.exclude 配置排除要检查的文件。\n\n\n配置项#\n\ncheckSyntax.targets#\n\n * 类型： string[]\n * 默认值： 当前项目的 browserslist 配置\n\ntargets 表示项目的目标浏览器范围，它的值为标准的 browserslist 数组，如果你不了解 browserslist 的用法，请参考\n「设置浏览器范围」。\n\nBuilder 会读取 targets 的值，并自动推导出构建产物中可以使用的最低 ECMAScript 语法版本，比如 ES5 或 ES6。\n\n * 示例：\n\n比如，项目中需要兼容的浏览器为 Chrome 53 以上版本，可以添加以下设置：\n\n\n\nBuilder 会推导出 chrome >= 53 可以使用的 ECMAScript 语法版本为 ES6，当构建产物中包含 es2016\n或更高的语法时，就会触发语法错误提示。\n\nTIP\n\n请留意，Builder 不支持基于 targets 来自动分析 ES6 以上的语法版本，如果你的构建产物兼容的语法版本超过 ES6，请通过\ncheckSyntax.ecmaVersion 进行设置。\n\ncheckSyntax.ecmaVersion#\n\n * 类型： 3 | 5 | 6 | 2015 | 2016 | 2017 | 2018 | 2019 | 2020 | 2021 | 2022 |\n   'latest'\n * 默认值： 基于 targets 自动分析\n\necmaVersion 表示构建产物中可以使用的最低 ECMAScript 语法版本，ecmaVersion 的优先级高于 targets。\n\n * 示例：\n\n比如，构建产物中可以使用的最低 ECMAScript 语法版本为 ES2020，可以添加以下设置：\n\n\n\n此时，构建产物中可以包含 ES2020 支持的所有语法，比如 optional chaining。\n\ncheckSyntax.exclude#\n\n * 类型： RegExp | RegExp[]\n * 默认值： undefined\n\nexclude 用于在检测时排除一部分文件，你可以传入一个或多个正则表达式来匹配源文件的路径，符合正则的文件将会被忽略，不会触发语法检测。\n\n * 示例：\n\n比如，忽略 node_modules/foo 目录下的文件：\n\n","routePath":"/builder/api/config-security","lang":"zh","toc":[{"text":"security.sri","id":"securitysri","depth":2,"charIndex":30},{"text":"SRI 介绍","id":"sri-介绍","depth":4,"charIndex":226},{"text":"示例","id":"示例","depth":3,"charIndex":463},{"text":"security.checkSyntax","id":"securitychecksyntax","depth":2,"charIndex":524},{"text":"启用检测","id":"启用检测","depth":3,"charIndex":622},{"text":"错误日志","id":"错误日志","depth":3,"charIndex":753},{"text":"解决方法","id":"解决方法","depth":3,"charIndex":960},{"text":"配置项","id":"配置项","depth":3,"charIndex":1164},{"text":"checkSyntax.targets","id":"checksyntaxtargets","depth":4,"charIndex":1170},{"text":"checkSyntax.ecmaVersion","id":"checksyntaxecmaversion","depth":4,"charIndex":1645},{"text":"checkSyntax.exclude","id":"checksyntaxexclude","depth":4,"charIndex":1967}],"domain":"","frontmatter":{"extractApiHeaders":[2]},"version":""},{"id":59,"title":"Source Config","content":"#\n\n本章节描述了 Builder 中与源代码解析、编译方式相关的配置。\n\n\nsource.alias#\n\n * 类型： Record | Function\n * 默认值： undefined\n\n设置文件引用的别名，对应 webpack 和 Rspack 的 resolve.alias 配置。\n\nTIP\n\n对于 TypeScript 项目，你只需要在 tsconfig.json 中配置 compilerOptions.paths 即可，Builder\n会自动识别它，不需要额外配置 source.alias 字段，详见 「路径别名」。\n\n\nObject 类型#\n\nalias 的值可以定义为 Object 类型，其中的相对路径会自动被 Builder 转换为绝对路径。\n\n\n\n以上配置完成后，如果你在代码中引用 @common/Foo.tsx, 则会映射到 /src/common/Foo.tsx 路径上。\n\n\nFunction 类型#\n\nalias 的值定义为函数时，可以接受预设的 alias 对象，并对其进行修改。\n\n\n\n也可以在函数中返回一个新对象作为最终结果，新对象会覆盖预设的 alias 对象。\n\n\n\n\n精确匹配#\n\n默认情况，source.alias 会自动匹配子路径，比如以下配置：\n\n\n\n它的匹配结果如下：\n\n\n\n你可以添加 $ 符号来开启精确匹配，开启后将不会自动匹配子路径。\n\n\n\n它的匹配结果如下：\n\n\n\n\n处理 npm 包#\n\n你可以使用 alias 将某个 npm 包指向统一的目录。\n\n比如项目中安装了多份 react，你可以将 react 统一指向根目录的 node_modules 中安装的版本，避免出现打包多份 React 代码的问题。\n\n\n\n当你在使用 alias 处理 npm 包时，请留意项目中是否使用了这个包不同的 major 版本。\n\n比如你的项目中某个模块或 npm 依赖使用了 React 18 的 API，如果你将 React alias 到 17 版本，就会导致该模块无法引用到\nReact 18 的 API，导致代码异常。\n\n\nsource.aliasStrategy#\n\n * 类型： 'prefer-tsconfig' | 'prefer-alias'\n * 默认值： 'prefer-tsconfig'\n\nsource.aliasStrategy 用于控制 tsconfig.json 中的 paths 选项与打包工具的 alias 选项的优先级。\n\n\nprefer-tsconfig#\n\nsource.aliasStrategy 默认为 'prefer-tsconfig'，此时 tsconfig.json 中的 paths 选项和打包工具的\nalias 选项都会生效，但 tsconfig paths 选项的优先级更高。\n\n比如同时配置以下内容：\n\n * tsconfig paths:\n\n\n\n * source.alias:\n\n\n\n由于 tsconfig paths 的优先级更高，所以：\n\n * @common 会使用 tsconfig paths 定义的值，指向 ./src/common-1\n * @utils 会使用 source.alias 定义的值，指向 ./src/utils\n\n\nprefer-alias#\n\n当 source.aliasStrategy 的值为 prefer-alias 时，tsconfig.json 中的 paths 选项只用于提供\nTypeScript 类型定义，而不会对打包结果产生任何影响。此时，构建工具只会读取 alias 选项作为路径别名。\n\n\n\n比如同时配置以下内容：\n\n * tsconfig paths:\n\n\n\n * source.alias:\n\n\n\n由于 tsconfig paths 只用于提供类型，所以最终只有 @common 别名生效，并指向 ./src/common-2 目录。\n\n大部分情况下你不需要使用 prefer-alias，但当你需要动态生成一些别名配置时，可以考虑使用它。比如，基于环境变量来生成 alias 选项：\n\n\n\n\nsource.include#\n\n * 类型： RuleSetCondition[]\n * 默认值：\n\n\n\nsource.include 用于指定额外需要编译的 JavaScript 文件。\n\n为了避免二次编译，默认情况下，Rsbuild 只会编译当前目录下的 JavaScript 文件，以及所有目录下的 TypeScript 和 JSX\n文件，不会编译 node_modules 下的 JavaScript 文件。\n\n通过 source.include 配置项，可以指定需要 Rsbuild 额外进行编译的目录或模块。source.include 的用法与 Rspack 中的\nRule.include 一致，支持传入字符串、正则表达式来匹配模块的路径。\n\n比如:\n\n\n\n\n编译 npm 包#\n\n比较典型的使用场景是编译 node_modules 下的 npm 包，因为某些第三方依赖存在 ES6+\n的语法，这可能导致在低版本浏览器上无法运行，你可以通过该选项指定需要编译的依赖，从而解决此类问题。\n\n以 query-string 为例，你可以做如下的配置：\n\n\n\n上述两种方法分别通过 \"路径前缀\" 和 \"正则表达式\"\n来匹配文件的绝对路径，值得留意的是，项目中所有被引用的模块都会经过匹配，因此你不能使用过于松散的值进行匹配，避免造成编译性能问题或编译异常。\n\n\n编译 npm 包的子依赖#\n\n当你通过 source.include 编译一个 npm 包时，Builder 默认只会编译匹配到的模块，不会编译对应模块的子依赖。\n\n以 query-string 为例，它依赖的 decode-uri-component 包中同样存在 ES6+ 代码，因此你需要将\ndecode-uri-component 也加入到 source.include 中：\n\n\n\n\n编译 Monorepo 中的其他库#\n\n在 Monorepo 中进行开发时，如果需要引用 Monorepo 中其他库的源代码，也可以直接在 source.include 进行配置:\n\n\n\n\n编译 CommonJS 模块#\n\nBabel 默认无法编译 CommonJS 模块，如果你编译了一个 CommonJS 模块，可能会出现 exports is not defined\n的运行时报错信息。\n\n当你需要使用 source.include 来编译 CommonJS 模块时，可以将 Babel 的 sourceType 配置设置为 unambiguous：\n\n\n\n将 sourceType 设置为 unambiguous 可能会产生一些其他影响，请参考 Babel 官方文档。\n\n\n匹配 Symlink#\n\n如果你匹配的模块是通过 symlink 链接到当前项目中的，那么需要匹配这个模块的真实路径，而不是 symlink 后的路径。\n\n比如，你将 Monorepo 中的 packages/foo 路径 symlink 到当前项目的 node_modules/foo 路径下，则需要去匹配\npackages/foo 路径，而不是 node_modules/foo 路径。\n\n该行为可以通过 webpack 的 resolve.symlinks 配置项来进行控制。\n\n\n注意事项#\n\n注意，source.include 不应该被用于编译整个 node_modules 目录，比如下面的写法是错误的：\n\n\n\n如果你对整个 node_modules 进行编译，不仅会使编译时间大幅度增加，并且可能会产生不可预期的错误。因为 node_modules 中的大部分 npm\n包发布的已经是编译后的产物，通常没必要经过二次编译。此外，core-js 等 npm 包被编译后可能会出现异常。\n\n\nsource.exclude#\n\n * 类型： Array\n * 默认值： []\n\n指定不需要编译的 JavaScript/TypeScript 文件。用法与 webpack 中的 Rule.exclude\n一致，支持传入字符串或正则表达式来匹配模块的路径。\n\n比如:\n\n\n\n\nsource.define#\n\n * 类型： Record\n * 默认值： {}\n\n构建时将代码中的变量替换成其它值或者表达式，可以用于在代码逻辑中区分开发环境与生产环境等场景。\n\n传入的配置对象的键名是需要替换变量的名称，或者是用 . 连接的多个标识符，配置项的值则根据类型进行不同的处理：\n\n * 字符串会被当作代码片段。\n * 包括函数在内的其他类型会被转换成字符串。\n * 嵌套对象的父子键名之间会用 . 连接作为需要替换的变量名。\n * 以 typeof 开头的键名会用来替换 typeof 调用。\n\n更多细节参考 webpack - DefinePlugin。\n\nTIP\n\n在使用 Rspack 作为打包工具时，支持的类型可参考 Rspack.builtins.define\n\n\n示例#\n\n\n\n表达式会被替换为对应的代码段：\n\n\n\n\nsource.globalVars#\n\n * 类型： Record | Function\n * 默认值：\n\n\n\n用于在构建时将类似 process.env.FOO 的全局变量表达式替换为指定的值，比如：\n\n\n\n\n示例#\n\n在下方示例中，会在代码中注入 ENABLE_VCONSOLE 和 APP_CONTEXT 两个环境变量：\n\n\n\n你可以在代码中直接使用它们：\n\n\n\n\n函数用法#\n\n * 类型：\n\n\n\n你可以将 source.globalVars 设置为一个函数，从而动态设置一些环境变量的值。\n\n比如，根据当前的构建产物类型进行动态设置：\n\n\n\n\n与 define 的区别#\n\nsource.globalVars 是 source.define 的一个语法糖，它们之间唯一的区别是，source.globalVars 会自动将传入的值进行\nJSON 序列化处理，这使得设置全局变量的值更加方便。注意 globalVars 的每个值都需要是可以被 JSON 序列化的值。\n\n\n\n\n注意事项#\n\nsource.globalVars 是通过字符串替换的形式来注入环境变量的，因此它无法对「解构赋值」等动态写法生效。\n\n在使用解构赋值时，Builder 将无法判断变量 NODE_ENV 是否与要替换的表达式 process.env.NODE_ENV\n存在关联，因此以下使用方式是无效的：\n\n\n\n\nsource.moduleScopes#\n\n * 类型： Array | Function\n * 默认值： undefined\n * 打包工具： 仅支持 webpack\n\n限制源代码的引用路径。配置该选项后，所有源文件只能从约定的目录下引用代码，从其他目录引用代码会产生对应的报错提示。\n\n\n示例#\n\n首先我们配置 moduleScopes 仅包含 src 目录：\n\n\n\n然后在 src/App.tsx 中导入 src 目录外部的 utils/a 模块:\n\n\n\n在编译时，会提示引用路径错误:\n\n\n\n通过该选项配置 utils 目录，再进行编译，则不会出现错误提示。\n\n\n\n\nArray 类型#\n\n当 moduleScopes 的值为 Array 类型时，可以直接设置若干个代码路径，比如添加以下配置：\n\n\n\n\nFunction 类型#\n\nmoduleScopes 也支持通过函数的形式来进行修改，避免覆盖默认值：\n\n\n\n\nsource.transformImport#\n\n用于按需引入组件库的代码和样式，能力等价于 babel-plugin-import。\n\n它与 babel-plugin-import 的区别在于，source.transformImport 不与 Babel 耦合。Builder\n会自动识别当前使用的编译工具是 Babel、SWC 还是 Rspack，并添加相应的按需引入配置。\n\n * 类型：\n\n\n\n * 默认值：\n\n当项目中安装了 Ant Design 组件库 <= 4.x 版本时，Builder 会自动添加以下默认配置：\n\n\n\n当项目中安装了 Arco Design 组件库 时，Builder 会自动添加以下默认配置：\n\n\n\nTIP\n\n当你添加了 antd 或 @arco-design/web-react 相关的配置时，优先级会高于上述默认配置。\n\n\n示例#\n\n当使用上述 antd 默认配置：\n\n\n\n源代码如下：\n\n\n\n会被转换成：\n\n\n\n\n禁用默认配置#\n\n你可以手动设置 transformImport: false 来关掉 transformImport 的默认行为。\n\n\n\n比如，当你使用了 externals 来避免打包 antd 时，由于 transformImport 默认会转换 antd\n的引用路径，导致匹配的路径发生了变化，因此 externals 无法正确生效，此时你可以设置关闭 transformImport 来避免该问题。\n\n\n配置#\n\nlibraryName#\n\n * 类型： string\n\n用于指定需要按需加载的模块名称。当 Builder 遍历代码时，如果遇到了对应模块的 import 语句，则会对其进行转换。\n\nlibraryDirectory#\n\n * 类型： string\n * 默认值： 'lib'\n\n用于拼接转换后的路径，拼接规则为 ${libraryName}/${libraryDirectory}/${member}，其中 member 为引入成员。\n\n示例：\n\n\n\n转换结果:\n\n\n\nstyle#\n\n * 类型： boolean\n * 默认值： undefined\n\n确定是否需要引入相关样式，若为 true，则会引入路径 ${libraryName}/${libraryDirectory}/${member}/style。\n若为 false 或 undefined 则不会引入样式。\n\n当配置为 true 时：\n\n\n\n转换结果:\n\n\n\nstyleLibraryDirectory#\n\n * 类型： string\n * 默认值： undefined\n\n该配置用于拼接引入样式时的引入路径，若该配置被指定，则 style 配置项会被忽略。拼接引入路径为\n${libraryName}/${styleLibraryDirectory}/${member}。\n\n当配置为 styles 时：\n\n\n\n转换结果:\n\n\n\ncamelToDashComponentName#\n\n * 类型： boolean\n * 默认值： true\n\n是否需要将 camelCase 的引入转换成 kebab-case。\n\n示例：\n\n\n\n转换结果：\n\n\n\ntransformToDefaultImport#\n\n * 类型： boolean\n * 默认值： true\n\n是否将导入语句转换成默认导入。\n\n示例：\n\n\n\n转换结果：\n\n\n\ncustomName#\n\n * 类型： ((member: string) => string | undefined) | string\n * 默认值： undefined\n\n注意\n * 函数类型的配置只能在 Webpack 构建中使用。\n * 模版类型的配置只能在 Rspack 构建或者使用了 SWC 的 Webpack 构建中使用。\n\n自定义转换后的导入路径，输入是引入的成员，例如配置成 (member) => `my-lib/${member}` ，会将 转换成 。\n\n在使用 Rspack 构建时，不能使用函数配置，但可以使用 handlebars 模版字符串，对于上面的函数配置，在使用模版字符串时可以用以下模版代替\nmy-lib/{{ member }}，也可以使用一些内置帮助方法，例如 my-lib/{{ kebabCase member }} 来转换成\nkebab-case 格式，除了 kebabCase 以外还有 camelCase，snakeCase，upperCase，lowerCase 可以使用。\n\ncustomStyleName#\n\n * 类型： ((member: string) => string | undefined) | string\n * 默认值： undefined\n\n注意\n * 函数类型的配置只能在 Webpack 构建中使用。\n * 模版类型的配置只能在 Rspack 构建或者使用了 SWC 的 Webpack 构建中使用。\n\n自定义转换后的样式导入路径，输入是引入的成员，例如配置成 (member) => `my-lib/${member}` ，会将 转换成 。\n\n在使用 Rspack 构建时，不能使用函数配置，但可以使用 handlebars 模版字符串，对于上面的函数配置，在使用模版字符串时可以用以下模版代替\nmy-lib/{{ member }}，也可以使用一些内置帮助方法，例如 my-lib/{{ kebabCase member }} 来转换成\nkebab-case 格式，除了 kebabCase 以外还有 camelCase，snakeCase，upperCase，lowerCase 可以使用。\n\n\nsource.preEntry#\n\n * 类型： string | string[]\n * 默认值： undefined\n\n在每个页面的入口文件前添加一段代码，这段代码会早于页面的代码执行，因此可以用于执行一些全局的代码逻辑，比如注入 polyfill、设置全局样式等。\n\n添加单个脚本#\n\n首先创建一个 src/polyfill.ts 文件：\n\n\n\n然后将 src/polyfill.ts 配置到 source.preEntry 上：\n\n\n\n重新运行编译并访问任意页面，可以看到 src/polyfill.ts 中的代码已经执行，并在 console 中输出了对应的内容。\n\n添加全局样式#\n\n你也可以通过 source.preEntry 来配置全局样式，这段 CSS 代码会早于页面代码加载，比如引入一个 normalize.css 文件：\n\n\n\n添加多个脚本#\n\n你可以将 preEntry 设置为数组来添加多个脚本，它们会按数组顺序执行：\n\n\n\n\nsource.resolveExtensionPrefix#\n\n * 类型： string | Record\n * 默认值： undefined\n\n用于为 resolve.extensions 添加统一的前缀。\n\n如果多个文件拥有相同的名称，但具有不同的文件后缀，Builder 会根据 extensions\n数组的顺序进行识别，解析数组中第一个被识别的文件，并跳过其余文件。\n\n\n示例#\n\n下面是配置 .web 前缀的例子。\n\n\n\n配置完成后，extensions 数组会发生以下变化：\n\n\n\n在代码中 import './foo' 时，会优先识别 foo.web.js 文件，再识别 foo.js 文件。\n\n根据产物类型设置#\n\n当你同时构建多种类型的产物时，你可以为不同的产物类型设置不同的 extension 前缀。此时，你需要把 resolveExtensionPrefix\n设置为一个对象，对象的 key 为对应的产物类型。\n\n比如为 web 和 node 设置不同的 extension 前缀：\n\n\n\n在代码中 import './foo' 时，对于 node 产物，会优先识别 foo.node.js 文件，而对于 web 产物，则会优先识别\nfoo.web.js 文件。\n\n\nsource.resolveMainFields#\n\n * 类型：\n\n\n\n * 默认值： undefined\n\n该配置项将决定你使用 package.json 哪个字段导入 npm 模块。对应 webpack 的 resolve.mainFields 配置。\n\n\n示例#\n\n\n\n根据产物类型设置#\n\n当你同时构建多种类型的产物时，你可以为不同的产物类型设置不同的 mainFields。此时，你需要把 resolveMainFields 设置为一个对象，对象的\nkey 为对应的产物类型。\n\n比如为 web 和 node 设置不同的 mainFields：\n\n","routePath":"/builder/api/config-source","lang":"zh","toc":[{"text":"source.alias","id":"sourcealias","depth":2,"charIndex":38},{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":271},{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":407},{"text":"精确匹配","id":"精确匹配","depth":3,"charIndex":510},{"text":"处理 npm 包","id":"处理-npm-包","depth":3,"charIndex":618},{"text":"source.aliasStrategy","id":"sourcealiasstrategy","depth":2,"charIndex":894},{"text":"prefer-tsconfig","id":"prefer-tsconfig","depth":3,"charIndex":1060},{"text":"prefer-alias","id":"prefer-alias","depth":3,"charIndex":1384},{"text":"source.include","id":"sourceinclude","depth":2,"charIndex":1737},{"text":"编译 npm 包","id":"编译-npm-包","depth":3,"charIndex":2076},{"text":"编译 npm 包的子依赖","id":"编译-npm-包的子依赖","depth":3,"charIndex":2323},{"text":"编译 Monorepo 中的其他库","id":"编译-monorepo-中的其他库","depth":3,"charIndex":2520},{"text":"编译 CommonJS 模块","id":"编译-commonjs-模块","depth":3,"charIndex":2615},{"text":"匹配 Symlink","id":"匹配-symlink","depth":3,"charIndex":2861},{"text":"注意事项","id":"注意事项","depth":3,"charIndex":3105},{"text":"source.exclude","id":"sourceexclude","depth":2,"charIndex":3312},{"text":"source.define","id":"sourcedefine","depth":2,"charIndex":3451},{"text":"示例","id":"示例","depth":3,"charIndex":3797},{"text":"source.globalVars","id":"sourceglobalvars","depth":2,"charIndex":3824},{"text":"示例","id":"示例-1","depth":3,"charIndex":3930},{"text":"函数用法","id":"函数用法","depth":3,"charIndex":4010},{"text":"与 define 的区别","id":"与-define-的区别","depth":3,"charIndex":4101},{"text":"注意事项","id":"注意事项-1","depth":3,"charIndex":4266},{"text":"source.moduleScopes","id":"sourcemodulescopes","depth":2,"charIndex":4422},{"text":"示例","id":"示例-2","depth":3,"charIndex":4568},{"text":"Array 类型","id":"array-类型","depth":3,"charIndex":4710},{"text":"Function 类型","id":"function-类型-1","depth":3,"charIndex":4778},{"text":"source.transformImport","id":"sourcetransformimport","depth":2,"charIndex":4834},{"text":"示例","id":"示例-3","depth":3,"charIndex":5217},{"text":"禁用默认配置","id":"禁用默认配置","depth":3,"charIndex":5263},{"text":"配置","id":"配置","depth":3,"charIndex":5470},{"text":"libraryName","id":"libraryname","depth":4,"charIndex":5475},{"text":"libraryDirectory","id":"librarydirectory","depth":4,"charIndex":5568},{"text":"style","id":"style","depth":4,"charIndex":5712},{"text":"styleLibraryDirectory","id":"stylelibrarydirectory","depth":4,"charIndex":5890},{"text":"camelToDashComponentName","id":"cameltodashcomponentname","depth":4,"charIndex":6076},{"text":"transformToDefaultImport","id":"transformtodefaultimport","depth":4,"charIndex":6184},{"text":"customName","id":"customname","depth":4,"charIndex":6273},{"text":"customStyleName","id":"customstylename","depth":4,"charIndex":6741},{"text":"source.preEntry","id":"sourcepreentry","depth":2,"charIndex":7217},{"text":"添加单个脚本","id":"添加单个脚本","depth":4,"charIndex":7354},{"text":"添加全局样式","id":"添加全局样式","depth":4,"charIndex":7506},{"text":"添加多个脚本","id":"添加多个脚本","depth":4,"charIndex":7593},{"text":"source.resolveExtensionPrefix","id":"sourceresolveextensionprefix","depth":2,"charIndex":7645},{"text":"示例","id":"示例-4","depth":3,"charIndex":7836},{"text":"根据产物类型设置","id":"根据产物类型设置","depth":4,"charIndex":7951},{"text":"source.resolveMainFields","id":"sourceresolvemainfields","depth":2,"charIndex":8192},{"text":"示例","id":"示例-5","depth":3,"charIndex":8324},{"text":"根据产物类型设置","id":"根据产物类型设置-1","depth":4,"charIndex":8331}],"domain":"","frontmatter":{"extractApiHeaders":[2]},"version":""},{"id":60,"title":"Tools Config","content":"#\n\n本章节描述了 Builder 中与底层工具有关的配置。\n\n\ntools.autoprefixer#\n\n * 类型： Object | Function\n * 默认值：\n\n\n\n通过 tools.autoprefixer 可以修改 autoprefixer 的配置。\n\n\nObject 类型#\n\n当 tools.autoprefixer 的值为 Object 类型时，会与默认配置通过 Object.assign 合并。比如：\n\n\n\n\nFunction 类型#\n\n当 tools.autoprefixer 为 Function 类型时，默认配置作为第一个参数传入，可以直接修改配置对象，也可以返回一个值作为最终结果。比如：\n\n\n\n\ntools.babel#\n\n * 类型： Object | Function\n * 默认值： undefined\n\n通过 tools.babel 可以修改 babel-loader 的配置项。\n\n\n使用场景#\n\n请留意 tools.babel 在以下使用场景中的局限性：\n\n * Rspack 场景：在使用 Rspack 作为打包工具时，使用 tools.babel 配置项将会明显拖慢 Rspack 构建速度。因为 Rspack\n   默认使用的是 SWC 编译，配置 Babel 会导致代码需要被编译两次，产生了额外的编译开销。\n * webpack + SWC 场景：在使用 webpack 作为打包工具时，如果你使用了 Builder 的 SWC 插件进行代码编译，那么\n   tools.babel 选项将不会生效。\n\n\nFunction 类型#\n\n当 tools.babel 为 Function 类型时，默认 Babel 配置会作为第一个参数传入，你可以直接修改配置对象，也可以返回一个对象作为最终的\nbabel-loader 配置。\n\n\n\ntools.babel 函数的第二个参数提供了一些方便的工具函数，请继续阅读下方文档。\n\nTIP\n\n以上示例仅作为参考，通常来说，你不需要手动配置 babel-plugin-import，因为 Builder 已经提供了更通用的\nsource.transformImport 配置。\n\n\nObject 类型#\n\n当 tools.babel 的值为 Object 类型时，会与默认配置通过 Object.assign 浅合并。\n\nCAUTION\n\nObject.assign 是浅拷贝，会完全覆盖内置的 presets 或 plugins 数组，导致内置的 presets 或 plugins\n失效，请在明确影响面的情况下再使用这种方式。\n\n\n\n\n工具函数#\n\ntools.babel 为 Function 类型时，第二个参数可用的工具函数如下:\n\naddPlugins#\n\n * 类型： (plugins: BabelPlugin[]) => void\n\n添加若干个 Babel 插件。\n\n\n\naddPresets#\n\n * 类型： (presets: BabelPlugin[]) => void\n\n添加若干个 Babel 预设配置 (大多数情况下不需要增加预设)。\n\n\n\nremovePlugins#\n\n * 类型： (plugins: string | string[]) => void\n\n移除 Babel 插件，传入需要移除的插件名称即可，你可以传入单个字符串，也可以传入一个字符串数组。\n\n\n\nremovePresets#\n\n * 类型： (presets: string | string[]) => void\n\n移除 Babel 预设配置，传入需要移除的预设名称即可，你可以传入单个字符串，也可以传入一个字符串数组。\n\n\n\nmodifyPresetEnvOptions#\n\n * 类型： (options: PresetEnvOptions) => void\n\n修改 @babel/preset-env 的配置项，传入的配置会与默认配置进行浅层合并，比如:\n\n\n\nmodifyPresetReactOptions#\n\n * 类型： (options: PresetReactOptions) => void\n\n修改 @babel/preset-react 的配置项，传入的配置会与默认配置进行浅层合并，比如:\n\n\n\naddIncludes#\n\n已废弃，请使用 source.include 代替，两者功能完全一致。\n\naddExcludes#\n\n已废弃，请使用 source.exclude 代替，两者功能完全一致。\n\n\n调试 Babel 配置#\n\n当你通过 tools.babel 修改 babel-loader 配置后，可以在 Builder 调试模式 下查看最终生成的配置。\n\n首先通过 DEBUG=builder 参数开启调试模式：\n\n\n\n然后打开生成的 (webpack|rspack).config.web.js，搜索 babel-loader 关键词，即可看到完整的 babel-loader\n配置内容。\n\n\ntools.bundlerChain#\n\n * 类型： Function | undefined\n * 默认值： undefined\n\n你可以通过 tools.bundlerChain 来修改默认的 webpack 和 Rspack 配置，它的值为 Function 类型，接收两个参数：\n\n * 第一个参数为 bundler-chain 对象实例，你可以通过这个实例来修改 webpack 和 Rspack 的配置。\n * 第二个参数为一个工具集合，包括env、isProd、CHAIN_ID 等。\n\n什么是 BundlerChain\n\nBundler chain 是 webpack chain 的子集，其中包含一部分 webpack chain API，你可以用它来同时修改 webpack 和\nRspack 的配置。\n\n通过 bundler chain 修改的配置，在 webpack 和 Rspack 构建时均可生效。需要注意的是，bundler chain 只支持修改\nwebpack 和 Rspack 间无差异部分的配置。如，修改 devtool 配置项(webpack 和 Rspack 的 devtool\n属性值类型相同)，或添加一个Rspack 兼容的 webpack 插件。\n\n> tools.bundlerChain 的执行时机早于 tools.webpackChain / tools.webpack /\n> tools.rspack，因此会被其他几个配置中的修改所覆盖。\n\n更多信息可参考 Rsbuild#tools.bundlerChain\n\n\ntools.cssExtract#\n\n * 类型： Object | Function\n * 默认值：\n\n\n\n * 打包工具： 仅支持 webpack\n\n通过 tools.cssExtract 可以更改 mini-css-extract-plugin 的配置。\n\n\nObject 类型#\n\n当此值为 Object 类型时，与默认配置通过 Object.assign 合并。比如：\n\n\n\n\nFunction 类型#\n\n当此值为 Function 类型时，默认配置作为第一个参数传入，你可以直接修改配置对象，也可以返回一个对象作为最终配置。比如：\n\n\n\n更多配置细节可参考 mini-css-extract-plugin。\n\n\ntools.cssLoader#\n\n * 类型： Object | Function\n * 默认值： undefined\n\n通过 tools.cssLoader 可以修改 css-loader 的配置项。默认配置如下:\n\n\n\nTIP\n\n在使用 Rspack 作为打包工具时，仅支持在 disableCssExtract 时使用该配置。\n\n修改 CSS Modules 相关配置，推荐使用 output.cssModules 配置项。\n\n\nObject 类型#\n\n当此值为 Object 类型时，会与默认配置进行深层合并 (deep merge)。比如：\n\n\n\n\nFunction 类型#\n\n当此值为 Function 类型时，默认配置作为第一个参数传入，你可以直接修改配置对象，也可以返回一个对象作为最终配置。比如：\n\n\n\n\ntools.devServer#\n\n * 类型： Object\n * 默认值： {}\n\n通过 tools.devServer 可以修改开发环境服务器的配置。\n\nTIP\n\nModern.js 中并没有直接使用 webpack-dev-server 或 @rspack/dev-server, 而是基于\nwebpack-dev-middleware 实现 DevServer。\n\n\n选项#\n\nafter#\n\n * 类型： Array\n * 默认值： []\n\n添加自定义中间件，在所有开发环境中间件后执行。\n\n\n\nwebpack-dev-server 使用 Express 作为服务端框架。Modern.js 中没有使用任何框架，上述中间件中 req 和 res 都是\nNode 原生对象，因此 webpack-dev-server 的 Express 中间件不一定能直接在 Modern.js 中使用。\n\n如果要迁移 webpack-dev-server 中使用的 Express 中间件，可以使用以下方式，将 Express app 作为中间件传入：\n\n\n\nbefore#\n\n * 类型： Array\n * 默认值： []\n\n添加自定义中间件，在所有开发环境中间件前执行。\n\n\n\nclient#\n\n * 类型：\n\n\n\n * 默认值：\n\n\n\n对应 HMR 客户端的配置，通常用于设置 HMR 对应的 WebSocket URL。\n\ncompress#\n\n * 类型： boolean\n * 默认值： true\n\n是否对静态资源启用 gzip 压缩。\n\n如果你需要禁用 gzip 压缩，可以将 compress 设置为 false：\n\n\n\ndevMiddleware#\n\n * 类型：\n\n\n\n * 默认值：\n\n\n\ndevMiddleware 配置项。当前配置是 webpack-dev-middleware 配置项的子集.\n\nheaders#\n\n * 类型： Record\n * 默认值： undefined\n\n设置自定义响应头。\n\n\n\nhistoryApiFallback#\n\n * 类型： boolean | ConnectHistoryApiFallbackOptions\n * 默认值： false\n\n在需要对一些 404 响应或其他请求提供替代页面的场景，可通过 devServer.historyApiFallback 进行设置：\n\n\n\n更多选项和详细信息可参考 connect-history-api-fallback 文档。\n\nhot#\n\n * 类型： boolean\n * 默认值： true\n\n是否开启 Hot Module Replacement 热更新能力。\n\nhttps#\n\n * 类型： boolean | { key: string; cert: string }\n * 默认值： false\n\n默认情况下，DevServer 会启用 HTTP 服务器。通过设置 devServer.https 为 true 将开启对 HTTPS 的支持，同时会禁用\nHTTP 服务器。\n\n你也可以手动传入 HTTPS 服务器所需要的证书和对应的私钥：\n\n\n\nliveReload#\n\n * 类型： boolean\n * 默认值： true\n\n默认情况下，当监听到文件变化时，DevServer 将会刷新页面（为使 liveReload 能够生效，devServer.hot 配置项应当禁用）。通过设置\ndevServer.liveReload 为 false 可以关闭该行为。\n\nsetupMiddlewares#\n\n * 类型：\n\n\n\n * 默认值： undefined\n\n提供执行自定义函数和应用自定义中间件的能力。\n\n几种不同中间件之间的执行顺序是: devServer.before => unshift => 内置中间件 => push =>\ndevServer.after。\n\n\n\n一些特殊场景需求可能需要使用服务器 API：\n\n * sockWrite。允许向 hmr 客户端传递一些消息，hmr 客户端将根据接收到的消息类型进行不同的处理。如果你发送一个\n   \"content-changed \" 的消息，页面将会重新加载。\n\n\n\nproxy#\n\n * 类型： Record | Record\n * 默认值： undefined\n\n代理请求到指定的服务上。\n\n\n\n此时，/api/users 请求将会代理到 http://localhost:3000/api/users。\n\n如果你不想传递 /api，可以通过 pathRewrite 重写请求路径：\n\n\n\nDevServer Proxy 基于 http-proxy-middleware 实现。你可以使用 http-proxy-middleware\n的所有配置项，具体可以查看文档。\n\nDevServer Proxy 完整类型定义为：\n\n\n\n除了 http-proxy-middleware 的选项外，还支持 bypass 和 context 两个配置项：\n\n * bypass：根据函数的返回值绕过代理。\n   * 返回 null 或 undefined 会继续用代理处理请求。\n   * 返回 false 会返回 404 错误。\n   * 返回一个具体的服务路径，将会使用此路径替代原请求路径。\n * context：如果你想代理多个特定的路径到同一个目标，你可以使用 context 配置项。\n\n\n\n\n\nwatch#\n\n * 类型： boolean\n * 默认值： true\n\n是否监听 mock/、server/、api/ 等目录的文件变化。\n\n\ntools.htmlPlugin#\n\n * 类型： false | Object | Function\n * 默认值：\n\n\n\n通过 tools.htmlPlugin 可以修改 html-webpack-plugin 或 @rspack/plugin-html 的配置项。\n\n\nObject 类型#\n\n当 tools.htmlPlugin 的值为 Object 类型时，会与默认配置通过 Object.assign 合并。\n\n\n\n\nFunction 类型#\n\n当 tools.htmlPlugin 为 Function 类型时：\n\n * 第一个参数是默认配置的对象，可以直接修改该对象。\n * 第二个参数是也是一个对象，包含了 entry 的名称和 entry 的值。\n * 函数可以 return 一个新的对象作为最终的配置。\n\n\n\n\nBoolean 类型#\n\n将 tools.htmlPlugin 配置为 false，可以禁用默认的 html-webpack-plugin 插件。\n\n\n\n\n禁用 JS / CSS 压缩#\n\n默认情况下，Builder 会在生产环境构建时压缩 HTML 内的 JavaScript / CSS\n代码，从而提升页面性能。此能力通常在使用自定义模版或插入自定义脚本时会有帮助。然而，当开启 output.enableInlineScripts 或\noutput.enableInlineStyles 时，会出现对 inline JavaScript / CSS\n代码重复压缩的情况，对构建性能会有一定影响。你可以通过修改 tools.htmlPlugin.minify 配置项来修改默认的压缩行为。\n\n\n\n\ntools.less#\n\n * 类型： Object | Function\n * 默认值：\n\n\n\n你可以通过 tools.less 修改 less-loader 的配置。\n\n\nObject 类型#\n\n当 tools.less 的值为 Object 类型时，会与默认配置通过 Object.assign 进行浅层合并，值得注意的是，lessOptions 会通过\ndeepMerge 进行深层合并。\n\n\n\n\nFunction 类型#\n\n当 tools.less 为 Function\n类型时，默认配置作为第一个参数传入，可以直接修改配置对象，也可以返回一个值作为最终结果，第二个参数提供了一些可以直接调用的工具函数：\n\n\n\n\n修改 Less 版本#\n\n在某些场景下，如果你需要使用特定的 Less 版本，而不是使用 Builder 内置的 Less v4，可以在项目中安装需要使用的 Less 版本，并通过\nless-loader 的 implementation 选项设置。\n\n\n\n\n工具函数#\n\naddExcludes#\n\n * 类型： (excludes: RegExp | RegExp[]) => void\n\n用来指定 less-loader 不编译哪些文件，你可以传入一个或多个正则表达式来匹配 less 文件的路径。例如：\n\n\n\n\ntools.minifyCss#\n\n * 类型： Object | Function | undefined\n * 默认值：\n\n\n\n在生产环境构建时，Builder 会通过 css-minimizer-webpack-plugin 对 CSS 代码进行压缩优化。可以通过\ntools.minifyCss 修改 css-minimizer-webpack-plugin 的配置。\n\n\nObject 类型#\n\n当 tools.minifyCss 的值为 Object 类型时，会与默认配置通过 Object.assign 合并。\n\n例如下面修改 cssnano 的 preset 配置：\n\n\n\n\nFunction 类型#\n\n当 tools.minifyCss 配置为 Function 类型时，默认配置作为第一个参数传入，可以直接修改配置对象，也可以返回一个值作为最终结果。\n\n\n\n\ntools.postcss#\n\n * 类型： Object | Function\n * 默认值：\n\n\n\nBuilder 默认集成 PostCSS，你可以通过 tools.postcss 对 postcss-loader 进行配置。\n\n\nFunction 类型#\n\n值为 Function 类型时，内部默认配置作为第一参数传入，可以直接修改配置对象不做返回，也可以返回一个对象作为最终结果；第二个参数为修改\npostcss-loader 配置的工具函数集合。\n\n例如，需要在原有插件的基础上新增一个 PostCSS 插件，在 postcssOptions.plugins 数组中 push 一个新的插件即可：\n\n\n\n需要给 PostCSS 插件传递参数时，可以通过函数参数的形式进行传入：\n\n\n\ntools.postcss 可以返回一个配置对象，并完全替换默认配置：\n\n\n\n\nObject 类型#\n\n当此值为 Object 类型时，与默认配置通过 Object.assign 合并。注意 Object.assign 是浅拷贝，会完全覆盖内置的 plugins\n数组，请谨慎使用。\n\n\n\n\n工具函数#\n\naddPlugins#\n\n * 类型： (plugins: PostCSSPlugin | PostCSSPlugin[]) => void\n\n用于添加额外的 PostCSS 插件，你可以传入单个 PostCSS 插件，也可以传入 PostCSS 插件数组。\n\n\n\nTIP\n\nBuilder 中使用的 PostCSS 版本为 v8，当你引入社区中的 PostCSS 插件时，请注意版本是否适配，部分旧版本插件可能无法在 PostCSS\nv8 下运行。\n\n\ntools.pug#\n\n * 类型： true | Object | Function | undefined\n * 默认值： false\n\n配置 Pug 模板引擎。\n\n\nBoolean 类型#\n\nBuilder 默认不启用 Pug 模板引擎，你可以将 tools.pug 设置为 true 来启用它。\n\n\n\n启用后，你可以在 html.template 中指定使用 index.pug 作为模板文件。\n\n\nObject 类型#\n\n当 tools.terser 的值为 Object 类型时，可以配置 Pug 模板引擎的选项：\n\n\n\n详细参数请查看 Pug API Reference。\n\n\nFunction 类型#\n\n当 tools.pug 配置为 Function 类型时，默认配置作为第一个参数传入，可以直接修改配置对象，也可以返回一个值作为最终结果。\n\n\n\n\ntools.sass#\n\n * 类型： Object | Function\n * 默认值：\n\n\n\n你可以通过 tools.sass 修改 sass-loader 的配置。\n\n\nObject 类型#\n\n当 tools.sass 的值为 Object 类型时，会与默认配置通过 Object.assign 进行浅层合并，值得注意的是，sassOptions 会通过\ndeepMerge 进行深层合并。\n\n\n\n\nFunction 类型#\n\n当 tools.sass 为 Function\n类型时，默认配置作为第一个参数传入，可以直接修改配置对象，也可以返回一个值作为最终结果，第二个参数提供了一些可以直接调用的工具函数：\n\n\n\n\n修改 Sass 版本#\n\n在某些场景下，如果你需要使用特定的 Sass 版本，而不是使用 Builder 内置的 Dart Sass v1，可以在项目中安装需要使用的 Sass\n版本，并通过 sass-loader 的 implementation 选项设置。\n\n\n\n\n工具函数#\n\naddExcludes#\n\n * 类型： (excludes: RegExp | RegExp[]) => void\n\n用来指定 sass-loader 不编译哪些文件，你可以传入一个或多个正则表达式来匹配 sass 文件的路径。例如：\n\n\n\n\ntools.styleLoader#\n\n * 类型： Object | Function\n * 默认值： {}\n\n通过 tools.styleLoader 可以设置 style-loader 的配置项。\n\n值得注意的是，Builder 默认不会开启 style-loader，你可以通过 output.disableCssExtract 配置项来开启它。\n\n\nObject 类型#\n\n当此值为 Object 类型时，与默认配置通过 Object.assign 合并。比如：\n\n\n\n\nFunction 类型#\n\n当此值为 Function 类型时，默认配置作为第一个参数传入，你可以直接修改配置对象，也可以返回一个对象作为最终配置。比如：\n\n\n\n\ntools.styledComponents#\n\n * 类型： Object | Function | false\n * 默认值：\n\n\n\n对应 babel-plugin-styled-components 或使用 SWC 时 @swc/plugin-styled-components 的配置。\n值为 Object 类型时，利用 Object.assign 函数与默认配置合并。比如:\n\n\n\n值为 Function 类型时，第一个参数为默认配置，第二个参数提供了一些可以直接调用的工具函数：\n\n\n\n该特性默认启用，你可以配置 tools.styledComponents 为 false 来关闭该行为，关闭后可以提升编译性能：\n\n\n\n\ntools.terser#\n\n * 类型： Object | Function | undefined\n * 默认值：\n\n\n\n * 打包工具： 仅支持 webpack\n\n在生产环境构建时，Builder 会通过 terser-webpack-plugin 对 JavaScript 代码进行压缩优化。可以通过\ntools.terser 修改 terser-webpack-plugin 的配置。\n\n\nObject 类型#\n\n当 tools.terser 的值为 Object 类型时，会与默认配置通过 Object.assign 合并。\n\n例如通过 exclude 排除部分文件的压缩：\n\n\n\n\nFunction 类型#\n\n当 tools.terser 配置为 Function 类型时，默认配置作为第一个参数传入，可以直接修改配置对象，也可以返回一个值作为最终结果。\n\n\n\n禁用代码压缩\n\n如果你需要禁用代码压缩，可以使用 output.disableMinimize 配置项。\n\n\ntools.tsLoader#\n\n * 类型： Object | Function | undefined\n * 默认值： undefined\n * 打包工具： 仅支持 webpack\n\n不再推荐使用 ts-loader\n\n使用 babel-loader 或 Rspack 转译 TypeScript 代码的性能明显优于 ts-loader 且能够使用更多拓展能力。\n\n启用 ts-loader 时将无法使用 source.transformImport 和 tools.styledComponents 等由 Babel 和\nSWC 提供支持的能力。\n\n项目中默认不开启 ts-loader，当 tools.tsLoader 不为 undefined 则表示开启 ts-loader，同时禁用\nbabel-loader 对 TypeScript 的编译。\n\n\nObject 类型#\n\n当此值为 Object 类型时，与默认配置通过 Object.assign 合并。\n\n默认配置如下:\n\n\n\n你可以通过 tools.tsLoader 配置项来覆盖默认配置:\n\n\n\n\nFunction 类型#\n\n当此值为 Function 类型时，默认配置作为第一参数传入，可以直接修改配置对象，也可以返回一个对象作为最终配置；第二个参数为修改 ts-loader\n配置工具函数集合：\n\n\n\n\n工具函数#\n\naddIncludes#\n\n已废弃，请使用 source.include 代替，两者功能完全一致。\n\naddExcludes#\n\n已废弃，请使用 source.exclude 代替，两者功能完全一致。\n\n\ntools.tsChecker#\n\n * 类型： Object | Function\n * 默认值：\n\n\n\n默认情况下，Builder 会开启 fork-ts-checker-webpack-plugin 进行类型检查。你可以通过\noutput.disableTsChecker 配置项来关闭类型检查。\n\n\nObject 类型#\n\n当 tsChecker 的值为 Object 类型时，会与默认配置进行深层合并。\n\n\n\n\nFunction 类型#\n\n当 tsChecker 的值为 Function 类型时，默认配置会作为第一个参数传入，你可以直接修改配置对象，也可以返回一个对象作为最终配置。\n\n\n\n\ntools.webpack#\n\n * 类型： Object | Function | undefined\n * 默认值： undefined\n * 打包工具： 仅支持 webpack\n\ntools.webpack 选项用于配置原生的 webpack。\n\n> tools.bundlerChain 同样可以修改 webpack 配置，并且功能更加强大，建议优先使用 tools.bundlerChain。\n\n\nObject 类型#\n\ntools.webpack 可以配置为一个对象，这个对象将会和内置的 webpack 配置通过 webpack-merge 进行深层合并。\n\n比如添加 resolve.alias 配置：\n\n\n\n\nFunction 类型#\n\ntools.webpack 也可以配置为一个函数，这个函数的第一个入参为内置的 webpack 配置对象，你可以对这个对象进行修改，然后返回一份新的配置。比如：\n\n\n\nTIP\n\ntools.webpack 函数返回的对象会直接作为最终使用的 webpack 配置，不会再与内置的 webpack 配置进行合并。\n\n\n工具集合#\n\n这个函数的第二个参数是一个对象，包含了一些工具函数和属性，详情如下：\n\nenv#\n\n * 类型： 'development' | 'production' | 'test'\n\n通过 env 参数可以判断当前环境为 development、production 还是 test。比如：\n\n\n\nisProd#\n\n * 类型： boolean\n\n通过 isProd 参数可以判断当前环境是否为 production。比如：\n\n\n\ntarget#\n\n * 类型： 'web' | 'node' | 'modern-web' | 'web-worker'\n\n通过 target 参数可以判断当前构建的目标运行时环境。比如：\n\n\n\nisServer#\n\n * 类型： boolean\n\n判断当前构建的目标运行时环境是否为 node，等价于 target === 'node'。\n\n\n\nisWebWorker#\n\n * 类型： boolean\n\n判断当前构建的目标运行时环境是否为 web-worker，等价于 target === 'web-worker'。\n\n\n\nwebpack#\n\n * 类型： typeof import('webpack')\n\n通过这个参数你可以拿到 webpack 实例。比如：\n\n\n\nHtmlWebpackPlugin#\n\n * 类型： typeof import('html-webpack-plugin')\n\n通过这个参数你可以拿到 HtmlWebpackPlugin 实例。\n\n\n\naddRules#\n\n * 类型： (rules: RuleSetRule | RuleSetRule[]) => void\n\n添加额外的 webpack rules。\n\n示例：\n\n\n\nprependPlugins#\n\n * 类型： (plugins: WebpackPluginInstance | WebpackPluginInstance[]) => void\n\n在内部 webpack 插件数组头部添加额外的插件，数组头部的插件会优先执行。\n\n\n\nappendPlugins#\n\n * 类型： (plugins: WebpackPluginInstance | WebpackPluginInstance[]) => void\n\n在内部 webpack 插件数组尾部添加额外的插件，数组尾部的插件会在最后执行。\n\n\n\nremovePlugin#\n\n * 类型： (name: string) => void\n\n删除内部的 webpack 插件，参数为该插件的 constructor.name。\n\n例如，删除内部的 fork-ts-checker-webpack-plugin：\n\n\n\nmergeConfig#\n\n * 类型： (...configs: WebpackConfig[]) => WebpackConfig\n\n用于合并多份 webpack 配置，等价于 webpack-merge。\n\n\n\ngetCompiledPath#\n\n * 类型： (name: string) => string\n\n获取 builder 内置依赖的所在路径，等价于 webpackChain#getCompiledPath。\n\n\ntools.webpackChain#\n\n * 类型： Function | undefined\n * 默认值： undefined\n * 打包工具： 仅支持 webpack\n\n你可以通过 tools.webpackChain 来修改默认的 webpack 配置，它的值为 Function 类型，接收两个参数：\n\n * 第一个参数为 webpack-chain 对象实例，你可以通过这个实例来修改默认的 webpack 配置。\n * 第二个参数为一个工具集合，包括env、isProd、CHAIN_ID 等。\n\n相比于 tools.webpack，webpack-chain 不仅支持链式调用，而且能够基于别名来定位到内置的 Rule 或\nPlugin，从而实现精准的配置修改。我们推荐使用 tools.webpackChain 来代替 tools.webpack。\n\n> tools.webpackChain 的执行时机早于 tools.webpack，因此会被 tools.webpack 中的修改所覆盖。\n\n\n工具集合#\n\nenv#\n\n * 类型： 'development' | 'production' | 'test'\n\n通过 env 参数可以判断当前环境为 development、production 还是 test。比如：\n\n\n\nisProd#\n\n * 类型： boolean\n\n通过 isProd 参数可以判断当前环境是否为 production。比如：\n\n\n\ntarget#\n\n * 类型： 'web' | 'node' | 'modern-web' | 'web-worker'\n\n通过 target 参数可以判断当前构建的目标运行时环境。比如：\n\n\n\nisServer#\n\n * 类型： boolean\n\n判断当前构建的目标运行时环境是否为 node，等价于 target === 'node'。\n\n\n\nisWebWorker#\n\n * 类型： boolean\n\n判断当前构建的目标运行时环境是否为 web-worker，等价于 target === 'web-worker'。\n\n\n\nwebpack#\n\n * 类型： typeof import('webpack')\n\n通过这个参数你可以拿到 webpack 实例。比如：\n\n\n\nHtmlWebpackPlugin#\n\n * 类型： typeof import('html-webpack-plugin')\n\n通过这个参数你可以拿到 HtmlWebpackPlugin 实例。\n\n\n\ngetCompiledPath#\n\n * 类型： (name: string) => string\n\n获取 builder 内置依赖的所在路径，例如：\n\n * sass\n * sass-loader\n * less\n * less-loader\n * css-loader\n * ...\n\n该方法通常在需要与 builder 复用同一份依赖时会被用到。\n\nTIP\n\nBuilder 内部依赖会随着版本迭代而发生变化，例如产生大版本变更。在非必要的情况下，请避免使用此 API。\n\n\n\nCHAIN_ID#\n\nBuilder 中预先定义了一些常用的 Chain ID，你可以通过这些 ID 来定位到内置的 Rule 或 Plugin。\n\nTIP\n\n请留意，下列的一部分 Rule 或 Plugin 并不是默认存在的，当你开启特定配置项、或是注册某些插件后，它们才会被包含在 webpack 配置中。\n\n比如，RULE.STYLUS 仅在注册了 Stylus 插件后才会存在。\n\nCHAIN_ID.RULE#\n\nID            描述\nRULE.MJS      处理 mjs 的规则\nRULE.JS       处理 js 的规则\nRULE.TS       处理 ts 的规则\nRULE.CSS      处理 css 的规则\nRULE.LESS     处理 less 的规则\nRULE.SASS     处理 sass 的规则\nRULE.STYLUS   处理 stylus 的规则（依赖 Stylus 插件）\nRULE.SVG      Rule for svg\nRULE.PUG      处理 pug 的规则\nRULE.TOML     处理 toml 的规则\nRULE.YAML     处理 yaml 的规则\nRULE.WASM     处理 wasm 的规则\nRULE.NODE     处理 node 的规则\nRULE.FONT     处理字体的规则\nRULE.IMAGE    处理图片的规则\nRULE.MEDIA    处理媒体资源的规则\n\nCHAIN_ID.ONE_OF#\n\n通过 ONE_OF.XXX 可以匹配到规则数组中的某一类规则。\n\nID                  描述\nONE_OF.SVG          处理 SVG 的规则，在 data URI 和单独文件之间自动选择\nONE_OF.SVG_URL      处理 SVG 的规则，输出为单独文件\nONE_OF.SVG_INLINE   处理 SVG 的规则，作为 data URI 内联到 bundle 中\nONE_OF.SVG_ASSETS   处理 SVG 的规则，在 data URI 和单独文件之间自动选择\n\nCHAIN_ID.USE#\n\n通过 USE.XXX 可以匹配到对应的 loader。\n\nID                                描述\nUSE.TS                            对应 ts-loader\nUSE.CSS                           对应 css-loader\nUSE.LESS                          对应 less-loader\nUSE.SASS                          对应 sass-loader\nUSE.STYLUS                        对应 stylus-loader\nUSE.PUG                           对应 pug-loader\nUSE.VUE                           对应 vue-loader\nUSE.TOML                          对应 toml-loader\nUSE.YAML                          对应 yaml-loader\nUSE.NODE                          对应 node-loader\nUSE.URL                           对应 url-loader\nUSE.SVGR                          对应 @svgr/webpack\nUSE.BABEL                         对应 babel-loader\nUSE.STYLE                         对应 style-loader\nUSE.POSTCSS                       对应 postcss-loader\nUSE.CSS_MODULES_TS                对应 css-modules-typescript-loader\nUSE.MINI_CSS_EXTRACT              对应 mini-css-extract-plugin.loader\nUSE.RESOLVE_URL_LOADER_FOR_SASS   对应 resolve-url-loader\n\nCHAIN_ID.PLUGIN#\n\n通过 PLUGIN.XXX 可以匹配到对应的 plugin。\n\nID                             描述\nPLUGIN.HMR                     对应 HotModuleReplacementPlugin\nPLUGIN.COPY                    对应 CopyWebpackPlugin\nPLUGIN.HTML                    对应 HtmlWebpackPlugin，使用时需要拼接 entry\n                               名称：${PLUGIN.HTML}-${entryName}\nPLUGIN.DEFINE                  对应 DefinePlugin\nPLUGIN.IGNORE                  对应 IgnorePlugin\nPLUGIN.BANNER                  对应 BannerPlugin\nPLUGIN.PROGRESS                对应 Webpackbar\nPLUGIN.APP_ICON                对应 AppIconPlugin\nPLUGIN.MANIFEST                对应 WebpackManifestPlugin\nPLUGIN.TS_CHECKER              对应 ForkTsCheckerWebpackPlugin\nPLUGIN.INLINE_HTML             对应 InlineChunkHtmlPlugin\nPLUGIN.BUNDLE_ANALYZER         对应 WebpackBundleAnalyzer\nPLUGIN.MINI_CSS_EXTRACT        对应 MiniCssExtractPlugin\nPLUGIN.VUE_LOADER_PLUGIN       对应 VueLoaderPlugin\nPLUGIN.REACT_FAST_REFRESH      对应 ReactFastRefreshPlugin\nPLUGIN.NODE_POLYFILL_PROVIDE   对应处理 node polyfill 的 ProvidePlugin\nPLUGIN.SUBRESOURCE_INTEGRITY   对应 webpack-subresource-integrity\nPLUGIN.ASSETS_RETRY            对应 Builder 中的 webpack 静态资源重试插件 WebpackAssetsRetryPlugin\nPLUGIN.AUTO_SET_ROOT_SIZE      对应 Builder 中的自动设置根字体大小插件 AutoSetRootSizePlugin\n\nCHAIN_ID.MINIMIZER#\n\n通过 MINIMIZER.XXX 可以匹配到对应的压缩工具。\n\nID                  描述\nMINIMIZER.JS        对应 TerserWebpackPlugin\nMINIMIZER.CSS       对应 CssMinimizerWebpackPlugin\nMINIMIZER.ESBUILD   对应 ESBuildPlugin\nMINIMIZER.SWC       对应 SwcWebpackPlugin\n\n\n使用示例#\n\n使用示例可参考：WebpackChain 使用示例。\n\n\ntools.rspack#\n\n * 类型： Object | Function | undefined\n * 默认值： undefined\n * 打包工具： 仅支持 Rspack\n\ntools.rspack 选项用于配置原生的 Rspack。\n\n\nObject 类型#\n\ntools.rspack 可以配置为一个对象，这个对象将会和内置的 Rspack 配置通过 webpack-merge 进行深层合并。\n\n比如添加 resolve.alias 配置：\n\n\n\n\nFunction 类型#\n\ntools.rspack 也可以配置为一个函数，这个函数接收一个参数，即内置的 Rspack 配置对象，你可以对这个对象进行修改，然后返回一份新的配置。比如：\n\n\n\nTIP\n\ntools.rspack 函数返回的对象会直接作为最终使用的 Rspack 配置，不会再与内置的 Rspack 配置进行合并。\n\n\n工具集合#\n\n这个函数的第二个参数是一个对象，包含了一些工具函数和属性，详情如下：\n\nenv#\n\n * 类型： 'development' | 'production' | 'test'\n\n通过 env 参数可以判断当前环境为 development、production 还是 test。比如：\n\n\n\nisProd#\n\n * 类型： boolean\n\n通过 isProd 参数可以判断当前环境是否为 production。比如：\n\n\n\ntarget#\n\n * 类型： 'web' | 'node' | 'modern-web' | 'web-worker'\n\n通过 target 参数可以判断当前构建的目标运行时环境。比如：\n\n\n\nisServer#\n\n * 类型： boolean\n\n判断当前构建的目标运行时环境是否为 node，等价于 target === 'node'。\n\n\n\nisWebWorker#\n\n * 类型： boolean\n\n判断当前构建的目标运行时环境是否为 web-worker，等价于 target === 'web-worker'。\n\n\n\nrspack#\n\n * 类型： typeof import('@rspack/core')\n\n通过这个参数你可以拿到 Rspack 实例。比如：\n\n\n\naddRules#\n\n * 类型： (rules: RuleSetRule | RuleSetRule[]) => void\n\n添加额外的 Rspack rules。\n\n示例：\n\n\n\nprependPlugins#\n\n * 类型： (plugins: RspackPluginInstance | RspackPluginInstance[]) => void\n\n在内部 Rspack 插件数组头部添加额外的插件，数组头部的插件会优先执行。\n\n\n\nappendPlugins#\n\n * 类型： (plugins: RspackPluginInstance | RspackPluginInstance[]) => void\n\n在内部 Rspack 插件数组尾部添加额外的插件，数组尾部的插件会在最后执行。\n\n\n\nremovePlugin#\n\n * 类型： (name: string) => void\n\n删除内部的 Rspack 插件，参数为该插件的 constructor.name。\n\n例如，删除内部的 webpack-bundle-analyzer：\n\n\n\nmergeConfig#\n\n * 类型： (...configs: RspackConfig[]) => RspackConfig\n\n用于合并多份 Rspack 配置，等价于 webpack-merge。\n\n\n\ngetCompiledPath#\n\n * 类型： (name: string) => string\n\n获取 builder 内置依赖的所在路径，例如：\n\n * sass\n * sass-loader\n * less\n * less-loader\n * ...\n\n该方法通常在需要与 builder 复用同一份依赖时会被用到。\n\nTIP\n\nBuilder 内部依赖会随着版本迭代而发生变化，例如产生大版本变更。在非必要的情况下，请避免使用此 API。\n\n","routePath":"/builder/api/config-tools","lang":"zh","toc":[{"text":"tools.autoprefixer","id":"toolsautoprefixer","depth":2,"charIndex":32},{"text":"Object 类型","id":"object-类型","depth":3,"charIndex":136},{"text":"Function 类型","id":"function-类型","depth":3,"charIndex":218},{"text":"tools.babel","id":"toolsbabel","depth":2,"charIndex":316},{"text":"使用场景","id":"使用场景","depth":3,"charIndex":415},{"text":"Function 类型","id":"function-类型-1","depth":3,"charIndex":682},{"text":"Object 类型","id":"object-类型-1","depth":3,"charIndex":938},{"text":"工具函数","id":"工具函数","depth":3,"charIndex":1117},{"text":"addPlugins","id":"addplugins","depth":4,"charIndex":1168},{"text":"addPresets","id":"addpresets","depth":4,"charIndex":1241},{"text":"removePlugins","id":"removeplugins","depth":4,"charIndex":1332},{"text":"removePresets","id":"removepresets","depth":4,"charIndex":1447},{"text":"modifyPresetEnvOptions","id":"modifypresetenvoptions","depth":4,"charIndex":1564},{"text":"modifyPresetReactOptions","id":"modifypresetreactoptions","depth":4,"charIndex":1684},{"text":"addIncludes","id":"addincludes","depth":4,"charIndex":1810},{"text":"addExcludes","id":"addexcludes","depth":4,"charIndex":1861},{"text":"调试 Babel 配置","id":"调试-babel-配置","depth":3,"charIndex":1913},{"text":"tools.bundlerChain","id":"toolsbundlerchain","depth":2,"charIndex":2114},{"text":"tools.cssExtract","id":"toolscssextract","depth":2,"charIndex":2802},{"text":"Object 类型","id":"object-类型-2","depth":3,"charIndex":2935},{"text":"Function 类型","id":"function-类型-2","depth":3,"charIndex":2996},{"text":"tools.cssLoader","id":"toolscssloader","depth":2,"charIndex":3114},{"text":"Object 类型","id":"object-类型-3","depth":3,"charIndex":3333},{"text":"Function 类型","id":"function-类型-3","depth":3,"charIndex":3395},{"text":"tools.devServer","id":"toolsdevserver","depth":2,"charIndex":3477},{"text":"选项","id":"选项","depth":3,"charIndex":3666},{"text":"after","id":"after","depth":4,"charIndex":3671},{"text":"before","id":"before","depth":4,"charIndex":3955},{"text":"client","id":"client","depth":4,"charIndex":4016},{"text":"compress","id":"compress","depth":4,"charIndex":4091},{"text":"devMiddleware","id":"devmiddleware","depth":4,"charIndex":4194},{"text":"headers","id":"headers","depth":4,"charIndex":4287},{"text":"historyApiFallback","id":"historyapifallback","depth":4,"charIndex":4343},{"text":"hot","id":"hot","depth":4,"charIndex":4546},{"text":"https","id":"https","depth":4,"charIndex":4617},{"text":"liveReload","id":"livereload","depth":4,"charIndex":4811},{"text":"setupMiddlewares","id":"setupmiddlewares","depth":4,"charIndex":4972},{"text":"proxy","id":"proxy","depth":4,"charIndex":5257},{"text":"watch","id":"watch","depth":4,"charIndex":5772},{"text":"tools.htmlPlugin","id":"toolshtmlplugin","depth":2,"charIndex":5845},{"text":"Object 类型","id":"object-类型-4","depth":3,"charIndex":5983},{"text":"Function 类型","id":"function-类型-4","depth":3,"charIndex":6060},{"text":"Boolean 类型","id":"boolean-类型","depth":3,"charIndex":6213},{"text":"禁用 JS / CSS 压缩","id":"禁用-js--css-压缩","depth":3,"charIndex":6291},{"text":"tools.less","id":"toolsless","depth":2,"charIndex":6564},{"text":"Object 类型","id":"object-类型-5","depth":3,"charIndex":6652},{"text":"Function 类型","id":"function-类型-5","depth":3,"charIndex":6767},{"text":"修改 Less 版本","id":"修改-less-版本","depth":3,"charIndex":6876},{"text":"工具函数","id":"工具函数-1","depth":3,"charIndex":7006},{"text":"addExcludes","id":"addexcludes-1","depth":4,"charIndex":7013},{"text":"tools.minifyCss","id":"toolsminifycss","depth":2,"charIndex":7136},{"text":"Object 类型","id":"object-类型-6","depth":3,"charIndex":7327},{"text":"Function 类型","id":"function-类型-6","depth":3,"charIndex":7432},{"text":"tools.postcss","id":"toolspostcss","depth":2,"charIndex":7526},{"text":"Function 类型","id":"function-类型-7","depth":3,"charIndex":7644},{"text":"Object 类型","id":"object-类型-7","depth":3,"charIndex":7913},{"text":"工具函数","id":"工具函数-2","depth":3,"charIndex":8019},{"text":"addPlugins","id":"addplugins-1","depth":4,"charIndex":8026},{"text":"tools.pug","id":"toolspug","depth":2,"charIndex":8254},{"text":"Boolean 类型","id":"boolean-类型-1","depth":3,"charIndex":8340},{"text":"Object 类型","id":"object-类型-8","depth":3,"charIndex":8458},{"text":"Function 类型","id":"function-类型-8","depth":3,"charIndex":8550},{"text":"tools.sass","id":"toolssass","depth":2,"charIndex":8638},{"text":"Object 类型","id":"object-类型-9","depth":3,"charIndex":8726},{"text":"Function 类型","id":"function-类型-9","depth":3,"charIndex":8841},{"text":"修改 Sass 版本","id":"修改-sass-版本","depth":3,"charIndex":8950},{"text":"工具函数","id":"工具函数-3","depth":3,"charIndex":9085},{"text":"addExcludes","id":"addexcludes-2","depth":4,"charIndex":9092},{"text":"tools.styleLoader","id":"toolsstyleloader","depth":2,"charIndex":9215},{"text":"Object 类型","id":"object-类型-10","depth":3,"charIndex":9395},{"text":"Function 类型","id":"function-类型-10","depth":3,"charIndex":9456},{"text":"tools.styledComponents","id":"toolsstyledcomponents","depth":2,"charIndex":9538},{"text":"tools.terser","id":"toolsterser","depth":2,"charIndex":9856},{"text":"Object 类型","id":"object-类型-11","depth":3,"charIndex":10056},{"text":"Function 类型","id":"function-类型-11","depth":3,"charIndex":10154},{"text":"tools.tsLoader","id":"toolstsloader","depth":2,"charIndex":10299},{"text":"Object 类型","id":"object-类型-12","depth":3,"charIndex":10680},{"text":"Function 类型","id":"function-类型-12","depth":3,"charIndex":10783},{"text":"工具函数","id":"工具函数-4","depth":3,"charIndex":10888},{"text":"addIncludes","id":"addincludes-1","depth":4,"charIndex":10895},{"text":"addExcludes","id":"addexcludes-3","depth":4,"charIndex":10946},{"text":"tools.tsChecker","id":"toolstschecker","depth":2,"charIndex":10998},{"text":"Object 类型","id":"object-类型-13","depth":3,"charIndex":11152},{"text":"Function 类型","id":"function-类型-13","depth":3,"charIndex":11209},{"text":"tools.webpack","id":"toolswebpack","depth":2,"charIndex":11300},{"text":"Object 类型","id":"object-类型-14","depth":3,"charIndex":11504},{"text":"Function 类型","id":"function-类型-14","depth":3,"charIndex":11614},{"text":"工具集合","id":"工具集合","depth":3,"charIndex":11786},{"text":"env","id":"env","depth":4,"charIndex":11829},{"text":"isProd","id":"isprod","depth":4,"charIndex":11938},{"text":"target","id":"target","depth":4,"charIndex":12005},{"text":"isServer","id":"isserver","depth":4,"charIndex":12103},{"text":"isWebWorker","id":"iswebworker","depth":4,"charIndex":12179},{"text":"webpack","id":"webpack","depth":4,"charIndex":12270},{"text":"HtmlWebpackPlugin","id":"htmlwebpackplugin","depth":4,"charIndex":12343},{"text":"addRules","id":"addrules","depth":4,"charIndex":12445},{"text":"prependPlugins","id":"prependplugins","depth":4,"charIndex":12538},{"text":"appendPlugins","id":"appendplugins","depth":4,"charIndex":12673},{"text":"removePlugin","id":"removeplugin","depth":4,"charIndex":12808},{"text":"mergeConfig","id":"mergeconfig","depth":4,"charIndex":12942},{"text":"getCompiledPath","id":"getcompiledpath","depth":4,"charIndex":13051},{"text":"tools.webpackChain","id":"toolswebpackchain","depth":2,"charIndex":13159},{"text":"工具集合","id":"工具集合-1","depth":3,"charIndex":13618},{"text":"env","id":"env-1","depth":4,"charIndex":13625},{"text":"isProd","id":"isprod-1","depth":4,"charIndex":13734},{"text":"target","id":"target-1","depth":4,"charIndex":13801},{"text":"isServer","id":"isserver-1","depth":4,"charIndex":13899},{"text":"isWebWorker","id":"iswebworker-1","depth":4,"charIndex":13975},{"text":"webpack","id":"webpack-1","depth":4,"charIndex":14066},{"text":"HtmlWebpackPlugin","id":"htmlwebpackplugin-1","depth":4,"charIndex":14139},{"text":"getCompiledPath","id":"getcompiledpath-1","depth":4,"charIndex":14241},{"text":"CHAIN_ID","id":"chain_id","depth":4,"charIndex":14483},{"text":"CHAIN_ID.RULE","id":"chain_idrule","depth":4,"charIndex":14678},{"text":"CHAIN_ID.ONE_OF","id":"chain_idone_of","depth":4,"charIndex":15128},{"text":"CHAIN_ID.USE","id":"chain_iduse","depth":4,"charIndex":15406},{"text":"CHAIN_ID.PLUGIN","id":"chain_idplugin","depth":4,"charIndex":16417},{"text":"CHAIN_ID.MINIMIZER","id":"chain_idminimizer","depth":4,"charIndex":17663},{"text":"使用示例","id":"使用示例","depth":3,"charIndex":17910},{"text":"tools.rspack","id":"toolsrspack","depth":2,"charIndex":17946},{"text":"Object 类型","id":"object-类型-15","depth":3,"charIndex":18070},{"text":"Function 类型","id":"function-类型-15","depth":3,"charIndex":18178},{"text":"工具集合","id":"工具集合-2","depth":3,"charIndex":18346},{"text":"env","id":"env-2","depth":4,"charIndex":18389},{"text":"isProd","id":"isprod-2","depth":4,"charIndex":18498},{"text":"target","id":"target-2","depth":4,"charIndex":18565},{"text":"isServer","id":"isserver-2","depth":4,"charIndex":18663},{"text":"isWebWorker","id":"iswebworker-2","depth":4,"charIndex":18739},{"text":"rspack","id":"rspack","depth":4,"charIndex":18830},{"text":"addRules","id":"addrules-1","depth":4,"charIndex":18906},{"text":"prependPlugins","id":"prependplugins-1","depth":4,"charIndex":18998},{"text":"appendPlugins","id":"appendplugins-1","depth":4,"charIndex":19130},{"text":"removePlugin","id":"removeplugin-1","depth":4,"charIndex":19262},{"text":"mergeConfig","id":"mergeconfig-1","depth":4,"charIndex":19388},{"text":"getCompiledPath","id":"getcompiledpath-2","depth":4,"charIndex":19494}],"domain":"","frontmatter":{"extractApiHeaders":[2]},"version":""},{"id":61,"title":"API","content":"#","routePath":"/builder/api/","lang":"zh","toc":[],"domain":"","frontmatter":{"overview":true},"version":""},{"id":62,"title":"Plugin Core","content":"#\n\n本章节描述了 Builder 插件核心的类型定义和 API。\n\n\nBuilderPlugin#\n\n插件对象的类型，插件对象包含以下属性：\n\n * name：插件的名称，唯一标识符。\n * setup：插件逻辑的主入口函数，可以是一个异步函数。该函数仅会在初始化插件时执行一次。\n * pre：指定当前插件的前置插件有哪些，可以传入前置插件 name 的数组，当前插件会被调整到这些插件之后执行。\n * post：指定当前插件的后置插件有哪些，可以传入后置插件 name 的数组，当前插件会被调整到这些插件之前执行。\n * remove：指定需要移除的插件，可以传入插件 name 的数组。\n\n\n\n你可以从 @modern-js/builder 中导入该类型：\n\n\n\n\n前置插件#\n\n默认情况下，插件会按照添加顺序依次执行，通过 pre 字段可以声明前置执行的插件。\n\n比如有下面两个插件：\n\n\n\nBar 插件在 pre 字段中配置了 Foo 插件，因此 Foo 插件一定会在 Bar 插件之前执行。\n\n\n后置插件#\n\n同样的，通过 post 字段可以声明后置执行的插件。\n\n\n\nBar 插件在 post 字段中配置了 Foo 插件，因此 Foo 插件一定会在 Bar 插件之后执行。\n\n\n移除插件#\n\n通过 remove 字段可以在一个插件中移除其他插件。\n\n\n\n比如同时注册上述的 Foo 和 Bar 插件，由于 Bar 插件声明 remove 了 Foo 插件，因此 Foo 插件不会生效。\n\n\nBuilderPluginAPI#\n\n插件 API 对象的类型。插件 API 对象上挂载了提供给插件使用的上下文数据、工具函数和注册生命周期钩子的函数。\n\n关于生命周期钩子的完整介绍，请阅读 Plugin Hooks 章节。\n\n在使用 webpack-provider 或 rspack-provider 时，BuilderPluginAPI\n的类型定义有一定不同，你可以根据插件的使用场景来引入对应的类型。\n\n\n适用于 webpack-provider 的插件#\n\n开发适用于 webpack-provider 的插件时，请从 @modern-js/builder-webpack-provider 中引入\nBuilderPluginAPI。\n\n\n\n\n适用于 rspack-provider 的插件#\n\n开发适用于 rspack-provider 的插件时，请从 @modern-js/builder-rspack-provider 中引入\nBuilderPluginAPI。\n\n\n\n\n同时适用于 webpack-provider 和 rspack-provider 的插件#\n\n想要开发同时适用于 webpack-provider 和 rspack-provider 的插件时，请从 @modern-js/builder-shared\n中引入 DefaultBuilderPlugin。\n\n需要注意的是，开发 webpack 和 Rspack 同时支持的插件，意味着不能使用任何带有 webpack 或 Rspack 标识的 api，如\nmodifyWebpackConfig 或 modifyRspackConfig。\n\n可通过 modifyBundlerChain 修改同时适用于 webpack 和 Rspack 的配置。\n\n\n\n\napi.context#\n\napi.context 是一个只读对象，提供一些上下文信息。\n\napi.context 的内容与 builder.context 完全一致，请参考 builder.context。\n\n * Example\n\n\n\n\napi.getBuilderConfig#\n\n获取 Builder 配置，该方法必须在 modifyBuilderConfig 钩子执行完成后才能被调用。\n\n * 类型\n\n\n\n * Example\n\n\n\n\napi.getNormalizedConfig#\n\n获取归一化后的 Builder 配置，该方法必须在 modifyBuilderConfig 钩子执行完成后才能被调用。\n\n相较于 getBuilderConfig 方法，该方法返回的配置经过了归一化处理，配置的类型定义会得到收敛，比如 config.html 的 undefined\n类型将被移除。\n\n推荐优先使用该方法获取配置。\n\n * 类型\n\n\n\n * Example\n\n\n\n\napi.isPluginExists#\n\n判断某个插件是否已经被注册。\n\n * 类型\n\n\n\n * Example\n\n\n\n\napi.getHTMLPaths#\n\n获取所有 HTML 产物的路径信息。\n\n该方法会返回一个对象，对象的 key 为 entry 名称，value 为 HTML 文件在产物目录下的相对路径。\n\n * 类型\n\n\n\n * Example\n\n","routePath":"/builder/api/plugin-core","lang":"zh","toc":[{"text":"BuilderPlugin","id":"builderplugin","depth":2,"charIndex":35},{"text":"前置插件","id":"前置插件","depth":3,"charIndex":336},{"text":"后置插件","id":"后置插件","depth":3,"charIndex":454},{"text":"移除插件","id":"移除插件","depth":3,"charIndex":546},{"text":"BuilderPluginAPI","id":"builderpluginapi","depth":2,"charIndex":652},{"text":"适用于 webpack-provider 的插件","id":"适用于-webpack-provider-的插件","depth":3,"charIndex":859},{"text":"适用于 rspack-provider 的插件","id":"适用于-rspack-provider-的插件","depth":3,"charIndex":979},{"text":"同时适用于 webpack-provider 和 rspack-provider 的插件","id":"同时适用于-webpack-provider-和-rspack-provider-的插件","depth":3,"charIndex":1096},{"text":"api.context","id":"apicontext","depth":2,"charIndex":1423},{"text":"api.getBuilderConfig","id":"apigetbuilderconfig","depth":2,"charIndex":1544},{"text":"api.getNormalizedConfig","id":"apigetnormalizedconfig","depth":2,"charIndex":1647},{"text":"api.isPluginExists","id":"apiispluginexists","depth":2,"charIndex":1864},{"text":"api.getHTMLPaths","id":"apigethtmlpaths","depth":2,"charIndex":1925}],"domain":"","frontmatter":{"extractApiHeaders":[2]},"version":""},{"id":63,"title":"Plugin Hooks","content":"#\n\n本章节描述了 Builder 插件提供的生命周期钩子。\n\n\n概览#\n\n通用钩子\n\n * modifyBuilderConfig：修改传递给 Builder 的配置项。\n * modifyBundlerChain (实验性)：通过 chain api 修改 webpack / Rspack 配置。\n * modifyWebpackChain：修改 webpack chain 配置。\n * modifyWebpackConfig：修改最终的 webpack 配置对象。\n * modifyRspackConfig：修改最终的 Rspack 配置对象。\n * onBeforeCreateCompiler：在创建 compiler 实例前调用。\n * onAfterCreateCompiler：在创建 compiler 实例后、执行构建前调用。\n\n构建钩子：仅在执行 build 方法构建生产环境产物时调用。\n\n * onBeforeBuild：在执行生产环境构建前调用。\n * onAfterBuild：在执行生产环境构建后调用，可以获取到构建结果信息。\n\n开发服务钩子：仅在执行 startDevServer 方法运行开发服务器时调用。\n\n * onBeforeStartDevServer：在启动开发服务器前调用。\n * onAfterStartDevServer：在启动开发服务器后调用。\n * onDevCompileDone：在每次开发环境构建结束后调用。\n\n其他钩子\n\n * onExit：在进程即将退出时调用。\n\n\n通用钩子#\n\n\nmodifyBuilderConfig#\n\n修改传递给 Builder 的配置项，你可以直接修改传入的 config 对象，也可以返回一个新的对象来替换传入的对象。\n\n * 类型\n\n\n\n * Example\n\n\n\n\nmodifyBundlerChain 实验性#\n\n什么是 BundlerChain\n\nBundler chain 是 webpack chain 的子集，其中包含一部分 webpack chain API，你可以用它来同时修改 webpack 和\nRspack 的配置。\n\n通过 bundler chain 修改的配置，在 webpack 和 Rspack 构建时均可生效。需要注意的是，bundler chain 只支持修改\nwebpack 和 Rspack 间无差异部分的配置。如，修改 devtool 配置项(webpack 和 Rspack 的 devtool\n属性值类型相同)，或添加一个Rspack 兼容的 webpack 插件。\n\nmodifyBundlerChain 用于调用 bundler chain 来修改 webpack / Rspack 的配置。你在使用\nwebpack-provider 或 rspack-provider 时都可以使用该 hook。\n\n * 类型\n\n\n\n * Example\n\n\n\n\nmodifyWebpackChain#\n\n通过 webpack chain 来修改 webpack 配置。该方法仅在使用 webpack-provider 时调用。\n\n * 类型\n\n\n\n * Example\n\n\n\n\nmodifyWebpackConfig#\n\n修改最终的 webpack 配置对象，你可以直接修改传入的 config 对象，也可以返回一个新的对象来替换传入的对象。该方法仅在使用\nwebpack-provider 时调用。\n\n该方法的调用时机晚于 modifyWebpackChain 钩子。\n\n * 类型\n\n\n\n * Example\n\n\n\n\nmodifyRspackConfig#\n\n修改最终的 Rspack 配置对象，你可以直接修改传入的 config 对象，也可以返回一个新的对象来替换传入的对象。该方法仅在使用\nrspack-provider 时调用。\n\n * 类型\n\n\n\n * Example\n\n\n\n\nonBeforeCreateCompiler#\n\nonBeforeCreateCompiler 是在创建底层 Compiler 实例前触发的回调函数，当你执行\nbuilder.startDevServer、builder.build 或 builder.createCompiler 时，都会调用此钩子。\n\n你可以通过 bundlerConfigs 参数获取到底层打包工具的最终配置数组：\n\n * 如果当前打包工具为 webpack，则获取到的是 webpack 配置数组。\n * 如果当前打包工具为 Rspack，则获取到的是 Rspack 配置数组。\n * 配置数组中可能包含一份或多份配置，这取决于你是否开启了 SSR 等功能。\n\n你可以通过 bundlerConfigs 参数获取到底层打包工具的最终配置对象。\n\n * 类型\n\n\n\n * Example\n\n\n\n\nonAfterCreateCompiler#\n\nonAfterCreateCompiler 是在创建 Compiler 实例后、执行构建前触发的回调函数，当你执行\nbuilder.startDevServer、builder.build 或 builder.createCompiler 时，都会调用此钩子。\n\n你可以通过 compiler 参数获取到 Compiler 实例对象:\n\n * 如果当前打包工具为 webpack，则获取到的是 webpack Compiler 对象。\n\n * 如果当前打包工具为 Rspack，则获取到的是 Rspack Compiler 对象。\n\n * 类型\n\n\n\n * Example\n\n\n\n\n构建钩子#\n\n\nonBeforeBuild#\n\nonBeforeBuild 是在执行生产环境构建前触发的回调函数，你可以通过 bundlerConfigs 参数获取到底层打包工具的最终配置数组：\n\n * 如果当前打包工具为 webpack，则获取到的是 webpack 配置数组。\n\n * 如果当前打包工具为 Rspack，则获取到的是 Rspack 配置数组。\n\n * 配置数组中可能包含一份或多份配置，这取决于 Builder 当前 target 配置的值。\n\n * 类型\n\n\n\n * Example\n\n\n\n\nonAfterBuild#\n\nonAfterBuild 是在执行生产环境构建后触发的回调函数，你可以通过 stats 参数获取到构建结果信息：\n\n * 如果当前打包工具为 webpack，则获取到的是 webpack Stats。\n\n * 如果当前打包工具为 Rspack，则获取到的是 Rspack Stats。\n\n * 类型\n\n\n\n * Example\n\n\n\n\n开发服务钩子#\n\n\nonBeforeStartDevServer#\n\n在启动开发服务器前调用。\n\n * 类型\n\n\n\n * Example\n\n\n\n\nonAfterStartDevServer#\n\n在启动开发服务器后调用，你可以通过 port 参数获得开发服务器监听的端口号。\n\n * 类型\n\n\n\n * Example\n\n\n\n\nonDevCompileDone#\n\n在每次开发环境构建结束后调用，你可以通过 isFirstCompile 来判断是否为首次构建。\n\n * 类型\n\n\n\n * Example\n\n\n\n\n其他钩子#\n\n\nonExit#\n\n在进程即将退出时调用，这个钩子只能执行同步代码。\n\n * 类型\n\n\n\n * Example\n\n","routePath":"/builder/api/plugin-hooks","lang":"zh","toc":[{"text":"概览","id":"概览","depth":2,"charIndex":32},{"text":"通用钩子","id":"通用钩子","depth":2,"charIndex":668},{"text":"modifyBuilderConfig","id":"modifybuilderconfig","depth":3,"charIndex":676},{"text":"modifyBundlerChain `实验性`","id":"modifybundlerchain-实验性","depth":3,"charIndex":-1},{"text":"modifyWebpackChain","id":"modifywebpackchain","depth":3,"charIndex":1249},{"text":"modifyWebpackConfig","id":"modifywebpackconfig","depth":3,"charIndex":1357},{"text":"modifyRspackConfig","id":"modifyrspackconfig","depth":3,"charIndex":1529},{"text":"onBeforeCreateCompiler","id":"onbeforecreatecompiler","depth":3,"charIndex":1663},{"text":"onAfterCreateCompiler","id":"onaftercreatecompiler","depth":3,"charIndex":2048},{"text":"构建钩子","id":"构建钩子","depth":2,"charIndex":2363},{"text":"onBeforeBuild","id":"onbeforebuild","depth":3,"charIndex":2371},{"text":"onAfterBuild","id":"onafterbuild","depth":3,"charIndex":2620},{"text":"开发服务钩子","id":"开发服务钩子","depth":2,"charIndex":2803},{"text":"onBeforeStartDevServer","id":"onbeforestartdevserver","depth":3,"charIndex":2813},{"text":"onAfterStartDevServer","id":"onafterstartdevserver","depth":3,"charIndex":2876},{"text":"onDevCompileDone","id":"ondevcompiledone","depth":3,"charIndex":2965},{"text":"其他钩子","id":"其他钩子","depth":2,"charIndex":3057},{"text":"onExit","id":"onexit","depth":3,"charIndex":3065}],"domain":"","frontmatter":{"extractApiHeaders":[2]},"version":""},{"id":64,"title":"浏览器兼容性","content":"#\n\n本章节介绍如何使用 Builder 提供的能力来处理浏览器兼容性问题。\n\n\n设置浏览器范围#\n\n在处理兼容性问题之前，首先需要明确你的项目需要支持的浏览器范围，并添加相应的 browserslist 配置。\n\n * 如果你还没有设置浏览器范围，请先阅读 设置浏览器范围 章节。\n\n * 如果你已经设置了浏览器范围，那么 Builder 会自动根据该范围进行编译，对 JavaScript 语法和 CSS 语法进行降级处理，并注入所需的\n   polyfill 代码。大部分情况下，你可以放心地使用现代 ECMAScript 特性，无须担心兼容性问题。\n\n在设置浏览器范围之后，如果你依然在开发中遇到了一些兼容性问题，请继续阅读下面的内容来寻找解决方案。\n\n\n背景知识#\n\n在处理兼容性问题之前，建议你了解以下背景知识，以更好地处理相关问题。\n\n\n语法降级和 API 降级#\n\n当你在项目中使用高版本语法和 API 时，为了让编译后的代码能稳定运行在低版本浏览器中，需要完成两部分降级：语法降级和 API 降级。\n\nBuilder 通过语法转译来对语法进行降级，通过 polyfill 来对 API 进行进行降级。\n\n> 语法和 API 并不是强绑定的，浏览器厂商在实现引擎的时候，会根据规范或者自身需要提前支持一些语法或者提前实现一些\n> API。因此，同一时期的不同厂商的浏览器，对语法和 API 的兼容都不一定相同。所以在一般的实践中，语法和 API 是分成两个部分进行处理的。\n\n\n语法转译#\n\n语法是编程语言如何组织代码的一系列规则，不遵守这些规则的代码无法被编程语言的引擎正确识别，因此无法被运行。在 JavaScript\n中，以下几个示例都是语法规则：\n\n * 在 const foo = 1 中，const 表示声明一个不可变的常量。\n * 在 foo?.bar?.baz 中，?. 表示可选链访问属性。\n * 在 async function () {} 中，async 表示声明一个异步函数。\n\n由于不同浏览器的解析器所能支持的语法不同，尤其是旧版本浏览器引擎所能支持的语法较少，因此一些语法在低版本浏览器引擎中运行时，就会在解析 AST 的阶段报错。\n\n比如下面这段代码在 IE 浏览器或低版本 Node.js 下会报错：\n\n\n\n我们在低版本 Node.js 中运行这段代码，会出现以下错误信息：\n\n\n\n从错误信息里可以明显看到，这是一个语法错误（SyntaxError）。这说明这个语法在低版本的引擎中是不受支持的。\n\n语法是不能通过 polyfill 或者 shim\n进行支持的。如果想在低版本浏览器中运行一些它原本不支持的语法，那么就需要对代码进行转译，转译成低版本引擎所能支持的语法。\n\n将上述代码转译为以下代码即可在低版本引擎中运行：\n\n\n\n转译后，代码的语法变了，把一些低版本引擎无法理解的语法用其可理解的语法替代，但代码本身的意义没有变。\n\n如果引擎在转换为 AST 的时候遇到了无法识别的语法，就会报语法错误，并中止代码执行流程。在这种情况下，如果你的项目没有使用 SSR 或 SSG\n等能力的话，页面将会直接白屏，导致页面不可用。\n\n如果代码被转换为 AST 成功，引擎会将 AST 转为可执行代码，并在引擎内部正常执行。\n\n\nAPI Polyfill#\n\nJavaScript 是解释型脚本语言，不同于 Rust 等编译型语言。Rust 会在编译阶段对代码中的调用进行检查，而 JavaScript\n在真正运行到某一行代码之前，并不知道这一行代码所调用的函数是否存在，因此一些错误只有在运行时才会出现。\n\n举个例子，下面这段代码：\n\n\n\n上面这段代码有着正确的语法，在引擎运行时的第一个阶段也能正确转换为 AST，但是在真正运行的时候，由于 String.prototype 上不存在\nnotExistedMethod 这个方法，所以在实际运行的时候会报错：\n\n\n\n随着 ECMAScript 的迭代，一些内置对象也会迎来新的方法。比如 String.prototype.replaceAll 是在 ES2021\n中被引入的，那么在大部分 2021 年前的浏览器的引擎的内置对象 String.prototype 中是不存在 replaceAll\n方法的，因此下面这段代码在最新的 Chrome 里可以运行，但是在较早的版本里无法运行：\n\n\n\n为了解决在旧版浏览器中的 String.prototype 缺少 replaceAll 的问题，我们可以在老版本的浏览器里扩展 String.prototype\n对象，给它加上 replaceAll 方法，例如：\n\n\n\n> 这种为旧环境提供实现来对齐新 API 的技术被称作 polyfill。\n\n\n降级方式#\n\n在 Builder 中，我们将代码分为三类：\n\n * 第一类是当前项目中的源代码。\n * 第二类是通过 npm 安装的第三方依赖代码。\n * 第三类是非当前项目的代码，比如 monorepo 中其他目录下的代码。\n\n默认情况下，Builder 只会对第一类代码进行编译和降级，而其他类型的代码默认是不进行降级处理的。\n\n之所以这样处理，主要有几个考虑：\n\n * 将所有第三方依赖代码都进行降级的话会导致构建性能显著下降。\n * 大部分第三方依赖在发布前已经进行了降级处理，二次降级可能会引入新问题。\n * 非当前项目的代码可能已经经过了编译处理，或者编译所需的配置与当前项目并不相同。\n\n\n降级当前项目代码#\n\n当前项目的代码会被默认降级，因此你不需要添加额外的配置，只需要保证正确设置了浏览器范围即可。\n\n\n降级第三方依赖#\n\n当你发现某个第三方依赖的代码导致了兼容性问题时，你可以将这个依赖添加到 Builder 的 source.include 配置中，使 Builder\n对该依赖进行额外的编译。\n\n以 query-string 这个 npm 包为例，你可以做如下的配置：\n\n\n\n请查看 source.include 文档来查看更详细的用法说明。\n\n\n降级非当前项目的代码#\n\n当你引用非当前项目的代码时，如果该代码未经过编译处理，那么你也需要配置 source.include 来对它进行编译。\n\n比如，你需要引用 monorepo 中 packages 目录下的某个模块，可以添加如下的配置：\n\n\n\n\nPolyfill 方案#\n\nBuilder 底层通过 Babel 或 SWC 编译 JavaScript 代码，并注入\ncore-js、@babel/runtime、@swc/helpers 等 polyfill 库。\n\n在不同的使用场景下，你可能会需要不同的 polyfill 方案。Builder 提供了 output.polyfill 配置项来切换不同的 polyfill\n方案。\n\n\nentry 方案#\n\nentry 为默认方案，无须手动设置。\n\n在使用 entry 方案时，Builder 会根据当前项目设置的浏览器范围来计算需要注入哪些 core-js\n方法，并在每个页面的入口文件中进行注入。这种方式注入的 polyfill 较为全面，不需要再担心项目源码和第三方依赖的 polyfill\n问题，但是因为包含了一些没有用到的 polyfill 代码，所以最终的包大小可能会有所增加。\n\nentry 方案对应的配置为：\n\n\n\n\nusage 方案#\n\nusage 方案可以更精确地控制需要注入哪些 core-js polyfill。\n\n当你开启 usage 方案时，Builder 会分析项目中的源代码，并判断需要注入哪些 polyfill。\n\n比如代码中使用了 Map:\n\n\n\n编译后，只会在该文件中注入 Map 所需的 polyfill：\n\n\n\n这种方式的优点是注入的 polyfill 体积更小，适合对包体积有较高要求的项目使用。缺点是 polyfill\n可能注入不全，因为第三方依赖默认不会被编译和降级处理，因此第三方依赖所需的 polyfill 不会被分析到，如果需要分析某个第三方依赖，也需要将其加入到\nsource.include 配置中。\n\nusage 方案对应的配置为：\n\n\n\n\n不注入 Polyfill#\n\n你可以将 output.polyfill 设置为 'off' 来禁用 polyfill 注入的行为。\n\n\n\n使用此选项时，你需要自行保证代码的兼容性，比如通过 source.preEntry 来手动引用所需的 polyfill 代码。","routePath":"/builder/guide/advanced/browser-compatibility","lang":"zh","toc":[{"text":"设置浏览器范围","id":"设置浏览器范围","depth":2,"charIndex":40},{"text":"背景知识","id":"背景知识","depth":2,"charIndex":331},{"text":"语法降级和 API 降级","id":"语法降级和-api-降级","depth":3,"charIndex":375},{"text":"语法转译","id":"语法转译","depth":3,"charIndex":646},{"text":"API Polyfill","id":"api-polyfill","depth":3,"charIndex":1385},{"text":"降级方式","id":"降级方式","depth":2,"charIndex":1994},{"text":"降级当前项目代码","id":"降级当前项目代码","depth":3,"charIndex":2296},{"text":"降级第三方依赖","id":"降级第三方依赖","depth":3,"charIndex":2356},{"text":"降级非当前项目的代码","id":"降级非当前项目的代码","depth":3,"charIndex":2531},{"text":"Polyfill 方案","id":"polyfill-方案","depth":2,"charIndex":2658},{"text":"entry 方案","id":"entry-方案","depth":3,"charIndex":2854},{"text":"usage 方案","id":"usage-方案","depth":3,"charIndex":3078},{"text":"不注入 Polyfill","id":"不注入-polyfill","depth":3,"charIndex":3412}],"domain":"","frontmatter":{},"version":""},{"id":65,"title":"设置浏览器范围","content":"#\n\nBuilder 支持通过 Browserslist 来设置 Web 应用需要兼容的浏览器范围。\n\n\n什么是 Browserslist#\n\n由于各种浏览器对 ECMAScript 和 CSS 的支持程度不同，因此开发者需要根据业务需求，为 Web 应用设置正确的浏览器范围。\n\nBrowserslist 可以指定 Web 应用能够在哪些浏览器中正常运行，它提供了统一的配置格式，并且已经成为了前端社区中的标准。Browserslist 被\nAutoprefixer, Babel, ESLint, PostCSS，SWC 和 Webpack 等库所使用。\n\n当你通过 Browserslist 指定了一个浏览器范围时，Builder 会将 JavaScript 代码和 CSS 代码编译到指定的语法，并注入相应的\npolyfill 代码。当你只需要兼容更现代的浏览器时，编译过程会引入更少的兼容代码和 polyfills，页面的性能会更好。\n\n比如，当你需要适配 IE11 浏览器时，Builder 会将代码编译至 ES5，并通过 core-js 注入 IE11 所需的 polyfill。\n\n什么是 polyfill\n\npolyfill 是一种用于解决浏览器兼容问题的技术。它用于模拟某些浏览器不支持的新特性，使得这些特性能在不支持的浏览器中正常工作。例如，如果某个浏览器不支持\nArray.prototype.flat() 方法，那么我们可以使用 polyfill 来模拟这个方法，从而让代码在这个浏览器中也能正常工作。\n\n\n设置 Browserslist#\n\n你可以在当前项目根目录的 package.json 或 .browserslistrc 文件里设置 Browserslist 的值。\n\n\n示例#\n\n通过 package.json 的 browserslist 设置：\n\n\n\n通过独立的 .browserslistrc 文件设置：\n\n\n\n\n生效范围#\n\n.browserslistrc 文件默认只对浏览器端的构建产物生效，包括 web 和 web-worker 这两种产物类型。\n\n当你同时构建多种产物，比如 target 包含 web 和 node 两种产物时，只有 web 产物会受到 .browserslistrc\n文件的影响。如果你希望对 node 产物进行修改，可以使用下方的 output.overrideBrowserslist 配置。\n\n\n使用 output.overrideBrowserslist 配置#\n\n除了上述的标准用法，Builder 还提供了 output.overrideBrowserslist 配置项，同样可以设置 Browserslist 的值。\n\noverrideBrowserslist 可以被设置为一个数组，数组的写法与 browserslistrc 配置是一样的，但比 browserslistrc\n拥有更高的优先级。\n\n\n\n当 .overrideBrowserslist 被设置为数组时，同样只对浏览器端的构建产物生效。\n\n当你同时构建多种类型的产物时，你可以为不同的产物类型设置不同的目标浏览器范围。此时，你需要把 overrideBrowserslist 设置为一个对象，对象的\nkey 为对应的产物类型。\n\n比如为 web 和 node 设置不同的范围：\n\n\n\n大多数场景下，推荐优先使用 .browserslistrc 文件，而不是使用 overrideBrowserslist 配置。因为\n.browserslistrc 文件是官方定义的配置文件，通用性更强，可以被社区中的其他库识别。\n\n\n常用的浏览器范围#\n\n以下是一些常用的浏览器范围，你可以根据自己的项目类型进行选择。\n\n\n桌面端 PC 场景#\n\n在桌面端 PC 场景下，如果你需要兼容 IE 11 浏览器，则可以将 Browserslist 设置为：\n\n\n\n以上浏览器范围会将代码编译至 ES5 规范，具体对应的浏览器列表可以查看 browserslist.dev。\n\n如果你不需要兼容 IE 11 浏览器，那么可以调整 Browserslist 来获得更高性能的产物，比如：\n\n * 设置为支持原生 ES Modules 的浏览器（推荐）：\n\n\n\n * 设置为支持 ES6 的浏览器：\n\n\n\n\n移动端 H5 场景#\n\n移动端 H5 场景主要兼容 iOS 和 Android 系统，通常我们将 Browserslist 设置为：\n\n\n\n以上浏览器范围会将代码编译至 ES5 规范，可以兼容市面上绝大多数移动端场景，具体对应的浏览器列表可以查看 browserslist.dev。\n\n\n\n你也可以选择在 H5 场景使用 ES6 规范，这样会让页面的性能表现更好，对应的 Browserslist 如下：\n\n\n\n\nBrowserslist 默认值#\n\nBuilder 会根据构建产物类型来设置不同的 Browserslist 默认值，但我们推荐你在项目中显式设置\nBrowserslist，这会让项目的兼容范围更加明确。\n\n\nWeb 产物#\n\nWeb 产物的默认值如下所示：\n\n\n\n在该浏览器范围下，JavaScript 代码被会编译到 ES5 语法。\n\n\nNode 产物#\n\nNode 产物默认最低兼容到 Node.js 14.0 版本。\n\n\n\n\nWeb Worker 产物#\n\nWeb Worker 产物默认的浏览器范围与 Web 一致。\n\n\n\n\nModern Web 产物#\n\nModern Web 产物默认最低兼容到支持原生 ES Modules 的浏览器。\n\n\n\n\n查询浏览器支持情况#\n\n在开发时，我们需要了解某些特性或 API 的浏览器支持情况，此时我们可以在 caniuse 网站上进行查询。\n\n比如我们需要知道 Promise 的浏览器支持情况，只需要在 caniuse 中输入 Promise，就可以看到以下结果：\n\n\n\n从上表可以看出，Promise 在 Chrome 33 和 iOS 8 中得到了原生支持，但是在 IE 11 中不被支持。","routePath":"/builder/guide/advanced/browserslist","lang":"zh","toc":[{"text":"什么是 Browserslist","id":"什么是-browserslist","depth":2,"charIndex":52},{"text":"设置 Browserslist","id":"设置-browserslist","depth":2,"charIndex":666},{"text":"示例","id":"示例","depth":3,"charIndex":753},{"text":"生效范围","id":"生效范围","depth":3,"charIndex":828},{"text":"使用 output.overrideBrowserslist 配置","id":"使用-outputoverridebrowserslist-配置","depth":3,"charIndex":1036},{"text":"常用的浏览器范围","id":"常用的浏览器范围","depth":2,"charIndex":1533},{"text":"桌面端 PC 场景","id":"桌面端-pc-场景","depth":3,"charIndex":1578},{"text":"移动端 H5 场景","id":"移动端-h5-场景","depth":3,"charIndex":1815},{"text":"Browserslist 默认值","id":"browserslist-默认值","depth":2,"charIndex":2022},{"text":"Web 产物","id":"web-产物","depth":3,"charIndex":2128},{"text":"Node 产物","id":"node-产物","depth":3,"charIndex":2194},{"text":"Web Worker 产物","id":"web-worker-产物","depth":3,"charIndex":2240},{"text":"Modern Web 产物","id":"modern-web-产物","depth":3,"charIndex":2291},{"text":"查询浏览器支持情况","id":"查询浏览器支持情况","depth":2,"charIndex":2353}],"domain":"","frontmatter":{},"version":""},{"id":66,"title":"修改 webpack 配置","content":"#\n\nBuilder 支持直接修改 webpack 配置对象，也支持通过 webpack-chain 来深度定制 webpack 配置。\n\n\n修改 webpack 配置对象#\n\n你可以使用 tools.webpack 来修改 webpack 配置对象。\n\n\n\n何时使用\n\n当你只需要修改少量 webpack 配置时，可以使用 tools.webpack。但如果你需要修改 Builder 内置的 webpack plugins 或\nloaders，请使用 tools.webpackChain 进行修改。\n\n\n使用 webpack-chain#\n\nwebpack-chain 是区别于直接修改 webpack 配置的另一种配置修改方式，相较于直接修改 webpack 配置对象，webpack-chain\n不仅支持链式调用，并且能够基于 id 来修改内置的 Rule 或 Plugin.\n\n\ntools.webpackChain 配置项#\n\nBuilder 提供了 tools.webpackChain 配置项来修改 webpack-chain。\n\ntools.webpackChain 的值为 Function 类型，接收两个参数：\n\n * 第一个参数为 webpack-chain 实例对象，你可以通过这个实例来修改默认的 webpack 配置。\n * 第二个参数为一个工具集合，包括 env、isProd、CHAIN_ID 等。\n\n下面是一个基本示例：\n\n\n\n\nwebpack-chain 基础知识#\n\n在开始使用 webpack-chain 来修改 webpack 配置之前，建议你先了解一些基础知识。\n\n\nwebpack-chain 是如何快速定位的#\n\n简单来说，webpack-chain 要求使用者为每个 Rule、Loader、Plugin、Minimizer 都设置一个独一无二的 id，通过这个\nid，就可以便捷地从嵌套层级很深的对象中找到所需的对象。\n\nBuilder 将内部定义的全部 id 都通过 CHAIN_ID 对象导出，因此你可以通过这些导出的 id，快速定位到你想要修改的 Loader 或\nPlugin，而不需要在 webpack 配置对象里通过复杂的遍历寻找。\n\n比如通过 CHAIN_ID.PLUGIN.HTML 来删除内置的 HTML 插件：\n\n\n\n\nwebpack-chain id 的类型#\n\nCHAIN_ID 对象包含了多种 id，对应的含义如下：\n\nCHAIN_ID 字段               对应的配置                    描述\nCHAIN_ID.PLUGIN           plugins[i]               对应 webpack 配置中的一个插件\nCHAIN_ID.RULE             module.rules[i]          对应 webpack 配置中的一个 Rule\nCHAIN_ID.USE              module.rules[i].loader   对应 webpack 配置中的一个 Loader\nCHAIN_ID.MINIMIZER        optimization.minimizer   对应 webpack 配置中的一个压缩工具\nCHAIN_ID.RESOLVE_PLUGIN   resolve.plugins[i]       对应 webpack 配置中的一个 Resolve 插件\n\n\nwebpack-chain 示例#\n\n\n新增/修改/删除 loader#\n\n\n\n\n新增/修改/删除 plugin#\n\n\n\n\n根据不同环境修改配置#\n\n在工具集合中你可以拿到各种环境的标识，如开发/生产/测试环境构建、 SSR 构建、Web Worker 构建，从而实现不同环境下的配置修改。\n\n\n\n以上是一些常见的配置示例，完整的 webpack-chain API 请见 webpack-chain 文档。","routePath":"/builder/guide/advanced/custom-webpack-config","lang":"zh","toc":[{"text":"修改 webpack 配置对象","id":"修改-webpack-配置对象","depth":2,"charIndex":70},{"text":"使用 webpack-chain","id":"使用-webpack-chain","depth":2,"charIndex":254},{"text":"tools.webpackChain 配置项","id":"toolswebpackchain-配置项","depth":3,"charIndex":395},{"text":"webpack-chain 基础知识","id":"webpack-chain-基础知识","depth":2,"charIndex":633},{"text":"webpack-chain 是如何快速定位的","id":"webpack-chain-是如何快速定位的","depth":3,"charIndex":707},{"text":"webpack-chain id 的类型","id":"webpack-chain-id-的类型","depth":3,"charIndex":997},{"text":"webpack-chain 示例","id":"webpack-chain-示例","depth":2,"charIndex":1480},{"text":"新增/修改/删除 loader","id":"新增修改删除-loader","depth":3,"charIndex":1500},{"text":"新增/修改/删除 plugin","id":"新增修改删除-plugin","depth":3,"charIndex":1521},{"text":"根据不同环境修改配置","id":"根据不同环境修改配置","depth":3,"charIndex":1542}],"domain":"","frontmatter":{},"version":""},{"id":67,"title":"环境变量","content":"#\n\nBuilder 支持在编译过程中向代码中注入环境变量或表达式，这对于区分运行环境、注入常量值等场景很有帮助。本章节会介绍环境变量的使用方式。\n\n\n默认环境变量#\n\n\nprocess.env.NODE_ENV#\n\n默认情况下，Builder 会自动设置 process.env.NODE_ENV 环境变量，在开发模式为 'development'，生产模式为\n'production'。\n\n你可以在 Node.js 和运行时代码中直接使用 process.env.NODE_ENV。\n\n\n\n在开发环境，以上代码会被编译为：\n\n\n\n在生产环境，以上代码会被编译为：\n\n\n\n在代码压缩过程中，if (false) { ... } 会被识别为无效代码，并被自动移除。\n\n\nprocess.env.ASSET_PREFIX#\n\n你可以在运行时代码中使用 process.env.ASSET_PREFIX 来访问静态资源的前缀。\n\n * 在开发环境下，它等同于 dev.assetPrefix 设置的值。\n * 在生产环境下，它等同于 output.assetPrefix 设置的值。\n * Builder 会自动移除 assetPrefix 尾部的斜线符号，以便于进行字符串拼接。\n\n比如，我们通过 output.copy 配置，将 static/icon.png 图片拷贝到 dist 目录下：\n\n\n\n此时，我们可以在前端代码中通过以下方式来拼接图片 URL：\n\n\n\n在开发环境，以上代码会被编译为：\n\n\n\n在生产环境，以上代码会被编译为：\n\n\n\n\n使用 define 配置项#\n\n通过配置 source.define 选项，你可以在构建时将代码中的变量替换成其它值或者表达式。\n\ndefine 类似于其它一些语言提供的宏定义能力，但得益于 JavaScript\n强大的运行时表达能力，通常不需要像那些语言一样将其用作复杂代码的生成器。它常用于在构建环境向运行时传递环境变量等简单信息，或是辅助 Builder 进行\nTree Shaking 等操作。\n\n\n替换表达式#\n\ndefine 最基础的用途是在构建时替换代码中的表达式。\n\n例如环境变量 NODE_ENV 的值会影响许多第三方模块的行为，在构建线上应用的产物时通常需要将它设置为 \"production\"：\n\n\n\n需要注意的是这里提供的值必须是 JSON 字符串，例如 process.env.NODE_ENV 的值为 \"production\" 则传入的值应当是\n\"\\\"production\\\"\" 才能够正确被处理。\n\n同理 { foo: \"bar\" } 也应该被转换成 \"{\\\"foo\\\":\\\"bar\\\"}\"，如果直接传入原始对象则意味着把表达式\nprocess.env.NODE_ENV.foo 替换为标识符 bar。\n\nsource.define 的具体行为请参考 API 文档。\n\nTIP\n\n以上例子中的环境变量 NODE_ENV 已经由 Builder 自动注入，通常你不需要手动配置它的值。\n\n\nprocess.env 注入方式#\n\n在使用 source.define 或 source.globalVars 时，请避免注入整个 process.env 对象，比如下面的用法是不推荐的：\n\n\n\n如果你采用了上述用法，将会导致如下问题：\n\n 1. 额外注入了一些未使用的环境变量，导致开发环境的环境变量被泄露到前端代码中。\n 2. 由于每一处 process.env 代码都会被替换为完整的环境变量对象，导致前端代码的包体积增加，性能降低。\n\n因此，请按照实际需求来注入 process.env 上的环境变量，避免全量注入。\n\n\n设置环境变量#\n\n针对设置环境变量的高频场景，Builder 还提供了 source.globalVars 配置用于简化配置，它是 source.define\n的一个语法糖，唯一的区别是 source.globalVars 会自动将传入的值进行 JSON 序列化处理，这使得设置环境变量的值更容易，避免大量书写\nJSON.stringify(...) 转换语句：\n\n\n\n需要注意的是不论以上哪种方式都只会匹配完整的表达式，对表达式进行解构会让 Builder 无法正确识别：\n\n\n\n\n声明环境变量类型#\n\n当你在 TypeScript 代码中读取环境变量时，TypeScript 可能会提示该变量缺少类型定义，此时你需要添加相应的类型声明。\n\n比如你引用了一个 CUSTOM_VAR 变量，在 TypeScript 文件中会出现如下提示：\n\n\n\n此时，你可以在项目中创建 src/env.d.ts 文件，并添加以下内容即可：\n\n\n\n\nTree Shaking#\n\nDefine 还可以用于标记死代码以协助 Builder 进行 Tree Shaking 优化。\n\n例如通过将 process.env.REGION 替换为具体值来实现针对不同地区的产物进行差异化构建：\n\n\n\n这样设置后对于存在地区控制的代码：\n\n\n\n指定环境变量 REGION=sg 并执行构建得到的产物会被剔除多余的代码：\n\n\n\n未用到的组件不会被打包到产物中，它们的外部依赖也会对应地被优化，最终即可得到体积和性能都更优的产物代码。\n\n\n源码内联测试#\n\nVitest 支持将测试写在源码文件内，能够在不导出的情况下测试私有功能的行为，并且通过设置 Define 来在正式构建时剔除测试代码。详细指南请参考\nVitest 官方文档。\n\n","routePath":"/builder/guide/advanced/define","lang":"zh","toc":[{"text":"默认环境变量","id":"默认环境变量","depth":2,"charIndex":75},{"text":"process.env.NODE_ENV","id":"processenvnode_env","depth":3,"charIndex":85},{"text":"process.env.ASSET_PREFIX","id":"processenvasset_prefix","depth":3,"charIndex":334},{"text":"使用 define 配置项","id":"使用-define-配置项","depth":2,"charIndex":673},{"text":"替换表达式","id":"替换表达式","depth":3,"charIndex":877},{"text":"process.env 注入方式","id":"processenv-注入方式","depth":3,"charIndex":1282},{"text":"设置环境变量","id":"设置环境变量","depth":2,"charIndex":1548},{"text":"声明环境变量类型","id":"声明环境变量类型","depth":2,"charIndex":1790},{"text":"Tree Shaking","id":"tree-shaking","depth":2,"charIndex":1965},{"text":"源码内联测试","id":"源码内联测试","depth":2,"charIndex":2202}],"domain":"","frontmatter":{},"version":""},{"id":68,"title":"模块热更新","content":"#\n\n模块热更新（HMR - hot module\nreplacement）功能会在应用程序运行过程中，替换、添加或删除模块，而无需重新加载整个页面。主要是通过以下几种方式，来显著加快开发速度：\n\n * 保留在完全重新加载页面期间丢失的应用程序状态。\n * 只更新变更内容，以节省宝贵的开发时间。\n * 在源代码中 CSS/JS 产生修改时，会立刻在浏览器中进行更新，这几乎相当于在浏览器 devtools 直接更改样式。\n\n\n启用 HMR#\n\nBuilder 已内置了对 HMR 的支持，在开发环境下默认启用。\n\n如果你不需要使用 HMR 能力，可以将 dev.hmr 设置为 false，此时将不再提供热更新和 react-refresh 功能。\n\n\n\n\n自定义 HMR URL#\n\n在默认情况下，Builder 使用当前页面的 host 和端口号来拼接 HMR 对应的 WebSocket URL。\n\n当出现 HMR 连接失败的情况时，你可以通过自定义 devServer.client 配置的方式来指定 WebSocket URL。\n\n\n默认配置#\n\n默认配置如下，Builder 会根据当前页面的 location 自动推导 WebSocket 请求的 URL：\n\n\n\n\n线上代理#\n\n如果你将一个线上页面代理到本地进行开发，WebSocket 请求将会连接失败。此时你可以尝试将 devServer.client 配置成如下值，使 HMR\n请求能打到本地的 Dev Server。\n\n\n\n\nLive reloading 和 Hot reloading 的区别#\n\n * Live reloading: 修改文件之后，webpack 重新编译，并强制刷新浏览器，属于全局（整个应用）刷新，相当于\n   window.location.reload()；\n * Hot reloading: 修改文件之后，webpack 重新编译对应模块，刷新时可以记住应用的状态，从而做到局部刷新，即热更新。\n\nDevServer 提供了 hot 和 liveReload 这两个配置项来控制更新方式。当 hot 和 liveReload 同时开启时，DevServer\n会优先尝试使用 hot 模式 (HMR)，如果 HMR 更新失败后，会降级到重新加载页面。\n\n\n常见问题#\n\n请参考 热更新问题。","routePath":"/builder/guide/advanced/hmr","lang":"zh","toc":[{"text":"启用 HMR","id":"启用-hmr","depth":2,"charIndex":213},{"text":"自定义 HMR URL","id":"自定义-hmr-url","depth":2,"charIndex":329},{"text":"默认配置","id":"默认配置","depth":3,"charIndex":472},{"text":"线上代理","id":"线上代理","depth":3,"charIndex":540},{"text":"Live reloading 和 Hot reloading 的区别","id":"live-reloading-和-hot-reloading-的区别","depth":2,"charIndex":650},{"text":"常见问题","id":"常见问题","depth":2,"charIndex":980}],"domain":"","frontmatter":{},"version":""},{"id":69,"title":"开启 REM 适配","content":"#\n\nBuilder 支持通过 output.convertToRem 一键开启 REM\n适配能力，能够根据屏幕大小来动态调整字体大小，让网页在不同大小的屏幕上都能够自适应显示。\n\n\n开启 REM 的适配能力#\n\n开启 convertToRem 后，会对页面进行如下两个操作：\n\n 1. 将 CSS 属性中的 px 转成 rem。\n 2. 对根元素的字体大小进行动态设置。\n\n\n\n\nCSS 属性值转换#\n\n由于默认的 rootFontSize 为 50。开启 rem 转换后，会按照 1rem = 50px 的比例，对 CSS 样式做如下转换：\n\n\n\nBuilder 默认会对所有 CSS 属性进行转换，如果希望仅对 font-size 属性进行转换，可通过设置 pxtorem.propList 实现。\n\n\n\n\n根元素字体大小计算#\n\n页面根元素的字体大小的计算公式为：\n\n\n\n以屏幕宽度为 390 的手机端浏览器为例，根元素字体值的默认值为 50， UI 设计图宽度为 375。\n\n此时计算出的页面根元素的字体大小为 52 (390 * 50 / 375)。 此时 1 rem 为 52px，CSS 样式中的 32px（0.64\nrem），实际页面效果为 33.28 px。\n\n\n\n\n自定义最大根元素字体值#\n\n在桌面浏览器端，根据计算公式得到的页面根元素字体值往往过大，当计算出的结果超出了默认的最大根元素字体值时，则采用当前设置的最大根元素字体值为当前根元素字体值。\n\n以屏幕宽度为 1920 的桌面浏览器为例，此时计算出的根元素的字体大小为 349，超出了最大根元素字体值 64。则采用 64 为当前的根元素字体值。\n\n\n\n\n如何判断 REM 是否生效？#\n\n 1. CSS：查看生成的 .css 文件中对应属性的值是否从 px 转换成 rem。\n 2. HTML：打开页面控制台查看 document.documentElement.style.fontSize 是否存在有效值。\n\n\n如何获取页面实际生效的 rootFontSize 值？#\n\n页面实际生效的 rootFontSize 会根据当前页面的情况动态计算。 可通过打印\ndocument.documentElement.style.fontSize 查看，也可通过 window.ROOT_FONT_SIZE 获取。","routePath":"/builder/guide/advanced/rem","lang":"zh","toc":[{"text":"开启 REM 的适配能力","id":"开启-rem-的适配能力","depth":2,"charIndex":91},{"text":"CSS 属性值转换","id":"css-属性值转换","depth":2,"charIndex":190},{"text":"根元素字体大小计算","id":"根元素字体大小计算","depth":2,"charIndex":356},{"text":"自定义最大根元素字体值","id":"自定义最大根元素字体值","depth":2,"charIndex":543},{"text":"如何判断 REM 是否生效？","id":"如何判断-rem-是否生效","depth":2,"charIndex":717},{"text":"如何获取页面实际生效的 rootFontSize 值？","id":"如何获取页面实际生效的-rootfontsize-值","depth":2,"charIndex":848}],"domain":"","frontmatter":{},"version":""},{"id":70,"title":"使用 Rspack","content":"#\n\n这篇文档会向你介绍如何在 Builder 中开启 Rspack 构建模式。\n\n什么是 Rspack\n\nRspack 是一个基于 Rust 的高性能 Web 构建工具，具备与 webpack 生态系统的互操作性，可以被 webpack\n项目低成本集成，并提供更好的构建性能。\n\n相较于 webpack，Rspack 的构建性能有明显提升，除了 Rust 带来的语言优势，这也来自于它的并行架构和增量编译等特性。经过 benchmark\n验证，Rspack 可以带来 5 ～ 10 倍编译性能的提升。\n\n\n启用 Rspack#\n\n\n在 Modern.js 框架中启用#\n\nModern.js 框架默认使用 webpack 作为打包工具。如果希望启用 Rspack 作为打包工具，可参考：使用 Rspack。\n\n\n在前端框架中接入#\n\n如果你基于 Builder 开发了一个前端框架，接入 rspack-provider 和 接入 webpack-provider 的方式类似，只需要把依赖从\n@modern-js/builder-webpack-provider 改为 @modern-js/builder-rspack-provider 即可。\n\n\n\n\n\n\n注意事项#\n\n在使用 Rspack 之前，请留意 Rspack 仍然是一个早期项目，当前还处于快速迭代阶段。因此，你需要预先了解以下事项：\n\n * Rspack 的 API 和配置项还不稳定，同时 Modern.js 对 Rspack 的支持属于实验性的，因此在后续的非 major\n   版本中，可能会引入不兼容更新。\n * Rspack 并未实现完整的 webpack 优化能力（如 tree shaking、bundle splitting、scope hoist\n   等能力，我们将在 6 ～ 12 月持续补齐相关优化能力），迁移到 Rspack 后，你可能会发现产物的包体积相较 webpack 有一定程度的增加。\n * Rspack 目前基于 SWC 进行代码编译和压缩，由于 SWC 的成熟度不及 babel 和 terser，因此你可能会遇到 SWC 的 bug。\n * Rspack 模式兼容了大部分 webpack 生态的插件和 loaders，但仍有部分插件和 loaders 暂时无法使用。\n\nRspack 正在积极改善上述问题，并计划在未来的版本中逐步解决它们。我们建议在决定是否使用 Rspack\n之前，评估你的项目需求和风险承受能力。如果你的项目对稳定性和性能要求较高，可以先选择更成熟的\nwebpack。如果你愿意尝试新的工具并为其发展做出贡献，我们欢迎你使用 Rspack，并提供反馈和报告问题，以帮助改进它的稳定性和功能。\n\n\n从 webpack 迁移到 Rspack#\n\nBuilder 旨在消除不同打包工具之间的主要差异，帮助用户以较低成本进行迁移。但由于各个打包工具提供的能力不同，你仍需要了解其中的部分差异。\n\n本文将从 Builder 的角度介绍 webpack 和 Rspack 之间的区别。如果需要了解更深层次的差异，请参考 Rspack 文档。\n\n\n1. Builder 配置差异#\n\n目前，Builder 内大部分的配置项已经适配了 Rspack，但仍有部分配置在支持中。\n\nSource Config#\n\n> Builder 中与源代码解析、编译方式相关的配置。\n\n不支持的配置项及能力包括：\n\n * source.include (issue 追踪)\n * source.exclude (issue 追踪)\n * source.moduleScopes (issue 追踪)\n\nHtml Config#\n\n> Builder 中与 HTML 有关的配置。\n\n所有 html 下的配置项及能力在 Rspack 内均可使用。\n\nSecurity Config#\n\n> Builder 中与安全有关的配置。\n\n不支持的配置项及能力包括：\n\n * security.sri (issue 追踪)\n\nDev Config#\n\n> Builder 中与本地开发有关的配置。\n\n所有 dev 下的配置项及能力在 Rspack 内均可使用。\n\nOutput Config#\n\n> Builder 中与构建产物有关的配置。\n\n不支持的配置项及能力包括：\n\n * output.enableInlineScripts\n * output.polyfill.usage (issue 追踪)\n\nExperiments Config#\n\n> Builder 中的一些实验性配置。\n\n不支持的配置项及能力包括：\n\n * experiments.lazyCompilation\n\nPerformance Config#\n\n> Builder 中与性能有关的配置。\n\n不支持的配置项及能力包括：\n\n * performance.buildCache\n * performance.chunkSplit (split-by-module)\n\nTools Config#\n\n> Builder 中与底层工具有关的配置。\n\n不支持的配置项包括：\n\n * tools.terser\n * tools.cssExtract\n * tools.cssLoader (仅在 disableCssExtract 时支持)\n * tools.styledComponents\n * tools.tsLoader\n * tools.webpack：使用 tools.rspack 代替。\n * tools.webpackChain：使用 tools.bundlerChain 代替。\n\nTIP\n\n除上述配置外，一些已支持的配置可能存在能力差异，请参考各配置 API 获取具体差异信息。\n\n\n2. 从 tools.webpackChain 迁移至 tools.bundlerChain#\n\nBuilder 支持通过 bundlerChain 来修改 Rspack config。通过 bundlerChain 修改的配置，在 webpack 和\nRspack 构建时均可生效。\n\n\n\nTIP\n\nbundlerChain 只为 Rspack & webpack 配置提供一致的 api 修改方式，实际 plugin / loader 是否可用，需要看\nRspack / webpack 实际支持情况。\n\nCHAIN_ID 差异#\n\n因为 webpack 和 Rspack 的一些实现差异，所以在规则配置上会有些不同。\n\n可通过 tools.bundlerChain#CHAIN_ID 查看所有在 Rspack & webpack 中都支持的规则。\n\n\n3. 从 tools.webpack 迁移至 tools.rspack#\n\nBundlerChain 只支持修改 Rspack & webpack 交集部分，更多 Rspack 独有功能，需要通过 tools.rspack 修改。\n\n在修改 Rspack 配置之前，你可能需要了解 Rspack 和 Webpack 的配置兼容性。\n\n\n\n关于 Rspack 的详细配置信息，请参考 Rspack 官网。\n\n\n4. Babel 配置迁移#\n\nRspack 默认会使用 SWC 进行转译和压缩，因此，在启用 Rspack 构建时，babel-loader 默认不会被启用。\n\n对于大部分常见的 Babel 插件，你可以在 Rspack 中找到对应的替代品，同时 Builder 也提供了一些相应的配置项。\n\nBABEL 插件                                          RSPACK 配置项              BUILDER 配置项\n@babel/preset-env                                 builtins.presetEnv      设置浏览器范围、浏览器兼容性\n@babel/preset-react                               builtins.react          模块热更新\n@emotion/babel-plugin                             builtins.emotion        暂无\nbabel-plugin-import                               builtins.pluginImport   source.transformImport\nbabel-plugin-lodash                               暂无                      暂无\nbabel-plugin-styled-components                    暂无                      暂无\n@babel/plugin-react-transform-remove-prop-types   暂无                      暂无\n\nTIP\n\n在使用 Rspack 构建时，仍然支持通过 tools.babel 配置 Babel 插件，但会产生额外的编译开销，在一定程度上拖慢 Rspack 构建速度。\n\n\n5. SWC 配置支持#\n\nRspack 中已内置了一部分的 swc 配置支持，如 builtins.react 等，可参考 Builtins。\n\n暂不支持在 Rspack 中添加 swc 插件和更多自定义配置，相关需求可追踪对应 issue 进度。\n\n\n6. Webpack Plugin 插件迁移#\n\n目前 Rspack 中兼容的 webpack 插件有限，当你的项目中有用到以下插件（或间接依赖）时，需要暂时将该插件移除或使用替代方案，否则不支持切换至\nRspack 构建：\n\n * webpack-retry-chunk-load-plugin：使用 output.assetsRetry 代替。\n * webpack.ProviderPlugin：使用 builtins.provide 代替。\n * webpack.DefinePlugin：使用 builtins.define 代替。\n * webpack.ContextReplacementPlugin\n * ...\n\n具体插件支持情况可参考：Plugin 兼容情况。\n\n未列出的插件可根据 Rspack Plugin API 支持情况 自行判断。\n\n\n7. CSS Modules 配置迁移#\n\nRspack 模式下不支持通过 tools.cssLoader 修改 CSS Modules 配置，Builder 提供了 output.cssModules\n配置项，用来抹平 Rspack 模式和 webpack 模式下的实现差异。\n\n\n\n\nRspack 性能分析#\n\nBuilder 支持使用 RSPACK_PROFILE 环境变量来进行构建性能分析。\n\n\n\n执行该命令后会在当前产物目录下生成一个 rspack-profile-${timestamp} 文件夹，该文件夹下会包含\nlogging.json、trace.json 和 jscpuprofile.json 三个文件\n\n * trace.json：使用 tracing 细粒度地记录了 Rust 侧各个阶段的耗时，可以使用 ui.perfetto.dev 进行查看\n * jscpuprofile.json：使用 Node.js inspector 细粒度地记录了 JavaScript 侧的各个阶段的耗时，可以使用\n   speedscope.app 进行查看\n * logging.json：包含一些日志信息，粗粒度地记录了构建的各个阶段耗时\n\n\n对比 Rspack CLI#\n\nBuilder Rspack 构建模式对比 Rspack CLI 添加了很多开箱即用的能力，同时，这些能力的封装会带来一定程度上的性能开销和行为表现上的差异:\n\n功能                       描述                                                             相关链接\n浏览器兼容性                   Builder 会根据构建产物类型来设置不同的 Browserslist 默认值                       \nSourceMap 生成             Builder 默认根据环境生成不同的 SourceMap (Rspack CLI 中默认是 false)          \nSVG 转 React 组件           Builder 默认支持在 React 组件中引用 SVG 作为组件                             \n按需引入常用组件库                当项目中安装了 Ant Design 或 Arco Design 组件库时，Builder 会自动添加对应的按需引入能力   \n默认开启 TypeScript 类型检查     Builder 会默认通过 TS Checker 检查类型问题                                \n默认集成 PostCSS             Builder 内默认开启 PostCSS 编译，并内置 autoprefixer 等多个插件                \n使用 @rspack/html-plugin   Builder 内默认集成 @rspack/html-plugin 以支持更多 HTML 模版功能 (Rspack      \n                         CLI 中默认使用 builtins.html)\nDevServer                Builder 内基于 webpack-dev-middleware 实现 DevServer (Rspack CLI    \n                         使用 @rspack/dev-server)\n\n以上能力均提供可调整的配置选项，可以根据项目实际情况按需进行调整。\n\n更多内置能力，可参考 功能导航。\n\n\n常见问题#\n\n\n启用 Rspack 构建后，性能没有预期的快？#\n\n通常情况下，启用 Rspack 后，相较 Webpack 会有 5 到 10 倍的编译性能提升。\n\n目前已知以下行为会在一定程度上拖慢 Rspack 构建性能：\n\n使用依赖 Babel 实现的配置项或插件#\n\n在使用 Rspack 构建时，Builder 默认不会启用 babel-loader。但当项目中使用到依赖 Babel 实现的配置项或插件时，会额外添加\nbabel-loader 进行文件转译：\n\n * 通过 tools.babel 添加 Babel plugin\n * 使用 Modern.js SSR 功能\n * ...\n\n你可以通过开启调试模式 来查看最终生成的 Rspack 配置中是否存在 Babel 插件。\n\n开启 TypeScript 类型检查#\n\nBuilder 构建时会默认开启 TypeScript 类型检查。在大型项目中，类型检查的耗时可能远超过 Rspack\n本身的构建耗时，因此在生产环境构建时，该行为会在一定程度上拖慢构建速度。\n\n此时，可通过 output.disableTsChecker 关闭类型检查，以查看排除类型检查后 Rspack 性能是否符合预期。\n\n大量 Less 文件#\n\n目前 Less 文件使用基于 JavaScript 实现的 less-loader 进行处理，未提供 Rust 版本，因此在处理大量 Less\n文件时会拖累构建性能。\n\nTIP\n\n在使用 Arco Design 等组件库时，请尽量避免全量引入 Less 样式。你可以改为按需引入，或直接引入 CSS 样式。\n\n大量 SVG 文件#\n\nBuilder 默认支持将 SVG 资源作为 React 组件使用，这会产生一定的性能开销。如果你不需要此能力，可以将 output.disableSvgr\n设置为 true 来关闭此行为，以提升构建性能。\n\n组件库未按需引入#\n\n默认情况下，在使用 Ant Design 或 Arco Design 组件库时，Builder 会自动开启按需引入功能，默认配置可参考\nsource.transformImport。\n\n在使用其他组件库时，如果该组件库支持按需引入，我们推荐优先通过 source.transformImport 配置按需引入。","routePath":"/builder/guide/advanced/rspack-start","lang":"zh","toc":[{"text":"启用 Rspack","id":"启用-rspack","depth":2,"charIndex":253},{"text":"在 Modern.js 框架中启用","id":"在-modernjs-框架中启用","depth":3,"charIndex":266},{"text":"在前端框架中接入","id":"在前端框架中接入","depth":3,"charIndex":356},{"text":"注意事项","id":"注意事项","depth":2,"charIndex":530},{"text":"从 webpack 迁移到 Rspack","id":"从-webpack-迁移到-rspack","depth":2,"charIndex":1163},{"text":"1. Builder 配置差异","id":"1-builder-配置差异","depth":3,"charIndex":1332},{"text":"Source Config","id":"source-config","depth":4,"charIndex":1396},{"text":"Html Config","id":"html-config","depth":4,"charIndex":1550},{"text":"Security Config","id":"security-config","depth":4,"charIndex":1623},{"text":"Dev Config","id":"dev-config","depth":4,"charIndex":1706},{"text":"Output Config","id":"output-config","depth":4,"charIndex":1775},{"text":"Experiments Config","id":"experiments-config","depth":4,"charIndex":1897},{"text":"Performance Config","id":"performance-config","depth":4,"charIndex":1987},{"text":"Tools Config","id":"tools-config","depth":4,"charIndex":2116},{"text":"2. 从 tools.webpackChain 迁移至 tools.bundlerChain","id":"2-从-toolswebpackchain-迁移至-toolsbundlerchain","depth":3,"charIndex":2431},{"text":"CHAIN_ID 差异","id":"chain_id-差异","depth":4,"charIndex":2686},{"text":"3. 从 tools.webpack 迁移至 tools.rspack","id":"3-从-toolswebpack-迁移至-toolsrspack","depth":3,"charIndex":2810},{"text":"4. Babel 配置迁移","id":"4-babel-配置迁移","depth":3,"charIndex":3014},{"text":"5. SWC 配置支持","id":"5-swc-配置支持","depth":3,"charIndex":3910},{"text":"6. Webpack Plugin 插件迁移","id":"6-webpack-plugin-插件迁移","depth":3,"charIndex":4038},{"text":"7. CSS Modules 配置迁移","id":"7-css-modules-配置迁移","depth":3,"charIndex":4421},{"text":"Rspack 性能分析","id":"rspack-性能分析","depth":2,"charIndex":4565},{"text":"对比 Rspack CLI","id":"对比-rspack-cli","depth":2,"charIndex":4952},{"text":"常见问题","id":"常见问题","depth":2,"charIndex":6007},{"text":"启用 Rspack 构建后，性能没有预期的快？","id":"启用-rspack-构建后性能没有预期的快","depth":3,"charIndex":6015}],"domain":"","frontmatter":{},"version":""},{"id":71,"title":"使用 Storybook","content":"#\n\nStorybook 是一个专门用于组件调试的工具，它围绕着组件开发提供了：\n\n * 丰富多样的调试能力\n * 可与一些测试工具结合使用\n * 可重复使用的文档内容\n * 可分享能力\n * 工作流程自动化\n\n在使用 Storybook 时，难免会遇到各种配置问题，需要手动配置 Babel 插件，手动配置 Webpack 去支持 less，sass 等。而\nModern.js builder 包含了许多强大的功能，使用 Modern.js builder 开发 Storybook 项目会极大的简化配置成本。\n\n使用 Modern.js builder 还可以一键在 Webpack 和 Rspack 之间进行切换。对于使用 Modern.js builder\n开发应用的用户，也可以很方便的直接使用现有的 Modern.js 配置用 Storybook 进行组件的测试。\n\n\n快速开始#\n\n在开始之前，当前 Storybook 支持底层使用 Webpack 或是 Rspack 进行构建，根据你的需求安装下列任何一个包：\n\n * @modern-js/builder-webpack-provider： 使用 Webpack 构建，更好的兼容性\n * @modern-js/builder-rspack-provider：使用 Rspack 构建，极致的启动速度（推荐）\n\n\n在 Modern.js 项目中使用, 没有使用过 Storybook 插件(@modern-js/plugin-storybook)#\n\n如果没有使用旧版本 Storybook 插件， 情直接使用如下命令开启 Storybook 功能。\n\n\n\n该命令会创建好 Storybook 常用的模版，包括\n\n * 创建配置文件夹 .storybook，以及默认配置文件 .storybook/main.ts\n * 创建 stories 组件示例\n * 更新 package.json，新增依赖 @storybook/addon-essential 和 @modern-js/storybook，以及创建\n   storybook 相关脚本\n\n运行 npm run storybook 即可启动 Storybook 预览。\n\n\n从 @modern-js/plugin-storybook 迁移#\n\n你仍然可以运行上方的命令，来创建模版以及修改 package.json，也可以手动升级。\n\n若你在旧版本对 storybook 进行了一些自定义配置，需要将配置文件 root/config/storybook/main.(j|t)s 移动到\nroot/.storybook/main.(j|t)s。\n\n并在 root/.storybook/main.(j|t)s 中添加以下配置，指定 framework 为 @modern-js/storybook：\n\n\n\n升级 @storybook/addon-* 系列依赖，升级到 7 版本。\n\n最后按照 Storybook 官网文档，对一些 breaking change 做相应的更新，例如 stories 的写法，MDX\n的写法等，参考storybook 迁移文档。\n\n在项目的 package.json 中添加相应的命令\n\n\n\n使用 npm run storybook 即可启动\n\n\n原生 Storybook 项目，没有使用 Modern.js#\n\n若当前 Storybook 版本还是 6，需要先按照 Storybook 官网文档升级到版本 7 ，参考storybook 迁移文档。\n\n\n\nModern.js 的配置文件默认为 modern.config.(j|t)s，配置请查看 builder 配置。\n\n若原来项目中包含了 Babel 等配置，需要对应的写在 modern 配置中，大部分 Babel 配置已经包含进了 Modern.js。\n\n安装完成后进行相应的配置。\n\n\n开启 Rspack 构建#\n\nRspack 构建速度非常快，在 Modern.js 中只需要如下配置即可使用 Rspack 作为构建工具。\n\n\n\n注意上面配置中，更改了 reactDocgen 配置，因为 Rspack 目前还不支持\n@storybook/react-docgen-typescript-plugin。 在启动前，确保已安装\n@modern-js/builder-rspack-provider 包。\n\n\n配置#\n\n在 .storybook/main.js 中包含一些配置。\n\n\nconfigPath#\n\n * 类型: string\n * 默认值: modern.config.(j|t)s\n\n用于指定配置文件路径。\n\n例如\n\n\n\n\nbundler#\n\n * 类型: 'webpack' | 'rspack'\n * 默认值: webpack\n\n指定底层构建工具使用 Webpack 还是 Rspack。请确保安装了对应的 provider，使用 Webpack 请安装\n@modern-js/builder-webpack-provider，使用 Rspack 请安装\n@modern-js/builder-rspack-provider。\n\n例如\n\n\n\n\nbuilderConfig#\n\n * 类型: BuilderConfig\n * 默认值: undefined\n\n更改 builder 的配置，该配置比配置文件拥有更高的优先级，若不想使用配置文件，也可直接在此处指定 Modern.js builder 配置。\n\n例如\n\n\n\n\n命令行#\n\n@modern-js/storybook 代理了部分 storybook cli 的命令。\n\n\nstorybook dev#\n\n启动 Storybook，详情请看 https://storybook.js.org/docs/react/api/cli-options#dev\n\n\nstorybook build#\n\n对 Storybook 进行生产环境构建，详情请看\nhttps://storybook.js.org/docs/react/api/cli-options#build\n\n\n配置文件#\n\n配置文件中除了 Modern.js builder 配置还包含一个额外的字段，builderPlugins，方便使用 builder 插件，例如启用 SWC\n编译。\n\n\n\n\nStorybook addon 兼容性#\n\n由于当前文档中的 Storybook 版本为 7，因此请选择 storybook V7 的 addon。\n\n当 addon 不需要额外的 Babel 或 Webpack 配置时，可以直接使用，如 @storybook/addon-essentials。\n\n部分 addon 需要依赖 babel 插件和 Webpack 配置时，如 @storybook/addon-coverage，只能使用\n@modern-js/builder-webpack-provider 才有支持。\n\n\n收益#\n\n使用 @modern-js/storybook 可以带给你 Rspack 超快的构建，并且完全无需繁琐配置，开箱即用。并且默认包含了许多 Web\n构建中的最佳实践，例如 code splitting 策略，内置 css module 和 postcss，开箱即用的 TypeScript 支持，内置常用\nBabel 插件等等。\n\nModern.js builder 强大的能力都可以直接在 Storybook 项目中使用。\n\n\nTrouble Shooting#\n\n 1. 使用 Modern.js builder 时不会读取 babel.config.json 等配置文件，因此 babel 配置需要在\n    tools.babel 中进行配置。 同样的 webpack 配置需要写在 tools.webpack 或 tools.webpackChain 中。\n\n 2. 如果发现构建速度很慢，请检查是否开启了自动文档生成功能，如果想要最高的性能，请配置为 react-docgen。react-docgen 和\n    react-docgen-typescript 的区别是，前者基于 Babel 实现，后者基于 TypeScript\n    实现，前者性能会更好，但类型推断能力更弱。如果使用 Rspack 构建，则只支持 react-docgen。\n\n","routePath":"/builder/guide/advanced/storybook","lang":"zh","toc":[{"text":"快速开始","id":"快速开始","depth":2,"charIndex":391},{"text":"在 Modern.js 项目中使用, 没有使用过 Storybook 插件(@modern-js/plugin-storybook)","id":"在-modernjs-项目中使用-没有使用过-storybook-插件modern-jsplugin-storybook","depth":3,"charIndex":591},{"text":"从 @modern-js/plugin-storybook 迁移","id":"从-modern-jsplugin-storybook-迁移","depth":3,"charIndex":950},{"text":"原生 Storybook 项目，没有使用 Modern.js","id":"原生-storybook-项目没有使用-modernjs","depth":3,"charIndex":1401},{"text":"开启 Rspack 构建","id":"开启-rspack-构建","depth":2,"charIndex":1650},{"text":"配置","id":"配置","depth":2,"charIndex":1861},{"text":"configPath","id":"configpath","depth":3,"charIndex":1898},{"text":"bundler","id":"bundler","depth":3,"charIndex":1975},{"text":"builderConfig","id":"builderconfig","depth":3,"charIndex":2187},{"text":"命令行","id":"命令行","depth":2,"charIndex":2325},{"text":"storybook dev","id":"storybook-dev","depth":3,"charIndex":2379},{"text":"storybook build","id":"storybook-build","depth":3,"charIndex":2471},{"text":"配置文件","id":"配置文件","depth":2,"charIndex":2575},{"text":"Storybook addon 兼容性","id":"storybook-addon-兼容性","depth":2,"charIndex":2669},{"text":"收益","id":"收益","depth":2,"charIndex":2932},{"text":"Trouble Shooting","id":"trouble-shooting","depth":2,"charIndex":3151}],"domain":"","frontmatter":{},"version":""},{"id":72,"title":"构建产物类型","content":"#\n\nBuilder 支持多种构建产物类型，分别适用于不同的目标运行环境。在设置正确的产物类型后，Builder\n会针对该环境优化打包结果，在构建过程中启用一些对应的插件或者配置。\n\n你可以通过 createBuilder 方法的 target 参数来设置产物类型。\n\n\n默认产物#\n\n默认情况下，target 会被设置为 'web'，并构建出运行在浏览器环境里的产物。\n\n同时，Builder 会读取项目中的 Browserslist 配置，以确定需要兼容的浏览器范围。\n\n\n可选类型#\n\n除了 'web' 外，你还可以将 target 设置为以下值：\n\n * 'node': 构建出运行在 Node.js 环境的产物，通常用于 SSR 等场景。\n * 'web-worker'：构建出运行在 Web Worker 里的产物。\n * 'modern-web'：构建出运行在现代浏览器里的产物。\n\n比如构建出适用于 Node.js 环境的产物：\n\n\n\n\n并行构建#\n\n当 target 为包含多个值的数组时，Builder 会并行构建，并生成多份不同的产物。\n\n比如同时构建浏览器产物和 SSR 产物：\n\n\n\n\nNode 产物#\n\n指运行在 Node.js 环境的产物，通常用于 SSR 等场景。\n\n当 target 设置为 'node' 时，Builder 会进行以下处理：\n\n * 不会生成 HTML 文件，与 HTML 相关的逻辑也不会执行，因为 Node.js 环境不需要 HTML。\n * 不会打包或抽取 CSS 代码，但产物中会包含 CSS Modules 的 id 信息。\n * 不会开启默认的拆包策略，但 dynamic import 依然可以生效。\n * 不会开启热更新相关的能力。\n * 将 Browserslist 的默认值调整为 ['node >= 14']。\n\nTIP\n\n如果触发了并行构建，比如同时构建 web 产物和 node 产物，那么上述处理不会影响 web 产物，web 产物所需的 HTML、CSS\n等文件依然会正确生成。\n\n\nWeb Worker 产物#\n\n指运行在 Web Worker 环境的产物。\n\nWeb Worker\n\nWeb Workers 是一种 JavaScript API，它允许网页在后台线程中执行脚本，与主线程（网页）分离。这意味着，您可以使用 Web Workers\n来执行计算密集型或长时间运行的任务，而无需阻塞主线程，进而影响网页的性能。\n\n当 target 设置为 'web-worker' 时，Builder 会进行以下处理：\n\n * 不会生成 HTML 文件，与 HTML 相关的逻辑也不会执行，因为 Web Worker 环境不需要 HTML。\n * 不会打包或抽取 CSS 代码，但产物中会包含 CSS Modules 的 id 信息。\n * 不会开启默认的拆包策略，并且 dynamic import 也不会生效，因为 Web Worker 仅运行支持单个 JavaScript 文件。\n * 不会开启热更新相关的能力。\n\n\nModern Web 产物#\n\n指运行在现代浏览器环境的产物。\n\n什么是现代浏览器?\n\n现代浏览器是我们的一个约定用语，指支持 原生 ES Modules 的浏览器。\n\n当 target 设置为 'modern-web' 时，Builder 会进行以下处理：\n\n * 将 Browserslist 的默认值调整为：\n\n","routePath":"/builder/guide/basic/build-target","lang":"zh","toc":[{"text":"默认产物","id":"默认产物","depth":2,"charIndex":135},{"text":"可选类型","id":"可选类型","depth":2,"charIndex":238},{"text":"并行构建","id":"并行构建","depth":2,"charIndex":426},{"text":"Node 产物","id":"node-产物","depth":2,"charIndex":505},{"text":"Web Worker 产物","id":"web-worker-产物","depth":2,"charIndex":882},{"text":"Modern Web 产物","id":"modern-web-产物","depth":2,"charIndex":1302}],"domain":"","frontmatter":{},"version":""},{"id":73,"title":"使用 Builder CLI","content":"#\n\nModern.js Builder 提供了一个轻量的 CLI 工具，包含 dev、build 等基础命令，它主要用于构建非 React 项目。\n\n * 对于 React 项目，我们建议直接使用 Modern.js 框架，参考 Modern.js - 快速上手。\n * 对于非 React 项目，比如开发一个 Vue 项目，那么你可以使用 Builder CLI 工具来构建你的项目。\n\n\n安装#\n\n你需要安装两个包，其中：\n\n * @modern-js/builder-cli：Builder 的 CLI 工具，提供基础的 CLI 命令，并会自动加载当前项目中安装的 Provider。\n\n * @modern-js/builder-rspack-provider：提供基于 webpack 或 Rspack 的构建能力。\n\n如果你想使用 webpack 而不是 Rspack，可以将 @modern-js/builder-rspack-provider 替换为\n@modern-js/builder-webpack-provider：\n\n\n命令#\n\nBuilder CLI 提供了以下命令，可以帮助你快速启动开发服务器、构建生产环境代码等。\n\n\nbuilder dev#\n\nbuilder dev 命令用于启动一个本地开发服务器，对源代码进行开发环境编译。\n\n\n\n\nbuilder build#\n\nbuilder build 命令默认会在 dist/ 目录下构建出可用于生产环境的产物。\n\n\n\n\nbuilder serve#\n\nbuilder serve 命令用于在本地预览生产环境构建的产物, 注意你需要提前执行 builder build 命令构建出对应产物。\n\n\n\n\n配置#\n\nBuilder CLI 默认会读取项目根目录下的 builder.config.ts 配置文件，你可以在配置文件中使用 Builder 提供的所有配置项。\n\n\n\n当你使用 Rspack 作为打包工具时，由于 webpack 和 Rspack 的配置类型存在一些差异，需要为 defineConfig 指定\n<'rspack'> 泛型：\n\n\n\n\n构建入口#\n\nBuilder CLI 默认会使用 src/index.(js|ts|jsx|tsx) 作为构建入口，你可以使用 source.entries\n配置项来修改构建入口。\n\n * 类型：\n\n\n\n * 默认值：\n\n\n\n * 示例：\n\n\n\n\n注册插件#\n\n你可以在 builder.config.ts 中使用 builderPlugins 选项来注册 Builder 插件。\n\n比如注册 Vue 插件：\n\n","routePath":"/builder/guide/basic/builder-cli","lang":"zh","toc":[{"text":"安装","id":"安装","depth":2,"charIndex":196},{"text":"命令","id":"命令","depth":2,"charIndex":473},{"text":"builder dev","id":"builder-dev","depth":3,"charIndex":526},{"text":"builder build","id":"builder-build","depth":3,"charIndex":586},{"text":"builder serve","id":"builder-serve","depth":3,"charIndex":651},{"text":"配置","id":"配置","depth":2,"charIndex":740},{"text":"构建入口","id":"构建入口","depth":2,"charIndex":917},{"text":"注册插件","id":"注册插件","depth":2,"charIndex":1041}],"domain":"","frontmatter":{},"version":""},{"id":74,"title":"Builder 配置项","content":"#\n\nBuilder 提供了丰富的配置项，以帮助使用者对构建行为进行定制。\n\n\n配置分类#\n\nBuilder 中的配置可以分为以下几类：\n\n * Dev Config：与本地开发有关的配置。\n * Html Config：与 HTML 有关的配置。\n * Tools Config：与底层工具有关的配置。\n * Source Config：与源代码解析、编译方式相关的配置。\n * Output Config：与构建产物有关的配置。\n * Security Config：与安全有关的配置。\n * Performance Config：与编译性能、产物性能有关的配置。\n\n你可以在 API Reference 页面找到所有配置项的详细说明。\n\n\n配置默认值#\n\nBuilder 为每个配置项预设了一个默认值，默认值可以满足大部分使用场景。同时，上层框架也会基于垂直场景的需求，覆盖一部分配置的默认值。\n\n因此，在大多数情况下，你不需要声明任何 Builder 配置，直接开箱使用即可。\n\n\n使用配置#\n\n\n在上层框架中使用#\n\n当你使用一个基于 Builder 的上层框架时，你可以直接通过框架的配置文件来定义 Builder 配置，上层框架会自动将相关配置透传给 Builder。\n\n比如在 Modern.js 框架中，你可以直接在 modern.config.ts 文件里定义 Builder 的 source.alias 配置：\n\n\n\n\n通过 Node API 使用#\n\n当你通过 Node API 调用 Builder 时，你可以通过 Provider 的 builderConfig 配置项来传入 Builder 配置：\n\n\n\n关于 Node API 的完整用法，请参考 API - createBuilder。\n\n\n与框架配置的关系#\n\n通常来说，Builder 配置是框架配置的子集。\n\nBuilder 配置只处理构建相关行为，而框架配置涵盖的范围更大，还包括运行时、服务端、部署等方面，因此框架是在 Builder 配置的基础上扩展出来的。\n\n\n调试配置#\n\n在执行构建时，你可以添加 DEBUG=builder 环境变量来开启 Builder 的调试模式。\n\n\n\n在调试模式下，Builder 会将内部最终生成的 Builder 配置写入到产物目录下，便于开发者查看和调试。\n\n\n\n打开生成的 /dist/builder.config.js 文件，即可查看 Builder 配置的完整内容。\n\n关于调试模式的完整介绍，请查看 开启调试模式 章节。","routePath":"/builder/guide/basic/builder-config","lang":"zh","toc":[{"text":"配置分类","id":"配置分类","depth":2,"charIndex":39},{"text":"配置默认值","id":"配置默认值","depth":2,"charIndex":322},{"text":"使用配置","id":"使用配置","depth":2,"charIndex":444},{"text":"在上层框架中使用","id":"在上层框架中使用","depth":3,"charIndex":452},{"text":"通过 Node API 使用","id":"通过-node-api-使用","depth":3,"charIndex":621},{"text":"与框架配置的关系","id":"与框架配置的关系","depth":2,"charIndex":763},{"text":"调试配置","id":"调试配置","depth":2,"charIndex":880}],"domain":"","frontmatter":{},"version":""},{"id":75,"title":"引用样式资源","content":"#\n\nBuilder 内置多种常用的样式资源处理方式，包括 Less / Sass 预处理器、PostCSS、CSS Modules、CSS 内联和 CSS 压缩。\n\n除此之外，Builder 也提供了多个配置项来自定义样式资源的处理规则。\n\n\n使用 Less、Sass 和 Stylus#\n\nBuilder 内置了社区流行的 CSS 预处理器，包括 Less 和 Sass。\n\n默认情况下，你不需要对 Less 和 Sass 进行任何配置。如果你有自定义 loader 配置的需求，可以通过配置 tools.less、tools.sass\n来进行设置。\n\n你也可以在 Builder 中使用 Stylus，只需要安装 Builder 提供的 Stylus 插件即可，使用方式请参考 Stylus 插件。\n\n\n使用 PostCSS#\n\nBuilder 内置了 PostCSS 来转换 CSS 代码。你可以通过 tools.postcss 来配置 postcss-loader。\n\n\n\n\n内置 PostCSS 插件#\n\nBuilder 内置了一些 PostCSS 插件，会对 CSS 进行以下转换：\n\n * autoprefixer：在默认情况下，我们开启了 autoprefixer 来自动补齐 CSS 的浏览器前缀。如果你需要配置目标浏览器，可使用\n   output.overrideBrowserslist 进行配置。\n * postcss-nesting：提供 CSS Nesting 支持，可以在 CSS 中使用嵌套写法，如：\n\n\n\n * postcss-flexbugs-fixes：用于修复已知的 Flex Bugs。\n * postcss-initial：仅在需要兼容低版本浏览器时启用，提供对 initial 属性值 的兼容。\n * postcss-page-break：仅在需要兼容低版本浏览器时启用，提供对 break- 属性 的兼容。\n * postcss-font-variant：仅在需要兼容低版本浏览器时启用，提供对 font-variant 的兼容。\n * postcss-media-minmax：仅在需要兼容低版本浏览器时启用，提供对 Media Query Ranges 的兼容。\n * postcss-custom-properties：仅在需要兼容低版本浏览器时启用，提供对 Custom Properties 的兼容，你可以在 CSS\n   中定义和使用自定义变量，如：\n\n\n\n\nCSS 压缩#\n\n通常情况下，在生产环境我们会将 CSS、JS 等静态资源进行压缩，以达到更好的传输效率。\n\nBuilder 通过 css-minimizer-webpack-plugin 在生产环境构建时自动压缩 CSS 代码（底层使用的压缩工具为 cssnano）。\n\n你可以通过 tools.minifyCss 配置项来修改 css-minimizer-webpack-plugin的配置。\n\n关于 cssnano\n\ncssnano 是一个用于优化和压缩 CSS 文件的工具。它通过删除未使用的规则、合并相同的规则、移除注释和空白符以及转换长度单位等方式来减小 CSS\n文件的体积，从而提升网站的加载速度。\n\n\n内联 CSS 文件#\n\n默认情况下，Builder 会把 CSS 提取为独立的 .css 文件，并输出到构建产物目录。\n\n如果你希望将样式内联到 JS 文件中，可以将 output.disableCssExtract 设置为 true 来禁用 CSS 提取逻辑。当浏览器请求到 JS\n文件后，JS 将动态地向 HTML 插入","routePath":"/builder/guide/basic/css-usage","lang":"zh","toc":[{"text":"使用 Less、Sass 和 Stylus","id":"使用-lesssass-和-stylus","depth":2,"charIndex":122},{"text":"使用 PostCSS","id":"使用-postcss","depth":2,"charIndex":354},{"text":"内置 PostCSS 插件","id":"内置-postcss-插件","depth":3,"charIndex":442},{"text":"CSS 压缩","id":"css-压缩","depth":2,"charIndex":1061},{"text":"内联 CSS 文件","id":"内联-css-文件","depth":2,"charIndex":1370},{"text":"引用 node_modules 里的样式","id":"引用-node_modules-里的样式","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":76,"title":"配置 HTML 模板","content":"#\n\n在构建的过程中，Builder 会基于 HTML 模板文件和模板参数进行编译，生成若干份 HTML 文件。\n\nBuilder 提供了一些配置项来对 HTML 模板进行设置。通过本章节你可以了解到这些配置项的基本用法。\n\n\n设置模板文件#\n\n通常来说，HTML 模板文件是由上层框架预先定义的。\n\n比如在 Modern.js 框架中，默认会预设一份 HTML 模板，同时也支持用户自定义模板的内容。你可以阅读 「Modern.js - HTML 模板」\n章节来了解相关内容。\n\n在 Builder 中，你可以使用 html.template 和 html.templateByEntries 配置项来设置自定义的 HTML 模板文件。\n\n\n\n\n设置页面标题#\n\n你可以通过 html.title 和 html.titleByEntries 配置项来设置 HTML 的 </code> 标签。</p>\n<p>当你的项目中只有一个页面时，直接使用 <code>html.title</code> 设置即可：</p> <pre><code>export\ndefault { html: { title: 'example', }, }; </code></pre> <p>当你的项目中有多个页面时，请使用\n<code>html.titleByEntries</code> 来为不同的页面设置对应的标题，<code>html.titleByEntries</code>\n使用页面的「入口名称」作为 key。</p> <pre><code>export default { html: { titleByEntries: {\nfoo: 'Foo', bar: 'Bar', }, }, }; </code></pre> <h2 id=\"设置页面图标\">设置页面图标<a\naria-hidden=\"true\" href=\"#设置页面图标\">#</a></h2> <p>Builder 支持设置 <a\nhref=\"https://developer.mozilla.org/en-US/docs/Glossary/Favicon\" target=\"_blank\"\nrel=\"noopener noreferrer\">favicon</a> 图标 和 iOS 系统下的 <a\nhref=\"https://webhint.io/docs/user-guide/hints/hint-apple-touch-icons/\"\ntarget=\"_blank\" rel=\"noopener noreferrer\">apple-touch-icon</a> 图标。</p> <p>你可以通过\n<a href=\"/api/config-html#htmlfavicon\">html.favicon</a> 和 <a\nhref=\"/api/config-html#htmlfaviconbyentries\">html.faviconByEntries</a> 配置项来设置\nfavicon 图标。</p> <pre><code>export default { html: { favicon:\n'./src/assets/icon.png', }, }; </code></pre> <p>也可以通过 <a\nhref=\"/api/config-html#htmlappicon\">html.appIcon</a> 配置项来设置 iOS 系统下的\napple-touch-icon 图标。</p> <pre><code>export default { html: { appIcon:\n'./src/assets/icon.png', }, }; </code></pre> <h2 id=\"设置-meta-标签\">设置 meta 标签<a\naria-hidden=\"true\" href=\"#设置-meta-标签\">#</a></h2> <p>你可以通过 <a\nhref=\"/api/config-html#htmlmeta\">html.meta</a> 和 <a\nhref=\"/api/config-html#htmlmetabyentries\">html.metaByEntries</a> 配置项来设置 HTML 的\n<code><meta></code> 标签。</p> <p>比如设置 description：</p> <pre><code>export default {\nhtml: { meta: { description: 'a description of the page', }, }, }; </code></pre>\n<p>最终在 HTML 中生成的 meta 标签为：</p> <pre><code><meta name=\"description\" content=\"a\ndescription of the page\" /> </code></pre> <h2 id=\"设置模板参数\">设置模板参数<a\naria-hidden=\"true\" href=\"#设置模板参数\">#</a></h2> <p>在 HTML 模板中，你可以使用丰富的模板参数，Builder\n默认注入的模板参数包括：</p> <pre><code>type DefaultParameters = { meta: string; // 对应\nhtml.meta 配置 title: string; // 对应 html.title 配置 mountId: string; // 对应\nhtml.mountId 配置 entryName: string; // 入口名称 assetPrefix: string; // 对应\noutput.assetPrefix 配置 compilation: webpack.Compilation; // 对应 webpack 的\ncompilation 对象 webpackConfig: Configuration; // webpack 配置 // htmlWebpackPlugin\n内置的参数 // 详见 https://github.com/jantimon/html-webpack-plugin htmlWebpackPlugin: {\ntags: object; files: object; options: object; }; }; </code></pre> <p>你也可以通过 <a\nhref=\"/api/config-html#htmltemplateparameters\">html.templateParameters</a> 和 <a\nhref=\"/api/config-html#htmltemplateparametersbyentries\">html.templateParametersB\nyEntries</a> 配置项来传入自定义的模板参数。</p> <p>比如：</p> <pre><code>export default { html: {\ntemplateParameters: { text: 'World', }, }, }; </code></pre> <p>接下来，你可以在 HTML\n模板中，通过 <code><%= text %></code> 来读取参数：</p> <pre><code><div>hello <%= text\n%>!</div> </code></pre> <p>经过编译后的最终 HTML 代码如下：</p> <pre><code><div>hello\nworld!</div> </code></pre> <h2 id=\"模板引擎\">模板引擎<a aria-hidden=\"true\"\nhref=\"#模板引擎\">#</a></h2> <p>Builder 支持 <a\nhref=\"https://www.lodashjs.com/docs/lodash.template\" target=\"_blank\"\nrel=\"noopener noreferrer\">Lodash Template</a>、<a href=\"https://ejs.co/\"\ntarget=\"_blank\" rel=\"noopener noreferrer\">EJS</a>、<a href=\"https://pugjs.org/\"\ntarget=\"_blank\" rel=\"noopener noreferrer\">Pug</a> 等多个模板引擎，默认使用最基础的 Lodash\nTemplate 作为模板引擎。</p> <h3 id=\"lodash-template\"><a\nhref=\"https://www.lodashjs.com/docs/lodash.template\" target=\"_blank\"\nrel=\"noopener noreferrer\">Lodash Template</a><a aria-hidden=\"true\"\nhref=\"#lodash-template\">#</a></h3> <p>当模板文件的后缀为 <code>.html</code> 时，Builder 会使用\nLodash Template 对模板进行编译。</p> <p>例如，在模板中定义一个 <code>text</code> 参数，值为\n<code>'world'</code>，在构建时会自动将 <code><%= text %></code> 替换为对应的值。</p>\n<pre><code><!-- 输入 --> <div>hello <%= text %>!</div> <!-- 输出 --> <div>hello\nworld!</div> </code></pre> <p>请阅读 <a\nhref=\"https://www.lodashjs.com/docs/lodash.template\" target=\"_blank\"\nrel=\"noopener noreferrer\">Lodash Template</a> 文档来了解完整用法。</p> <h3 id=\"ejs\"><a\nhref=\"https://ejs.co/\" target=\"_blank\" rel=\"noopener noreferrer\">EJS</a><a\naria-hidden=\"true\" href=\"#ejs\">#</a></h3> <p>当模板文件的后缀为 <code>.ejs</code>\n时，Builder 会使用 EJS 模板引擎对模板进行编译。EJS 是一套简单的模板语言，支持直接在标签内书写简单、直白的 JavaScript 代码，并通过\nJavaScript 输出最终所需的 HTML。</p> <p>例如，你可以先通过 <a\nhref=\"/api/config-html#htmltemplate\">html.template</a> 配置项来引用一个\n<code>.ejs</code> 模板文件：</p> <pre><code>export default { html: { template:\n'./static/index.ejs', }, }; </code></pre> <p>接着在模板中定义一个 <code>user</code> 参数，值为\n<code>{ name: 'Jack' }</code>。在构建时，会自动将 <code><%= user.name %></code>\n替换为对应的值。</p> <pre><code><!-- 输入 --> <% if (user) { %> <h2><%= user.name %></h2>\n<% } %> <!-- 输出 --> <h2>Jack</h2> </code></pre> <p>请阅读 <a href=\"https://ejs.co/\"\ntarget=\"_blank\" rel=\"noopener noreferrer\">EJS</a> 文档来了解完整用法。</p> <h3 id=\"pug\"><a\nhref=\"https://pugjs.org/\" target=\"_blank\" rel=\"noopener noreferrer\">Pug</a><a\naria-hidden=\"true\" href=\"#pug\">#</a></h3> <p>当模板文件的后缀为 <code>.pug</code>\n时，Builder 会使用 Pug 模板引擎对模板进行编译。Pug 是一款健壮、灵活、功能丰富的模板引擎，专门为 Node.js 平台开发。</p> <p>使用\nPug 模板前，需要开启 <a href=\"/api/config-tools#toolspug\">tools.pug</a> 配置项，并通过 <a\nhref=\"/api/config-html#htmltemplate\">html.template</a> 配置项来引用一个\n<code>.pug</code> 模板文件：</p> <pre><code>export default { html: { template:\n'./static/index.pug', }, tools: { pug: true, }, }; </code></pre> <p>开启后，你可以在\n<code>.pug</code> 模板中使用 Pug 语法：</p> <pre><code><!-- 输入 --> p Hello #{text}! <!--\n输出 --> <p>Hello World!</p> </code></pre> <p>请阅读 <a href=\"https://pugjs.org/\"\ntarget=\"_blank\" rel=\"noopener noreferrer\">Pug</a> 文档来了解完整用法。</p> <h2\nid=\"注入标签\">注入标签<a aria-hidden=\"true\" href=\"#注入标签\">#</a></h2> <p>通过配置\n<code>html.tags</code> 选项可以在最终生成的 HTML 产物中插入任意标签。</p>\n<div><div>使用场景</div><div><p>前端应用的产物最终都会直接或间接地被 HTML 入口引用，但大多数时候直接向 HTML\n注入标签都并非首选。</p></div></div> <p>模版文件中可以通过 <code>htmlWebpackPlugin.tags</code>\n变量来访问需要最终注入到 HTML 的所有标签：</p> <pre><code><html> <head> <%=\nhtmlWebpackPlugin.tags.headTags %> </head> <body> <%=\nhtmlWebpackPlugin.tags.bodyTags %> </body> </html> </code></pre>\n<p><code>html.tags</code> 的作用就是调整这些模板变量进而修改 HTML，配置的具体定义参考 <a\nhref=\"/api/config-html#htmltags\">API References</a>。</p> <h3 id=\"对象形式\">对象形式<a\naria-hidden=\"true\" href=\"#对象形式\">#</a></h3> <pre><code>export default { output: {\nassetPrefix: '//example.com/' }, html: { tags: [ { tag: 'script', attrs: { src:\n'a.js' } }, { tag: 'script', attrs: { src: 'b.js' }, append: false }, { tag:\n'link', attrs: { href: 'style.css', rel: 'stylesheet' }, append: true } { tag:\n'link', attrs: { href: 'page.css', rel: 'stylesheet' }, publicPath: false } {\ntag: 'script', attrs: { src: 'c.js' }, head: false }, { tag: 'meta', attrs: {\nname: 'referrer', content: 'origin' } }, ], }, }; </code></pre> <p>标签最终的插入位置由\n<code>head</code> 和 <code>append</code>\n选项决定，两个配置相同的元素将被插入到相同区域，并且维持彼此之间的相对位置。</p> <p>标签默认会启用 <code>publicPath</code>\n配置，即会将 <code>output.assetPrefix</code> 的值拼接到 <code>script</code> 标签的\n<code>src</code> 等表示路径的属性上。</p> <p>所以以上配置构建出的 HTML 产物将会类似：</p> <pre><code><html>\n<head> <script src=\"//example.com/b.js\"></script> <link\nhref=\"//example.com/style.css\" rel=\"stylesheet\" /> <link href=\"page.css\"\nrel=\"stylesheet\" /> <!-- some other headTags... --> <script\nsrc=\"//example.com/a.js\"></script> <meta name=\"referrer\" content=\"origin\" />\n</head> <body> <!-- some other bodyTags... --> <script\nsrc=\"//example.com/c.js\"></script> </body> </html> </code></pre> <h3\nid=\"函数形式\">函数形式<a aria-hidden=\"true\" href=\"#函数形式\">#</a></h3>\n<p><code>html.tags</code> 也支持传入回调函数，常用于修改标签列表或是在插入标签的同时确保其相对位置：</p>\n<pre><code>export default { html: { tags: [ tags => { tags.splice(0, 1); }, {\ntag: 'script', attrs: { src: 'a.js' }, head: false }, { tag: 'script', attrs: {\nsrc: 'b.js' }, append: false }, { tag: 'script', attrs: { src: 'c.js' } }, tags\n=> [...tags, { tag: 'script', attrs: { src: 'd.js' } }], ], }, }; </code></pre>\n<p>最终产物将会类似：</p> <pre><code><html> <head> <!-- some other headTags... -->\n<script src=\"//example.com/c.js\"></script> <script\nsrc=\"//example.com/d.js\"></script> </head> <body> <!-- some other bodyTags...\n--> <script src=\"//example.com/a.js\"></script> </body> </html> </code></pre>","routePath":"/builder/guide/basic/html-template","lang":"zh","toc":[{"text":"设置模板文件","id":"设置模板文件","depth":2,"charIndex":113},{"text":"设置页面标题","id":"设置页面标题","depth":2,"charIndex":323},{"text":"设置页面图标","id":"设置页面图标","depth":2,"charIndex":-1},{"text":"设置 meta 标签","id":"设置-meta-标签","depth":2,"charIndex":-1},{"text":"设置模板参数","id":"设置模板参数","depth":2,"charIndex":-1},{"text":"模板引擎","id":"模板引擎","depth":2,"charIndex":-1},{"text":"Lodash Template","id":"lodash-template","depth":3,"charIndex":-1},{"text":"EJS","id":"ejs","depth":3,"charIndex":-1},{"text":"Pug","id":"pug","depth":3,"charIndex":-1},{"text":"注入标签","id":"注入标签","depth":2,"charIndex":-1},{"text":"对象形式","id":"对象形式","depth":3,"charIndex":-1},{"text":"函数形式","id":"函数形式","depth":3,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":77,"title":"使用 TypeScript","content":"#\n\nBuilder 对 TypeScript 的转译和类型检查做了默认支持，无需任何配置即可在项目中使用 .ts 和 .tsx 文件。\n\n\nTypeScript 转译#\n\nBuilder 有三种可选方式处理 TypeScript 文件。\n\nBabel\n\n在默认配置下，源码中所有的 TypeScript 文件会经过 Babel 转译。 可能你在查阅较老旧的资料时会发现，Babel 无法处理 const enum\n以及 namespace alias 语法，但是其实在 7.15 版本已经得到了支持。Babel 无需手动开启，直接在项目中使用 TypeScript\n文件即可。\n\nts-loader\n\nts-loader 使用 TypeScript 官方的 TSC 转译。当开启 ts-loader 后 TypeScript 文件不会再经过 Babel\n编译处理，但处理后的 JavaScript 产物仍然会由 Babel 进行语法降级以及 Polyfill 注入。\n\n开启 ts-loader(使用默认配置):\n\n\n\n更详细配置可见 tools.tsLoader。 如果开启 ts-loader，默认不会启用类型检查，只会进行转译。\n\nSWC\n\n如果想要更快的项目构建速度，并且项目没有依赖某些自定义的 Babel 插件，那么也可以选择 SWC 来对 JavaScript 和 TypeScript\n进行转译和压缩。Builder 的 SWC 插件默认支持 TypeScript, TSX, Decorator，使用方式可见 SWC 插件。\n\n\n为什么默认使用 Babel#\n\nBabel 除了没有类型检查以外，对 TypeScript 语法支持已经非常完善，而类型检查可以借助另外的工具更好地进行。转译到低版本的 JavaScript\n时，某些语法 Babel 会处理得更符合标准，例如 Babel 会将类成员初始化为 undefined，将类方法标记不可枚举等行为。如果启用\nts-loader，为了更精确的语法降级和 Polyfill，最后还是会将处理后的产物再次经过 Babel 处理，产生不必要的性能开销。\n\n\n类型检查#\n\n目前生产可用的类型检查工具只有官方的 TSC，TSC 类型检查耗时在大项目中往往是很慢的过程，Builder 中默认使用\ntsChecker(fork-ts-checker-webpack-plugin) 在构建过程中异步进行类型检查，不阻塞项目的启动。\n\n配置 tsChecker(使用默认配置):\n\n\n\n更多配置可见 tsChecker 配置。\n\n如果开启 ts-loader 并且手动配置了 compileOnly: false，请关闭 tsChecker，避免重复类型检查。\n\nSTC\n\nSWC 作者新开源的基于 Rust 的类型检查工具 STC 目前还不可用于生产，还在起步阶段，不推荐用于项目中，等待更成熟之后，我们会考虑集成到 Builder\n的 SWC 插件中作为实验功能，敬请期待。","routePath":"/builder/guide/basic/typescript","lang":"zh","toc":[{"text":"TypeScript 转译","id":"typescript-转译","depth":2,"charIndex":70},{"text":"为什么默认使用 Babel","id":"为什么默认使用-babel","depth":3,"charIndex":674},{"text":"类型检查","id":"类型检查","depth":2,"charIndex":912}],"domain":"","frontmatter":{},"version":""},{"id":78,"title":"开启调试模式","content":"#\n\n为了便于排查问题，Builder 提供了调试模式，你可以在执行构建时添加 DEBUG=builder 环境变量来开启 Builder 的调试模式。\n\n\n\n在调试模式下，Builder 会输出一些额外的日志信息，并将内部最终生成的 Builder 配置和 webpack 配置写入到产物目录下，便于开发者查看和调试。\n\n\n日志信息#\n\n在调试模式下，你会看到 Shell 中输出了一些额外的信息，其中以 debug 开头的是一些流程日志，表明 Builder 内部执行了哪些操作。\n\n\n\n此外，Shell 中还会输出以下日志，表示 Builder 将内部生成的构建配置写入到磁盘中，此时你可以打开这些配置文件来查看相应的内容。\n\n\n\n\nBuilder 配置文件#\n\n在调试模式下，Builder 会自动生成 dist/builder.config.js 文件，这里面包含了最终生成的 Builder\n配置。在这个文件里，你可以了解到你传入的 Builder 配置在经过框架层和 Builder 处理后的最终结果。\n\n该文件的大致结构如下：\n\n\n\n关于 Builder 配置项的完整介绍，请查看 Builder 配置项 章节。\n\n\nwebpack 配置文件#\n\n如果当前项目是使用 webpack 进行构建的，那么在调试模式下，Builder 还会自动生成 dist/webpack.config.web.js\n文件，这里面包含了最终生成的 webpack 配置。在这个文件里，你可以了解到 Builder 最终传递给 webpack 的配置里包含了哪些内容。\n\n该文件的大致结构如下：\n\n\n\n此外，如果项目配置了额外的构建产物类型，比如开启了框架的 SSR 能力（对应额外的 Node.js 构建产物），在 dist 目录会另外生成一份\nwebpack.config.node.js 文件，对应 SSR 构建时的 webpack 配置。\n\n关于 webpack 配置项的完整介绍，请查看 webpack 官方文档。\n\n\nRspack 配置文件#\n\n如果当前项目是使用 Rspack 进行构建的，那么在调试模式下，Builder 还会自动生成 dist/rspack.config.web.js\n文件，这里面包含了最终生成的 Rspack 配置。在这个文件里，你可以了解到 Builder 最终传递给 Rspack 的配置里包含了哪些内容。\n\n该文件的大致结构如下：\n\n\n\n关于 Rspack 配置项的完整介绍，请查看 Rspack 官方文档。","routePath":"/builder/guide/debug/debug-mode","lang":"zh","toc":[{"text":"日志信息","id":"日志信息","depth":2,"charIndex":162},{"text":"Builder 配置文件","id":"builder-配置文件","depth":2,"charIndex":319},{"text":"webpack 配置文件","id":"webpack-配置文件","depth":2,"charIndex":516},{"text":"Rspack 配置文件","id":"rspack-配置文件","depth":2,"charIndex":861}],"domain":"","frontmatter":{},"version":""},{"id":79,"title":"异常类问题","content":"#\n\n当前文档已移动至 Modern.js - 构建相关问题。","routePath":"/builder/guide/faq/exceptions","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":80,"title":"功能类问题","content":"#\n\n当前文档已移动至 Modern.js - 构建相关问题。","routePath":"/builder/guide/faq/features","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":81,"title":"通用类问题","content":"#\n\n\nModern.js Builder 和 Modern.js 的关系？#\n\nModern.js 的构建能力是基于 Modern.js Builder 实现的。\n\n在开发 Modern.js 的过程中，我们把 Builder 作为独立的模块进行设计，并明确划分 Builder 与 Modern.js 的职责界限。\n因此，Builder 可以脱离 Modern.js 框架使用，被单独应用于其他框架或场景。\n\n--------------------------------------------------------------------------------\n\n\nBuilder 能否用于构建工具库或组件库？#\n\nBuilder 专注于解决 Web 应用构建场景，我们不推荐你使用 Builder 来构建工具库或组件库。\n\n如果需要构建工具库或组件库，推荐使用 Modern.js Module 解决方案。\n\n--------------------------------------------------------------------------------\n\n\nBuilder 是否会接入 Turbopack？#\n\nBuilder 已经在对接 Rspack，并且目前 Turbopack 仅支持在 Next.js 中使用，因此 Builder 暂时没有接入 Turbopack\n的计划。\n\n> 你可以在 Rspack 的 介绍 中查看 Rspack 与 Turbopack 的对比。\n\n--------------------------------------------------------------------------------\n\n\nBuilder 是否会接入 Vite？#\n\nVite 是一个非常优秀的工具，但 Builder 的目标是使用 Rspack 替换 webpack，Rspack\n能提供极致的编译速度，同时能保持开发环境和生产环境的打包行为一致。\n\nBuilder 会聚焦于从 webpack 演进至 Rspack 的过程，因此不会接入 Vite。\n\n> 你可以在 Rspack 的 介绍 中查看 Rspack 与 Vite 的对比。","routePath":"/builder/guide/faq/general","lang":"zh","toc":[{"text":"Modern.js Builder 和 Modern.js 的关系？","id":"modernjs-builder-和-modernjs-的关系","depth":3,"charIndex":3},{"text":"Builder 能否用于构建工具库或组件库？","id":"builder-能否用于构建工具库或组件库","depth":3,"charIndex":289},{"text":"Builder 是否会接入 Turbopack？","id":"builder-是否会接入-turbopack","depth":3,"charIndex":495},{"text":"Builder 是否会接入 Vite？","id":"builder-是否会接入-vite","depth":3,"charIndex":740}],"domain":"","frontmatter":{},"version":""},{"id":82,"title":"热更新问题","content":"#\n\n当前文档已移动至 Modern.js - 热更新问题。","routePath":"/builder/guide/faq/hmr","lang":"zh","toc":[],"domain":"","frontmatter":{},"version":""},{"id":83,"title":"功能导航","content":"#\n\n注意事项\n\nModern.js Builder 已升级为 Rsbuild 独立品牌，当前文档将不再继续迭代。\n\n * 如果你在使用 Modern.js 框架，请直接访问 Modern.js 框架文档。\n * 如果你在使用 Modern.js Builder 的 CLI 或 Node API，可以轻松迁移到 Rsbuild，请访问 Rsbuild 仓库\n   了解更多。\n\n在这里，你可以了解到 Modern.js Builder 支持的主要功能。\n\n\nJavaScript 编译#\n\n功能              描述                                                    相关链接\nRspack 打包       可选功能，使用 Rspack 作为打包工具                                 \nBabel 编译        默认开启 Babel 编译，将 JavaScript 和 TypeScript 代码转换为向后兼容的    \n                JavaScript 语法\nTS 编译           默认通过 Babel 编译 TS 文件，支持切换为 ts-loader 编译                \nTS 类型检查         默认通过 TS Checker 检查类型问题                                \nJS 压缩           默认在生产环境构建时开启压缩                                        \nPolyfill 注入     默认会注入 core-js 等 Polyfill                              \nSourceMap 生成    默认在生产环境构建时生成高质量 SourceMap                             \n文件别名            可选功能，通过 alias 设置文件别名                                  \n限制源代码路径         可选功能，限制源代码的引用路径                                       \nesbuild 编译      可选功能，通过 esbuild 对 JavaScript 和 TypeScript 代码进行转译和压缩   \nSWC 编译          可选功能，通过 SWC 对 JavaScript 和 TypeScript 代码进行转译和压缩       \nNode 产物         可选功能，支持构建出运行在 Node.js 环境的 JavaScript 产物               \nWeb Worker 产物   可选功能，支持构建出运行在 Web Worker 环境的 JavaScript 产物            \n浏览器范围           可选功能，通过 browserslist 来设置 Web 应用需要兼容的浏览器范围             \n兼容性检查           可选功能，分析构建产物中是否存在当前浏览器范围下不兼容的高级语法                      \n注入环境变量          可选功能，向代码中注入环境变量或表达式                                   \nNode polyfill   可选功能，在浏览器端注入 Node 核心模块的 polyfills                     \n\n\nCSS 编译#\n\n功能                  描述                                      相关链接\nPostCSS 编译          默认开启 PostCSS 编译，内置 autoprefixer 等多个插件   \nSass 预处理            默认支持编译 Sass/Scss 文件                     \nLess 预处理            默认支持编译 Less 文件                          \nStylus 预处理          可选功能，编译 Stylus 文件                       \nCSS Modules 编译      默认支持编译 CSS Modules 文件                   \nCSS Modules 类型提示    可选功能，自动生成 CSS Modules 的类型定义文件           \nCSS 压缩              默认在生产环境构建时开启压缩                          \n抽取 CSS 文件           默认会将 CSS 抽取为独立的文件                       \nStyled Components   默认支持 styled-components 编译               \n内联 CSS 到 JS 中       可选功能，将 CSS 文件内联到 JS 文件中                 \nrem 单位转换            可选功能，将 CSS 中的 px 转成 rem 单位              \n\n\nHTML 编译#\n\n功能            描述                       相关链接\n设置标题          设置 HTML 的 title 标签       \n设置 meta       设置 HTML 的 meta 标签        \n设置 favicon    设置页面的 favicon 图标         \n设置 app 图标     设置 iOS 系统下的 apple icon   \n使用 EJS 模板引擎   可选功能，使用 EJS 模板语法         \n使用 Pug 模板引擎   可选功能，使用 Pug 模板语法         \n内联 JS 文件      可选功能，将 JS 内联到 HTML 中     \n内联 CSS 文件     可选功能，将 CSS 内联到 HTML 中    \n\n\n开发调试相关#\n\n功能                 描述                                     相关链接\n自动打开页面             可选功能，在启动 Dev Server 时自动在浏览器中打开页面 URL   \nHTTPS Dev Server   可选功能，开启 Dev Server 对 HTTPS 的支持         \n\n\n前端框架相关#\n\n功能               描述                           相关链接\nReact Refresh    默认支持 React Refresh 热更新       \nSVG 转 React 组件   默认支持在 React 组件中引用 SVG 作为组件   \nVue 3 SFC 编译     可选功能，开启 Vue 3 SFC 单文件组件编译    \nVue 3 JSX 编译     可选功能，开启 Vue 3 JSX 语法编译       \n\n\n静态资源相关#\n\n功能               描述                             相关链接\n引用图片资源           支持在代码中引用图片资源                   \n引用字体资源           支持在代码中引用字体资源                   \n引用视频资源           支持在代码中引用视频资源                   \n引用 Wasm 资源       支持在代码中引用 WebAssembly 资源        \n引用 node addons   支持在代码中引用 Node.js addons        -\n静态资源内联           默认将体积较小的图片等资源内联到 JS 中          \n清理静态资源           每次开始构建前，自动清理 dist 目录下的静态资源     \n拷贝静态资源           可选功能，将静态资源拷贝到 dist 目录下         \n生成 manifest 文件   可选功能，生成包含静态资源信息的 manifest 文件   \n\n\n性能相关#\n\n功能                描述                                    相关链接\n产物自动拆包            Builder 中内置了多种拆包策略，自动将代码包拆分为体积适中的文件   \n展示产物体积            在生产环境构建后，默认展示所有静态资源的体积信息              \n分析产物体积            可选功能，通过 Bundle Analyzer 分析产物体积        \n移除 console        可选功能，移除代码中的 console.xx                \n优化 moment.js 体积   可选功能，移除 moment.js 多余的 locale 文件       \n组件库按需引入           可选功能，按需引入组件库的代码和样式                    \n图片压缩              可选功能，对引用的图片资源进行压缩处理                   \nPreload           可选功能，对资源进行预加载                         \nPrefetch          可选功能，对资源进行预获取                         \nPreconnect        可选功能，对资源进行预连接                         \nDNS prefetch      可选功能，对资源进行 DNS 预获取                    ","routePath":"/builder/guide/features","lang":"zh","toc":[{"text":"JavaScript 编译","id":"javascript-编译","depth":2,"charIndex":229},{"text":"CSS 编译","id":"css-编译","depth":2,"charIndex":1559},{"text":"HTML 编译","id":"html-编译","depth":2,"charIndex":2306},{"text":"开发调试相关","id":"开发调试相关","depth":2,"charIndex":2682},{"text":"前端框架相关","id":"前端框架相关","depth":2,"charIndex":2874},{"text":"静态资源相关","id":"静态资源相关","depth":2,"charIndex":3124},{"text":"性能相关","id":"性能相关","depth":2,"charIndex":3630}],"domain":"","frontmatter":{},"version":""},{"id":84,"title":"构建 Vue 2 应用","content":"#\n\n尽管 Modern.js 框架是基于 React 实现的，但底层的 Modern.js Builder 并不与 React 耦合。因此，你可以使用\nModern.js Builder 来构建你的 Vue 应用，并使用 Modern.js Builder 提供的绝大多数能力。\n\n在这篇文档中，你可以了解到如何基于 Modern.js Builder 来构建一个 Vue 2 应用。\n\n\n示例项目#\n\n我们搭建了一个基于 Modern.js Builder 的 Vue 2 示例项目，你可以参考或直接克隆这个项目，并对照下文的指南来了解更多细节。\n\n * modern-js-examples - builder-vue2\n\n * modern-js-examples - builder-vue2-rspack\n\n\nCLI 工具#\n\n在开始构建 Vue 项目之前，你需要一个 CLI 工具来提供基本的命令。\n\n你可以直接使用 Builder 提供的 CLI 工具，也可以基于 Builder 的 Node API 搭建属于你自己的 CLI 工具。\n\n\n使用 Vue 插件#\n\n为了能够编译 Vue 的 SFC（单文件组件）和 JSX 语法，你需要注册 Builder 的 Vue 2 插件，插件会自动添加 Vue\n构建所需的配置，并移除内置的 React 相关配置。\n\n例如，在 builder.config.ts 中注册：\n\n\n\n\n类型定义#\n\n在 TypeScript 项目中，你需要为 *.vue 文件添加类型定义，使 TypeScript 能够正确识别它。\n\n请在 src 目录下创建 env.d.ts，并添加以下内容：\n\n","routePath":"/builder/guide/framework/vue2","lang":"zh","toc":[{"text":"示例项目","id":"示例项目","depth":2,"charIndex":195},{"text":"CLI 工具","id":"cli-工具","depth":2,"charIndex":360},{"text":"使用 Vue 插件","id":"使用-vue-插件","depth":2,"charIndex":478},{"text":"类型定义","id":"类型定义","depth":2,"charIndex":619}],"domain":"","frontmatter":{},"version":""},{"id":85,"title":"构建 Vue 3 应用","content":"#\n\n尽管 Modern.js 框架是基于 React 实现的，但底层的 Modern.js Builder 并不与 React 耦合。因此，你可以使用\nModern.js Builder 来构建你的 Vue 应用，并使用 Modern.js Builder 提供的绝大多数能力。\n\n在这篇文档中，你可以了解到如何基于 Modern.js Builder 来构建一个 Vue 3 应用。\n\n\n示例项目#\n\n我们搭建了一个基于 Modern.js Builder 的 Vue 3 示例项目，你可以参考或直接克隆这个项目，并对照下文的指南来了解更多细节。\n\n * modern-js-examples - builder-vue3\n\n * modern-js-examples - builder-vue3-rspack\n\n\nCLI 工具#\n\n在开始构建 Vue 项目之前，你需要一个 CLI 工具来提供基本的命令。\n\n你可以直接使用 Builder 提供的 CLI 工具，也可以基于 Builder 的 Node API 搭建属于你自己的 CLI 工具。\n\n\n使用 Vue 插件#\n\n为了能够编译 Vue 的 SFC（单文件组件）和 JSX 语法，你需要注册 Builder 的 Vue 插件，插件会自动添加 Vue\n构建所需的配置，并移除内置的 React 相关配置。\n\n例如，在 builder.config.ts 中注册：\n\n\n\n\n类型定义#\n\n在 TypeScript 项目中，你需要为 *.vue 文件添加类型定义，使 TypeScript 能够正确识别它。\n\n请在 src 目录下创建 env.d.ts，并添加以下内容：\n\n","routePath":"/builder/guide/framework/vue3","lang":"zh","toc":[{"text":"示例项目","id":"示例项目","depth":2,"charIndex":195},{"text":"CLI 工具","id":"cli-工具","depth":2,"charIndex":360},{"text":"使用 Vue 插件","id":"使用-vue-插件","depth":2,"charIndex":478},{"text":"类型定义","id":"类型定义","depth":2,"charIndex":617}],"domain":"","frontmatter":{},"version":""},{"id":86,"title":"名词解释","content":"#\n\n注意事项\n\nModern.js Builder 已升级为 Rsbuild 独立品牌，当前文档将不再继续迭代。\n\n * 如果你在使用 Modern.js 框架，请直接访问 Modern.js 框架文档。\n * 如果你在使用 Modern.js Builder 的 CLI 或 Node API，可以轻松迁移到 Rsbuild，请访问 Rsbuild 仓库\n   了解更多。\n\n\nBundler#\n\n指 webpack、Rspack 等模块打包工具。\n\n打包工具的主要目标是将 JavaScript、CSS 等文件打包在一起，打包后的文件可以在浏览器、Node.js 等环境中使用。当 Bundler 处理 Web\n应用时，它会构建一个依赖关系图，其中包含应用需要的各个模块，然后将所有模块打包成一个或多个 bundle。\n\n\nBuilder#\n\nModern.js Builder 指的是 Modern.js 的构建层，它的目标是为 Modern.js 用户提供开箱即用的构建能力，并支持在 webpack\n和 Rspack 间无缝切换。\n\nModern.js MAJOR_VERSION.46.0 之前版本使用的是 @modern-js/builder, 从 MAJOR_VERSION.46.0\n开始升级为 Rsbuild。\n\n\nBuilder Provider#\n\nBuilder Provider 是 Builder 的组成部分之一，Provider 基于特定 bundler 实现了对应的构建能力。\n\n目前 Builder 提供了两个 Provider：\n\n * @modern-js/builder-webpack-provider：底层基于 webpack 来实现。\n * @modern-js/builder-rspack-provider：底层基于 Rspack 来实现。\n\n\nMicro-frontend#\n\n微前端（Micro-frontend，简称\nMFE）是一种类似于微服务的架构，是一种由独立交付的多个前端应用组成整体的架构风格，它将前端应用分解成一些更小、更简单的能够独立开发、测试、部署的应用，而在用户\n看来仍然是内聚的单个产品。\n\n它主要解决了两个问题：\n\n * 随着项目迭代应用越来越庞大，难以维护。\n\n * 跨团队或跨部门协作开发项目导致效率低下的问题。\n\n\nModule Federation#\n\n模块联邦（Module Federation，简称 MF）是 Webpack 的一个特性。它允许 JavaScript\n应用从另一个应用动态加载代码，并在此过程中共享依赖关系。如果使用联邦模块的应用缺少联邦代码所需的依赖项，Webpack 将从该联邦的构建源下载缺失的依赖项。\n\n这使得可以创建微前端风格的应用程序，多个系统可以共享代码，并在不需要重新构建整个应用程序的情况下进行动态更新。\n\nModern.js 提供了一个 Module Federation 的示例项目，请参考 module-federation-examples -\nmodernjs。\n\n你也可以阅读 webpack Module Federation 文档 来了解更多概念。\n\n\nRspack#\n\nRspack 是一个基于 Rust 的高性能 Web 构建工具，具备与 webpack 生态系统的互操作性，可以被 webpack\n项目低成本集成，并提供更好的构建性能。\n\n相较于 webpack，Rspack 的构建性能有明显提升，除了 Rust 带来的语言优势，这也来自于它的并行架构和增量编译等特性。经过 benchmark\n验证，Rspack 可以带来 5 ～ 10 倍编译性能的提升。\n\n\nModern.js#\n\nModern.js 是字节跳动 Web 工程体系的开源版本，它提供多个解决方案，来帮助开发者解决不同研发场景下的问题。\n\n * Modern.js 代码仓库。\n\n\nEdenX#\n\n字节跳动内部的 Web 工程方案，基于 Modern.js 实现。","routePath":"/builder/guide/glossary","lang":"zh","toc":[{"text":"Bundler","id":"bundler","depth":2,"charIndex":190},{"text":"Builder","id":"builder","depth":2,"charIndex":364},{"text":"Builder Provider","id":"builder-provider","depth":2,"charIndex":568},{"text":"Micro-frontend","id":"micro-frontend","depth":2,"charIndex":799},{"text":"Module Federation","id":"module-federation","depth":2,"charIndex":1000},{"text":"Rspack","id":"rspack","depth":2,"charIndex":1348},{"text":"Modern.js","id":"modernjs","depth":2,"charIndex":1557},{"text":"EdenX","id":"edenx","depth":2,"charIndex":1651}],"domain":"","frontmatter":{},"version":""},{"id":87,"title":"介绍","content":"#\n\n注意事项\n\nModern.js Builder 已升级为 Rsbuild 独立品牌，当前文档将不再继续迭代。\n\n * 如果你在使用 Modern.js 框架，请直接访问 Modern.js 框架文档。\n * 如果你在使用 Modern.js Builder 的 CLI 或 Node API，可以轻松迁移到 Rsbuild，请访问 Rsbuild 仓库\n   了解更多。\n\nModern.js Builder 是一个基于 Rspack 的 Web 构建工具。\n\n随着前端生态的发展，社区中出现了多样化的编译工具和插件。对于大部分开发者来说，构建一个 Web\n应用所需的配置和依赖已变得十分复杂。在追求最佳实践的过程中，开发者需要付出的成本也在不断上升。\n\n为了减少构建的复杂性，降低上手门槛，我们基于 Modern.js 在 Web 应用构建方面的实践经验，抽象其中的构建能力，打造出 Modern.js\nBuilder 这个构建工具。\n\n\nRust 化#\n\n近年来，前端工具链的发展趋势是使用 Rust 等编程语言重新实现 —— 以获得更好的性能表现。社区中出现 Rspack、SWC\n等高性能工具，并且应用领域在逐步扩宽。但这些 Rust 工具与 JavaScript\n工具之间存在较多差异，包括功能不完整、配置不一致等，导致使用者需要承担一定的迁移成本。\n\n前端工具链 Rust 化的进程还会持续较长一段时间，Modern.js Builder 期望能帮助开发者更好地过渡到 Rust 工具。不管是\nJavaScript 工具，还是 Rust 工具，甚至是 webpack 等底层 bundler，在 Modern.js Builder\n中都是可替换的零部件。你可以通过开启配置或启用插件的方式，对这些零部件进行渐进式替换，Modern.js Builder\n会抹平其中的主要差异，帮助使用者进行低成本迁移。\n\n\n定位#\n\nModern.js Builder (简称 Builder) 的定位是服务于上层框架的构建工具，它专注于解决 Web\n应用构建面临的各类问题，期望能为前端框架提供开箱即用的构建能力。\n\n如果你正在开发一个前端框架，或是开发一个前端应用的脚手架，那么 Builder 可以为你完成前端框架中大部分与构建有关的逻辑，让你能够聚焦于实现框架的其他功能。\n\n如果你是一名业务开发者，大部分情况下，你不需要在业务项目中手动接入 Builder，我们推荐你直接使用一些基于 Builder 的上层框架。\n\n目前已经接入 Builder 的前端框架有：\n\n * 开源的 Modern.js 框架。\n * 字节跳动内部的 EdenX、PIA 等框架。\n\n\n特性#\n\n\n支持 Rspack 打包#\n\nBuilder 支持 webpack 和 Rspack 两种打包工具，你可以在成熟的 Webpack 和更快的 Rspack 之间进行切换。\n\n什么是 Rspack\n\nRspack 是一个基于 Rust 的高性能 Web 构建工具，具备与 webpack 生态系统的互操作性，可以被 webpack\n项目低成本集成，并提供更好的构建性能。\n\n相较于 webpack，Rspack 的构建性能有明显提升，除了 Rust 带来的语言优势，这也来自于它的并行架构和增量编译等特性。经过 benchmark\n验证，Rspack 可以带来 5 ～ 10 倍编译性能的提升。\n\n默认情况下，Builder 使用 webpack 5 作为打包工具，尽管 webpack\n的编译速度不是很理想，但它依然是社区中功能最完整、生态最丰富的打包工具。Builder 在 webpack 的基础上，集成了\nBabel、PostCSS、terser 等工具进行代码转义和压缩。Builder 也支持替换部分编译能力为原生工具来提升编译速度，比如将 Babel /\nterser 替换为 swc 或 esbuild。\n\n如果你对构建性能有更极致的需求，可以一键切换到 Rspack 构建模式，请参考 使用 Rspack 来进行切换。\n\n\n深度优化构建产物#\n\nBuilder 充分利用 webpack 生态内的各种优化手段，保证生产环境的产物性能得到深度优化，并在稳定性上提供保障。\n\n以拆包场景为例，webpack 原生的 splitChunks 配置较为复杂，Builder 将其封装为开箱即用的 performance.chunkSplit\n配置项，默认将常见的三方库拆分为体积适中的 chunk，使页面加载速度达到最优状态。\n\n\n易于扩展的插件系统#\n\nBuilder 提供丰富的配置项和可插拔的插件系统，支持对各项能力进行扩展和定制。\n\n对于 Builder 来说，所有的构建能力都是通过插件来实现的：\n\n * 大部分插件较为轻量，被内置在 Builder 内部，开发者可以通过配置项来控制启用。\n * 少部分插件较为复杂，被外置为独立 npm 包，开发者可以按需进行安装和使用。\n\nBuilder 也支持自定义插件，因此框架开发者可以开发自定义的插件，实现定制化的构建需求。\n\n\nnpm 包#\n\nBuilder 已发布的 npm 包有：\n\n包名                                         版本   描述\n@modern-js/builder                              Builder 核心包\n@modern-js/builder-cli                          Builder CLI 工具\n@modern-js/builder-webpack-provider             提供 webpack 构建能力\n@modern-js/builder-rspack-provider              提供 Rspack 构建能力\n@modern-js/builder-plugin-vue                   Vue 3 插件\n@modern-js/builder-plugin-vue2                  Vue 2 插件\n@modern-js/builder-plugin-swc                   SWC 插件\n@modern-js/builder-plugin-stylus                Stylus 插件\n@modern-js/builder-plugin-esbuild               Esbuild 插件\n@modern-js/builder-plugin-node-polyfill         Node Polyfill 插件\n@modern-js/builder-plugin-image-compress        Image Compress 插件\n@modern-js/builder-shared                       Builder 内部的公共模块\n@modern-js/builder-doc                          Builder 文档\n\n你可以在 modern.js 仓库的 packages/builder 目录下查看这些包的源代码。\n\n\n下一步#\n\n你可能想要：","routePath":"/builder/guide/introduction","lang":"zh","toc":[{"text":"Rust 化","id":"rust-化","depth":2,"charIndex":423},{"text":"定位","id":"定位","depth":2,"charIndex":812},{"text":"特性","id":"特性","depth":2,"charIndex":1137},{"text":"支持 Rspack 打包","id":"支持-rspack-打包","depth":3,"charIndex":1143},{"text":"深度优化构建产物","id":"深度优化构建产物","depth":3,"charIndex":1713},{"text":"易于扩展的插件系统","id":"易于扩展的插件系统","depth":3,"charIndex":1913},{"text":"npm 包","id":"npm-包","depth":2,"charIndex":2140},{"text":"下一步","id":"下一步","depth":2,"charIndex":3064}],"domain":"","frontmatter":{},"version":""},{"id":88,"title":"拆包最佳实践","content":"#\n\n良好的拆包策略对于提升应用的加载性能是十分重要的，可以充分利用浏览器的缓存机制，减少请求数量，加快页面加载速度。\n\n在 Builder 中内置了多种拆包策略，可以满足大部分应用的需求，你也可以根据自己的业务场景，自定义拆包配置。\n\n\n拆包策略#\n\n> Builder 的拆包配置集中在 performance.chunkSplit 中。\n\nBuilder 支持设置以下几种拆包策略：\n\n * split-by-experience: 根据经验制定的拆分策略，自动将一些常用的 npm 包拆分为体积适中的 chunk。\n * split-by-module: 按 NPM 包的粒度拆分，每个 NPM 包对应一个 chunk。\n * split-by-size：根据模块大小自动进行拆分。\n * all-in-one: 将所有代码全部打包到一个 chunk 中。\n * single-vendor: 将所有 NPM 包的代码打包到一个单独的 chunk 中。\n * custom: 自定义拆包配置。\n\n\nsplit-by-experience#\n\n分包策略#\n\nBuilder 默认采用 split-by-experience 策略，这是我们根据经验制定的策略。具体来说，当你的项目中引用了以下 npm\n包时，它们会自动被拆分为单独的 chunk：\n\n * lib-polyfill.js：包含 core-js，@babel/runtime，@swc/helpers，tslib。\n * lib-react.js：包含 react，react-dom。\n * lib-router.js：包含 react-router，react-router-dom，history，@remix-run/router。\n * lib-lodash.js：包含 lodash，lodash-es。\n * lib-antd.js：包含 antd。\n * lib-arco.js：包含 @arco-design/web-react 以及 @arco-design 组织下相关的包。\n * lib-semi.js：包含 @douyinfe/semi-ui 以及 @ies 和 @douyinfe 组织下相关的包。\n * lib-axios.js：包含 axios 以及相关的包。\n\n这种拆包策略将常用的包进行分组，然后拆分为单独的 chunk，一般 chunk 的数量不会很多，适合绝大部分应用，同时也是我们推荐的拆包策略。\n\n配置#\n\n\n\n注意事项#\n\n * 如果项目中没有安装或引用以上 npm 包，则不会生成相应的 chunk。\n\n\nsplit-by-module#\n\n分包策略#\n\n将每一个 NPM 包拆分为一个单独的 chunk。\n\n配置#\n\n\n\n注意事项#\n\n * 这个配置会最细化地拆分 node_modules，产生大量的文件请求。\n * 在使用 HTTP/2 时，由于存在多路复用，会加快资源的加载时间，并提高缓存命中率。\n * 在未使用 HTTP/2 时，由于 HTTP 队头阻塞问题，会导致页面加载性能下降，请谨慎使用。\n\n\nall-in-one#\n\n分包策略#\n\n此分包策略将业务代码、第三方依赖打包在同一个 chunk 中。\n\n配置#\n\n\n\n注意事项#\n\n * 这个配置会将构建生成的 JS 代码全部打包到一个文件里（除了 dynamic import 拆分的 chunk）\n * 单个 JS 文件的体积可能会非常大，使页面加载性能下降。\n\n\nsingle-vendor#\n\n分包策略#\n\n此分包策略将第三方依赖打包在一个 chunk 中，业务代码打包在另外的 chunk 中。\n\n配置#\n\n\n\n注意事项#\n\n * 单个 vendor 文件的体积可能会非常大，使页面加载性能下降。\n\n\nsplit-by-size#\n\n分包策略#\n\n该策略下，设置 minSize、maxSize 为一个固定值后，Builder 会自动进行拆分，无需干预。\n\n配置#\n\n\n\n\n自定义拆包#\n\n除了使用内置的拆包策略外，你也可以通过 Builder 自定义拆包功能来满足更多的定制化需求。自定义拆包分为两部分:\n\n * 自定义拆包分组\n * 自定义原生 bundler 拆包配置\n\n值得注意的是，这两种自定义拆包能力可以和内置的拆包策略一起使用，也就是说，你可以使用内置的拆包策略来拆分常用的包，然后再使用自定义拆包功能来拆分其他的包。\n\n\n自定义分组#\n\nBuilder 支持自定义拆包分组，这样比内置拆包策略更灵活，同时比手写 bundler 底层配置更简单。\n\n比如将 node_modules 下的 axios 库拆分到 axios.js 中：\n\n\n\n通过 forceSplitting 配置，你可以很方便把某些模块拆分为一个 chunk。\n\n注意事项#\n\n通过 forceSplitting 配置拆分的 chunk 会通过","routePath":"/builder/guide/optimization/split-chunk","lang":"zh","toc":[{"text":"拆包策略","id":"拆包策略","depth":2,"charIndex":119},{"text":"split-by-experience","id":"split-by-experience","depth":3,"charIndex":452},{"text":"分包策略","id":"分包策略","depth":4,"charIndex":474},{"text":"配置","id":"配置","depth":4,"charIndex":1054},{"text":"注意事项","id":"注意事项","depth":4,"charIndex":1061},{"text":"split-by-module","id":"split-by-module","depth":3,"charIndex":1110},{"text":"分包策略","id":"分包策略-1","depth":4,"charIndex":1128},{"text":"配置","id":"配置-1","depth":4,"charIndex":1162},{"text":"注意事项","id":"注意事项-1","depth":4,"charIndex":1169},{"text":"all-in-one","id":"all-in-one","depth":3,"charIndex":1314},{"text":"分包策略","id":"分包策略-2","depth":4,"charIndex":1327},{"text":"配置","id":"配置-2","depth":4,"charIndex":1367},{"text":"注意事项","id":"注意事项-2","depth":4,"charIndex":1374},{"text":"single-vendor","id":"single-vendor","depth":3,"charIndex":1475},{"text":"分包策略","id":"分包策略-3","depth":4,"charIndex":1491},{"text":"配置","id":"配置-3","depth":4,"charIndex":1544},{"text":"注意事项","id":"注意事项-3","depth":4,"charIndex":1551},{"text":"split-by-size","id":"split-by-size","depth":3,"charIndex":1596},{"text":"分包策略","id":"分包策略-4","depth":4,"charIndex":1612},{"text":"配置","id":"配置-4","depth":4,"charIndex":1674},{"text":"自定义拆包","id":"自定义拆包","depth":2,"charIndex":1682},{"text":"自定义分组","id":"自定义分组","depth":3,"charIndex":1864},{"text":"注意事项","id":"注意事项-4","depth":4,"charIndex":2019},{"text":"自定义 bundler 拆包配置","id":"自定义-bundler-拆包配置","depth":3,"charIndex":-1},{"text":"使用 Dynamic Import 拆包","id":"使用-dynamic-import-拆包","depth":2,"charIndex":-1}],"domain":"","frontmatter":{},"version":""},{"id":89,"title":"快速上手","content":"#\n\n注意事项\n\nModern.js Builder 已升级为 Rsbuild 独立品牌，当前文档将不再继续迭代。\n\n * 如果你在使用 Modern.js 框架，请直接访问 Modern.js 框架文档。\n * 如果你在使用 Modern.js Builder 的 CLI 或 Node API，可以轻松迁移到 Rsbuild，请访问 Rsbuild 仓库\n   了解更多。\n\n\n环境准备#\n\n在开始使用前，你需要安装 Node.js，并保证 Node.js 版本不低于 16.2.0，我们推荐使用 Node.js 18 的 LTS 版本。\n\n你可以通过以下命令检查当前使用的 Node.js 版本：\n\n\n\n如果你当前的环境中尚未安装 Node.js，或是安装的版本低于 16，可以通过 nvm 或 fnm 安装需要的版本。\n\n下面是通过 nvm 安装 Node.js 18 LTS 版本的例子：\n\n\n\nnvm 和 fnm\n\nnvm 和 fnm 都是 Node.js 版本管理工具。相对来说，nvm 较为成熟和稳定，而 fnm 是使用 Rust 实现的，比 nvm 提供了更好的性能。\n\n此外，在安装 nvm 或 fnm 后，然后只要仓库根目录下有内容为 lts/hydrogen 的 .nvmrc 文件，进入这个仓库时就会自动安装或切换到正确的\nNode.js 版本。\n\n\n使用 Modern.js 框架#\n\nModern.js 框架默认使用 Modern.js Builder 作为构建工具。因此，如果你是一名业务开发者，那么不需要手动接入\nBuilder，只需要创建一个 Modern.js 项目，就可以使用 Builder 提供的所有能力。\n\n\n\n请阅读 Modern.js - 介绍 和 Modern.js - 快速上手 来了解 Modern.js 框架的使用方法。\n\n关于文档\n\nModern.js 框架文档和 Modern.js Builder 文档部署在两个独立的站点下。如果你在使用 Modern.js\n框架的过程中遇到任何构建相关的问题，你可以随时查阅 Modern.js Builder 的文档来寻找相应的解决方案。\n\n\n使用 Builder CLI 工具#\n\nModern.js Builder 提供了一个轻量的 CLI 工具，包含 dev、build 等基础命令，它主要用于构建非 React 项目。\n\n如果你的项目不是基于 React 的，比如开发一个 Vue 项目，那么你可以使用 Builder CLI 工具来构建你的项目。\n\n请参考 使用 Builder CLI 来了解相关用法。\n\n\n在前端框架中接入#\n\n如果你正在开发一个前端框架，可以通过下面的步骤来接入 Builder:\n\n\n1. 安装 Builder#\n\n你需要安装两个包，其中：\n\n * @modern-js/builder 为 Builder 的核心包，导出了 Builder 的核心 API。\n\n * @modern-js/builder-rspack-provider，它提供基于 Rspack 的构建能力。\n\n如果你想使用 webpack 而不是 Rspack，可以将 @modern-js/builder-rspack-provider 替换为\n@modern-js/builder-webpack-provider：\n\n> 在进行版本升级时，请确保你安装的 builder 和 provider 为同一个版本。\n\n\n2. 创建 Builder 实例#\n\n创建 Builder 实例的过程分两步：\n\n首先你需要初始化 Builder Provider，并传入 builderConfig 配置对象。Builder\n提供了丰富的配置项，允许你对构建行为进行灵活定制。此时你还不需要了解配置项的具体内容，传入一个空对象即可。你可以在 API - 配置 中找到所有可用的配置项。\n\n * 初始化 webpack Provider：\n\n\n\n * 初始化 Rspack Provider：\n\n\n\n拿到 provider 实例后，你可以调用 createBuilder 方法来创建一个 Builder 实例对象：\n\n\n\n除了上述示例中的 entry 选项，createBuilder 方法也提供了一些其他的选项，你可以在 API - createBuilder 中进一步了解。\n\n\n3. 调用 Builder 实例方法#\n\nBuilder 实例提供了与构建相关的各个方法，你可以根据实际场景来进行使用。\n\n在本地开发场景，建议使用 builder.startDevServer 方法，调用后会启动本地 Dev Server。\n\n\n\n成功启动 Dev Server 后，可以看到以下日志信息：\n\n\n\n在生产环境部署场景，建议使用 builder.build 方法，调用后会构建出生产环境产物。\n\n\n\n> 关于 Builder 实例方法的更多介绍，请阅读 Builder Instance 章节。\n\n通过以上三个步骤，你已经了解了 Builder 基本的使用方法。接下来你可以通过 Builder 插件和 Builder 配置来对构建流程进行定制。\n\n\n下一步#\n\n你可能想要：","routePath":"/builder/guide/quick-start","lang":"zh","toc":[{"text":"环境准备","id":"环境准备","depth":2,"charIndex":190},{"text":"使用 Modern.js 框架","id":"使用-modernjs-框架","depth":2,"charIndex":588},{"text":"使用 Builder CLI 工具","id":"使用-builder-cli-工具","depth":2,"charIndex":922},{"text":"在前端框架中接入","id":"在前端框架中接入","depth":2,"charIndex":1110},{"text":"1. 安装 Builder","id":"1-安装-builder","depth":3,"charIndex":1159},{"text":"2. 创建 Builder 实例","id":"2-创建-builder-实例","depth":3,"charIndex":1462},{"text":"3. 调用 Builder 实例方法","id":"3-调用-builder-实例方法","depth":3,"charIndex":1838},{"text":"下一步","id":"下一步","depth":2,"charIndex":2172}],"domain":"","frontmatter":{},"version":""},{"id":91,"title":"插件系统","content":"#\n\nBuilder 提供了一套轻量强大的插件系统，用以实现自身的大多数功能，并允许用户进行扩展。 开发者编写的插件能够修改 Builder\n的默认行为并添加各类额外功能，包括但不限于：\n\n * 修改 bundler 配置\n * 处理新的文件类型\n * 修改或编译文件\n * 部署产物\n\nBuilder 底层支持 webpack 和 Rspack 等 bundler，并提供统一的 Node.js API\n来抹平插件开发的差异，进而接入不同的上层框架、降低用户对底层 bundler 切换的感知。\n\n\n开发插件#\n\n插件提供类似 (options?: PluginOptions) => BuilderPlugin 的函数作为入口，建议将插件函数命名为\nbuilderPluginXXX。\n\n\n\n函数形式的插件可以 接受选项对象 并 返回插件实例，并通过闭包机制管理内部状态。\n\n其中各部分的作用分别为：\n\n * name 属性用于标注插件名称\n * setup 作为插件逻辑的主入口\n * api 对象包含了各类钩子和工具函数\n\n为了便于识别，插件名称需要包含约定的 builder-plugin 前缀，例如 builder-plugin-foo\n@scope/builder-plugin-bar 等。\n\n\n生命周期钩子#\n\nBuilder 在内部按照约定的生命周期进行任务调度，插件可以通过注册钩子来介入工作流程的任意阶段，并实现自己的功能。\n\nBuilder 生命周期钩子的完整列表参考 API 文档。\n\nBuilder 不会接管底层 Bundler 的生命周期，相关生命周期钩子的使用方式见对应文档：webpack hooks\n\n\n使用配置项#\n\n自行编写的插件通常使用初始化时传入函数的参数作为配置项即可，开发者可以随意定义和使用函数的入参。\n\n但某些情况下插件可能需要读取 / 修改 Builder 公用的配置项，这时就需要了解 Builder 内部对配置项的生产和消费流程：\n\n * 读取、解析配置并合并默认值\n * 插件通过 api.modifyBuilderConfig(...) 回调修改配置项\n * 归一化配置项并提供给插件后续消费，此后无法再修改配置项\n\n整套流程可以通过这个简单的插件体现：\n\n\n\n插件中有三种方式使用配置项对象：\n\n * api.modifyBuilderConfig(config => {}) 在回调中修改配置\n * api.getBuilderConfig() 获取配置项\n * api.getNormalizedConfig() 获取归一化后的配置项\n\n归一化的配置项会再次合并默认值并移除大部分可选类型，对于 PluginUploadDist 的例子其部分类型定义为：\n\n\n\ngetNormalizedConfig() 的返回值类型与 BuilderConfig 的略有不同、相比文档其它地方描述的类型进行了收窄，\n在使用时无需自行判空、填充默认值。\n\n因此使用配置项的最佳方式应该是：\n\n * 通过 api.modifyBuilderConfig(config => {}) 来修改配置\n * 在其后的生命周期中读取 api.getNormalizedConfig() 作为插件实际使用的配置\n\n\n修改 webpack 配置#\n\n插件可以通过多种方式修改 webpack 的配置项。\n\n * api.modifyWebpackChain(chain => {}) 修改 webpack-chain\n * api.modifyWebpackConfig(config => {}) 修改最终的 webpack 配置\n * api.onAfterCreateCompiler(compiler => {}) 直接操作 webpack 实例\n\n通常推荐使用 neutrinojs/webpack-chain 提供的链式 API 来修改 webpack 配置的工作。\n\nBuilder 使用的是兼容 webpack5 的修改版本：sorrycc/webpack-chain。\n\n\n参考范例#\n\n\n修改 Loader#\n\nLoader 可以读取和处理不同类型的文件模块，具体参考 concepts 和 loaders。\n\n\n\n\n添加模块入口#\n\n\n\n\n接入 webpack 插件#\n\n开发者可以在 Builder 插件中接入已有的 webpack 插件来平缓迁移项目：\n\n","routePath":"/builder/plugins/introduction","lang":"zh","toc":[{"text":"开发插件","id":"开发插件","depth":2,"charIndex":250},{"text":"生命周期钩子","id":"生命周期钩子","depth":2,"charIndex":555},{"text":"使用配置项","id":"使用配置项","depth":2,"charIndex":720},{"text":"修改 webpack 配置","id":"修改-webpack-配置","depth":2,"charIndex":1377},{"text":"参考范例","id":"参考范例","depth":2,"charIndex":1714},{"text":"修改 Loader","id":"修改-loader","depth":3,"charIndex":1722},{"text":"添加模块入口","id":"添加模块入口","depth":3,"charIndex":1787},{"text":"接入 webpack 插件","id":"接入-webpack-插件","depth":3,"charIndex":1799}],"domain":"","frontmatter":{},"version":""},{"id":92,"title":"总览","content":"#\n\n\n官方插件#\n\n * @modern-js/builder-plugin-vue：用于构建 Vue 3 应用。\n * @modern-js/builder-plugin-vue2：用于构建 Vue 2 应用。\n * @modern-js/builder-plugin-swc：使用 SWC 进行代码编译和压缩以提升构建性能。\n * @modern-js/builder-plugin-stylus：使用 Stylus 作为 CSS 预处理器。\n * @modern-js/builder-plugin-esbuild：使用 esbuild 进行代码编译和压缩以提升构建性能。\n * @modern-js/builder-plugin-node-polyfill：注入 Node 核心模块在浏览器端的 Polyfills。\n * @modern-js/builder-plugin-image-compress：将项目中用到的图片资源进行压缩处理。\n\n你可以在 modern.js/packages/builder 目录下找到这些插件的源代码。","routePath":"/builder/plugins/list","lang":"zh","toc":[{"text":"官方插件","id":"官方插件","depth":2,"charIndex":3}],"domain":"","frontmatter":{},"version":""},{"id":93,"title":"Esbuild 插件","content":"#\n\nWARNING\n\n当前文档中的 esbuild 功能已停止迭代，我们更推荐使用 Rspack + SWC 的方案，因为 Rspack + SWC\n具备更好的构建性能、功能丰富度和产物兼容性。\n\n请参考「使用 Rspack」了解更多。\n\nesbuild 是一款基于 Golang 开发的前端构建工具，具有打包、编译和压缩 JavaScript 代码的功能，相比传统的打包编译工具，esbuild\n在性能上有显著提升。在代码压缩方面，相比 webpack 内置的 terser 压缩器，esbuild 在性能上有数十倍的提升。\n\nModern.js Builder 提供了 esbuild 插件，让你能使用 esbuild 代替 babel-loader、ts-loader 和\nterser 等库进行代码编译和压缩。在大型工程中启用 esbuild 后，可以大幅度减少代码编译和压缩所需的时间，同时有效避免 OOM (heap out\nof memory) 问题。\n\n\n快速开始#\n\n\n在 Modern.js 框架中使用#\n\nModern.js 框架默认集成了 Builder 的 esbuild 插件，因此，你不需要手动安装和注册插件，只需要使用 tools.esbuild\n配置项即可：\n\n\n\n\n通过 Node API 使用#\n\n如果你直接使用了 Builder 的 Node API，那么需要手动安装和注册 esbuild 插件。\n\n安装插件#\n\n你可以通过如下的命令安装插件:\n\n注册插件#\n\n通过 addPlugins 方法来注册 esbuild 插件：\n\n\n\n\n配置#\n\n插件默认会开启代码转译和代码压缩的功能，你也可以通过配置来自定义插件的行为。\n\n\nloader#\n\n * 类型：\n\n\n\n * 默认值：\n\n\n\n这个选项用于启用 JavaScript 和 TypeScript 的转译，启用时将会使用 esbuild-loader 替换 babel-loader 和\nts-loader。\n\n如果你需要修改转译参数，可以查看 esbuild-loader 文档。\n\n设置 JSX 格式#\n\n在使用 esbuild 进行代码转译时，esbuild 默认会读取 tsconfig.json 中的 compilerOptions.jsx\n字段，来决定使用哪种 JSX 语法。\n\n因此，你需要在 tsconfig.json 中设置正确的 JSX 语法。\n\n比如 React 项目，需要将 compilerOptions.jsx 设置为 react-jsx：\n\n\n\n修改目标环境#\n\n通过 target 选项来修改代码转译的目标环境。target 可以直接设置为 JavaScript 语言版本，比如\nes6，es2020；也可以设置为若干个目标环境，每个目标环境都是一个环境名称后跟一个版本号，比如 ['chrome58', 'edge16'\n,'firefox57']。target 字段的详细介绍可以参考 esbuild - target。\n\ntarget 支持设置为以下环境：\n\n * chrome\n * edge\n * firefox\n * ie\n * ios\n * node\n * opera\n * safari\n\n\n\n关闭代码转译#\n\n将 loader 设置为 false 来关闭 esbuild 代码转译，此时 Builder 会继续使用 Babel 来进行代码转译。\n\n\n\n\nminimize#\n\n * 类型：\n\n\n\n * 默认值：\n\n\n\n这个选项用于启用 JavaScript 和 CSS 的代码压缩。\n\n如果你需要修改压缩参数，可以查看 esbuild-loader 文档。\n\n修改目标环境#\n\n通过 target 选项来修改代码压缩的目标环境。\n\n\n\n关闭代码压缩#\n\n将 minimize 设置为 false 来关闭 esbuild 代码压缩，此时 Builder 会继续使用 Terser 进行代码压缩。\n\n\n\n\nesbuild 局限性#\n\n虽然 esbuild 能给现有的 webpack 项目带来明显的构建性能提升，但这个工具在接入 Builder\n时还存在一定的局限性，需要大家在接入的时候格外注意。\n\n\n兼容性#\n\n使用 esbuild 进行代码转译时（即 loader 能力），esbuild 通常最低支持到 ES2015（即 ES6）语法，并且不具备自动注入\nPolyfill 的能力。如果生产环境需要降级到 ES5 及以下的语法，建议使用 SWC 编译。\n\n你可以通过如下的配置指定目标语法版本:\n\n\n\n使用 esbuild 进行代码压缩时（即 minimize 能力），esbuild 可以在生产环境中进行压缩和混淆，通常最低支持到 ES2015 语法。\n\n如果设置压缩的 target 为 es5，需要保证所有代码已经被转义为 ES5 代码，否则会导致 esbuild 编译报错：Transforming 'xxx'\nto the configured target environment (\"es5\") is not supported yet。\n\n因此，对于生产环境需要兼容 ES5 及以下语法的项目，请谨慎开启 minimize 能力，建议使用 SWC 压缩。\n\n你可以通过如下的配置指定目标语法版本:\n\n\n\n\n不支持 Babel 插件#\n\n使用 esbuild 进行代码转译时，诸如 babel-plugin-import 等原有 Babel 插件的语法编译功能在开启 esbuild\n后无法使用。并且由于 Builder 底层使用的是 esbuild 的 Transform API，因此不支持使用额外 esbuild\n插件来进行自定义编译过程。\n\n如果你有 babel-plugin-import 等 Babel 插件相关诉求，可以使用 SWC 插件。\n\n\n产物体积#\n\n使用 esbuild 压缩虽然带来了构建效率上的提升，但 esbuild 的压缩比例是低于 terser\n的，因此构建产物的体积会增大，请根据业务情况酌情使用。通常来说，esbuild 比较适合中后台等对体积不敏感的场景。\n\n对于压缩工具之间的详细对比，可以参考 minification-benchmarks。","routePath":"/builder/plugins/plugin-esbuild","lang":"zh","toc":[{"text":"快速开始","id":"快速开始","depth":2,"charIndex":436},{"text":"在 Modern.js 框架中使用","id":"在-modernjs-框架中使用","depth":3,"charIndex":444},{"text":"通过 Node API 使用","id":"通过-node-api-使用","depth":3,"charIndex":551},{"text":"安装插件","id":"安装插件","depth":4,"charIndex":621},{"text":"注册插件","id":"注册插件","depth":4,"charIndex":645},{"text":"配置","id":"配置","depth":2,"charIndex":688},{"text":"loader","id":"loader","depth":3,"charIndex":734},{"text":"设置 JSX 格式","id":"设置-jsx-格式","depth":4,"charIndex":891},{"text":"修改目标环境","id":"修改目标环境","depth":4,"charIndex":1086},{"text":"关闭代码转译","id":"关闭代码转译","depth":4,"charIndex":1369},{"text":"minimize","id":"minimize","depth":3,"charIndex":1450},{"text":"修改目标环境","id":"修改目标环境-1","depth":4,"charIndex":1553},{"text":"关闭代码压缩","id":"关闭代码压缩","depth":4,"charIndex":1591},{"text":"esbuild 局限性","id":"esbuild-局限性","depth":2,"charIndex":1674},{"text":"兼容性","id":"兼容性","depth":3,"charIndex":1773},{"text":"不支持 Babel 插件","id":"不支持-babel-插件","depth":3,"charIndex":2236},{"text":"产物体积","id":"产物体积","depth":3,"charIndex":2462}],"domain":"","frontmatter":{},"version":""},{"id":94,"title":"Image Compress 插件","content":"#\n\nImage Compress 插件会将项目中用到的图片资源进行压缩处理，进而在图片视觉观感不受影响的同时减小产物体积。\n\n\n快速开始#\n\n\n安装插件#\n\n你可以通过如下的命令安装插件:\n\n\n注册插件#\n\n在 Modern.js 等上层框架中，你可以通过 builderPlugins 配置项来注册 Image Compress 插件：\n\n\n\n当你直接调用 Builder 的 Node API 时，可以通过 addPlugins 方法来注册 Image Compress 插件：\n\n\n\n\n配置项#\n\n插件接受一系列压缩器配置项组成的数组，数组的每一项既可以是字符串也可以是对象。字符串代表使用对应名称的压缩器并启用其默认配置， 或是使用对象格式配置并在 use\n字段指定压缩器，对象的剩余字段将作为压缩器的配置项。\n\n插件默认会开启 jpeg, png, ico 三种图片压缩器，即等同于如下两种写法的配置：\n\n\n\n\n\n通过指定配置项可以覆盖默认配置，例如让 jpeg 压缩器识别新的拓展名并设置 png 压缩器的质量：\n\n\n\n默认的 png 压缩器为有损压缩，如果需要将其替换为无损压缩器，你可以使用如下配置：\n\n\n\n配置项列表最终会转换成对应的 bundler loader 配置，因此压缩器也遵循从下到上依次匹配的规则。 例如对于如下配置，png 压缩器会优先于\npngLossless 压缩器生效：\n\n\n\n压缩器的具体配置项请参考 @napi-rs/image。","routePath":"/builder/plugins/plugin-image-compress","lang":"zh","toc":[{"text":"快速开始","id":"快速开始","depth":2,"charIndex":64},{"text":"安装插件","id":"安装插件","depth":3,"charIndex":72},{"text":"注册插件","id":"注册插件","depth":3,"charIndex":97},{"text":"配置项","id":"配置项","depth":2,"charIndex":246}],"domain":"","frontmatter":{},"version":""},{"id":95,"title":"Node Polyfill 插件","content":"#\n\nNode Polyfill 介绍\n\n通常情况下，我们不会在浏览器端使用 Node 模块。但在当前代码需要同时在 Node 端和浏览器端运行时，用到一些 Node 模块是有可能的。Node\nPolyfill 为这些 Node 模块提供了浏览器版本的 polyfills。\n\n通过使用 Node Polyfill 插件，会自动注入 Node 核心模块在浏览器端的 polyfills，让你可以在浏览器端放心使用这些模块。\n\n\n快速开始#\n\n\n在 Modern.js 框架中使用#\n\nModern.js 框架默认集成了 Builder 的 Node Polyfill 插件，因此，你不需要手动安装和注册插件，只需要将\noutput.disableNodePolyfill 设置为 false 即可：\n\n\n\n\n通过 Node API 使用#\n\n如果你直接使用了 Builder 的 Node API，那么需要手动安装和注册 Node Polyfill 插件。\n\n安装插件#\n\n你可以通过如下的命令安装插件:\n\n注册插件#\n\n通过 addPlugins 方法来注册 Node Polyfill 插件：\n\n\n\n\nNode Polyfills#\n\n\nGlobals#\n\n * Buffer\n * process\n\n当你在代码中使用以上全局变量时，对应 polyfill 会被自动注入。\n\n\n\n\nModules#\n\n * assert\n * buffer\n * console\n * constants\n * crypto\n * domain\n * events\n * http\n * https\n * os\n * path\n * punycode\n * process\n * querystring\n * stream\n * _stream_duplex\n * _stream_passthrough\n * _stream_readable\n * _stream_transform\n * _stream_writable\n * string_decoder\n * sys\n * timers\n * tty\n * url\n * util\n * vm\n * zlib\n\n当你通过 require 或 import 等语法在代码中引用以上模块时，对应 polyfill 会被注入。\n\n\n\n\nFallbacks#\n\n * child_process\n * cluster\n * dgram\n * dns\n * fs\n * module\n * net\n * readline\n * repl\n * tls\n\n目前浏览器端没有以上模块的 polyfill，因此当你引用以上模块时，会自动 fallback 为一个空对象。\n\n","routePath":"/builder/plugins/plugin-node-polyfill","lang":"zh","toc":[{"text":"快速开始","id":"快速开始","depth":2,"charIndex":213},{"text":"在 Modern.js 框架中使用","id":"在-modernjs-框架中使用","depth":3,"charIndex":221},{"text":"通过 Node API 使用","id":"通过-node-api-使用","depth":3,"charIndex":353},{"text":"安装插件","id":"安装插件","depth":4,"charIndex":429},{"text":"注册插件","id":"注册插件","depth":4,"charIndex":453},{"text":"Node Polyfills","id":"node-polyfills","depth":2,"charIndex":502},{"text":"Globals","id":"globals","depth":3,"charIndex":520},{"text":"Modules","id":"modules","depth":3,"charIndex":592},{"text":"Fallbacks","id":"fallbacks","depth":3,"charIndex":988}],"domain":"","frontmatter":{},"version":""},{"id":96,"title":"Stylus 插件","content":"#\n\nStylus 是一个富于表现力、动态的、健壮的 CSS 预处理器，本章节介绍如何在 Builder 中使用 Stylus。\n\n\n快速开始#\n\n\n安装插件#\n\n你可以通过如下的命令安装插件:\n\n\n注册插件#\n\n在 Modern.js 等上层框架中，你可以通过 builderPlugins 配置项来注册 Stylus 插件：\n\n\n\n当你直接调用 Builder 的 Node API 时，可以通过 addPlugins 方法来注册 Stylus 插件：\n\n\n\n\n示例#\n\n安装完插件后，你可以直接在代码中引入 *.styl 或 *.module.styl 文件，无须添加其他配置。\n\n * normalize.styl:\n\n\n\n * title.module.styl:\n\n\n\n * index.js:\n\n\n\n\n配置#\n\n如果你需要自定义 Stylus 的编译行为，可以使用以下配置项。\n\n\nstylusOptions#\n\n * 类型：\n\n\n\n * 默认值： undefined\n\n传递给 Stylus 的选项，请查阅 Stylus 文档 来了解具体用法。\n\n\n\n\nsourceMap#\n\n * 类型： boolean\n * 默认值： isDev\n\n是否生成 Source Map，默认在开发环境下启用。\n\n","routePath":"/builder/plugins/plugin-stylus","lang":"zh","toc":[{"text":"快速开始","id":"快速开始","depth":2,"charIndex":66},{"text":"安装插件","id":"安装插件","depth":3,"charIndex":74},{"text":"注册插件","id":"注册插件","depth":3,"charIndex":99},{"text":"示例","id":"示例","depth":2,"charIndex":232},{"text":"配置","id":"配置","depth":2,"charIndex":357},{"text":"stylusOptions","id":"stylusoptions","depth":3,"charIndex":397},{"text":"sourceMap","id":"sourcemap","depth":3,"charIndex":484}],"domain":"","frontmatter":{},"version":""},{"id":97,"title":"SWC 插件","content":"#\n\nSWC (Speedy Web Compiler) 是基于 Rust 语言编写的高性能 JavaScript 和 TypeScript 转译和压缩工具。在\nPolyfill 和语法降级方面可以和 Babel 提供一致的能力，并且性能比 Babel 高出一个数量级。\n\nModern.js 提供了开箱即用的 SWC 插件，可以为你的 Web 应用提供语法降级、Polyfill 以及压缩，并且移植了一些额外常见的 Babel\n插件。\n\n\n适用场景#\n\n在使用 SWC 插件之前，请先了解一下 SWC 插件的适用场景和局限性，以明确你的项目是否需要使用 SWC 插件。\n\n\nRspack 场景#\n\n如果你的项目中已经使用了 Rspack 作为打包工具，那么你不需要接入 SWC 插件，因为 Rspack 默认会使用 SWC 进行转译和压缩，各个 SWC\n编译能力可以开箱即用。\n\n如果你使用 Rspack 时配置了当前的 SWC 插件，它将不会产生任何效果。\n\n\nBabel 插件#\n\n如果你的项目需要注册一些自定义的 Babel 插件，由于 SWC 替代了 Babel 作为转译工具，因此使用 SWC 后，你将无法注册和使用 Babel 插件。\n\n对于大部分常见的 Babel 插件，你可以在 SWC 中找到对应的替代品，比如：\n\n * @babel/preset-env: 使用 presetEnv 代替。\n * @babel/preset-react: 使用 presetReact 代替。\n * babel-plugin-import：使用 source.transformImport 代替。\n * babel-plugin-lodash：使用 extensions.lodash 代替。\n * @emotion/babel-plugin：使用 extensions.emotion 代替。\n * babel-plugin-styled-components：使用 extensions.styledComponents 代替。\n * @babel/plugin-react-transform-remove-prop-types: 使用\n   reactUtils.removePropTypes 代替。\n\n如果你使用了 SWC 尚未支持的 Babel 插件能力，在切换到 SWC 编译后，将无法再使用它们。你可以到 swc-plugins 仓库下通过 issues\n进行反馈，我们会评估是否需要内置支持。\n\n\n产物体积#\n\n在使用 SWC 来代替 terser 和 cssnano 进行代码压缩时，构建产物的体积可能会出现少量变化。在 JavaScript 代码压缩方面，SWC\n的压缩率是优于 terser 的；在 CSS 代码压缩方面，SWC 的压缩率稍逊于 cssnano。\n\n对于压缩工具之间的详细对比，可以参考 minification-benchmarks。\n\n\n快速开始#\n\n\n在 Modern.js 框架中使用#\n\nModern.js 框架对 Builder 的 SWC 插件进行了封装，你可以通过以下方式来使用：\n\n首先，你需要执行 pnpm run new 启用 SWC 编译：\n\n\n\n执行完成后，你只需在 modern.config.ts 文件中注册 Modern.js 的 SWC 插件，即可启用 SWC 编译和压缩能力。\n\n\n\n\n通过 Node API 使用#\n\n如果你直接使用了 Builder 的 Node API，那么需要手动安装和注册 Builder 的 SWC 插件。\n\n安装插件#\n\n你可以通过如下的命令安装插件:\n\n注册插件#\n\n通过 addPlugins 方法来注册 SWC 插件：\n\n\n\nThat's it! 现在你可以在项目中无缝使用 SWC 的转译和压缩能力了。\n\n\n配置#\n\n * 类型：\n\n\n\n插件配置在 SWC 配置的基础上，为了简化部分深层配置和为提高开发体验，进行了部分拓展，例如当使用对象形式配置时，可以使用 presetReact 以及\npresetEnv 快速配置 react 以及语法降级相关功能，另外不属于插件特有的配置也会直接透传给 swc。\n\n当使用函数形式配置时，则会传入插件内部产出的默认配置，可以对其进行修改或返回新的配置。\n\n\npresetReact#\n\n * 类型： SWC 中的 react 配置。\n\n对标 @babel/preset-react。传入的值会与默认配置进行合并。\n\n插件默认会自动根据你的 react 版本确定 runtime 字段，如果 react 版本大于 17.0.0，会设置成 automatic，否则设置成\nclassic。\n\n\npresetEnv#\n\n * 类型： SWC 中的 presetEnv。\n\n对标 @babel/preset-env。传入的值会与默认配置进行合并。 默认配置为:\n\n\n\n\njsMinify#\n\n * 类型： boolean 或者 terser 中的 compress 配置。\n * 默认值： { compress: {}, mangle: true }。\n\n如果配置 false 将不会使用 SWC 的压缩能力，配置 true 会启用默认压缩配置，如果配置是对象，则会与默认配置进行合并。\n\n\ncssMinify#\n\n * 类型： boolean\n * 默认值： true\n\n是否启用 SWC 对 CSS 文件进行压缩，若启用会使得 CSS 压缩性能提高，但压缩率会略微降低。\n\n\noverrides#\n\n * 类型：\n\n\n\n * 默认值： undefined\n\n对指定文件运用另外的配置。例如需要对 foo.ts 的语法降级成 ie 11，则可以如下配置：\n\n\n\n该配置会与默认配置进行合并，并且不会影响到其他文件。\n\n\nextensions#\n\n * 类型： Object\n\nextensions 包含了从 Babel 移植过来的一些插件能力。\n\nextensions.reactUtils#\n\n * 类型：\n\n\n\n一些用于 React 的工具，包括以下配置项:\n\nreactUtils.autoImportReact\n\n * 类型： boolean\n\n自动引入 React, ``，用于 jsx 转换使用 React.createElement。\n\nreactUtils.removeEffect\n\n * 类型： boolean\n\n移除 useEffect 调用。\n\nreactUtils.removePropTypes\n\n * 类型：\n\n\n\n移除 React 组件在运行时的类型判断。移植自 @babel/plugin-react-transform-remove-prop-types。\n\n相应配置和 @babel/plugin-react-transform-remove-prop-types 插件保持一致。\n\nextensions.lodash#\n\n * 类型：\n\n\n\n * 默认值：\n\n\n\n移植自 babel-plugin-lodash，用于自动将 Lodash 的引用转换为按需引入，从而减少打包后的 Lodash 代码大小。\n\n\n\nextensions.styledComponents#\n\n * 类型：\n\n\n\n由 Next.js 团队移植自 babel-plugin-styled-components。\n\nextensions.emotion#\n\n * 类型：\n\n\n\n由 Next.js 团队移植自 @emotion/babel-plugin。\n\nextensions.pluginImport#\n\nTIP\n\nBuilder 提供了 source.transformImport 配置项，因此你不需要手动配置 extensions.pluginImport。\n\n移植自 babel-plugin-import，配置选项保持一致。\n\n一些配置可以传入函数，例如 customName，customStyleName 等，这些 JavaScript 函数会由 Rust 通过 Node-API\n调用，这种调用会造成一些性能劣化。\n\n简单的函数逻辑其实可以通过模版语言来代替，因此customName，customStyleName\n等这些配置除了可以传入函数，也可以传入字符串作为模版来代替函数，提高性能。\n\n我们以下面代码为例说明:\n\n\n\n添加以下配置：\n\n\n\n其中的 {{ member }} 会被替换为相应的引入成员，转换后:\n\n\n\n可以看出配置 customName: \"foo/es/{{ member }}\" 的效果等同于配置 customName: (member) =>\n`foo/es/${member}` ，但是不会有 Node-API 的调用开销。\n\n这里使用到的模版是 handlebars，模版配置中还内置了一些有用的辅助工具，还是以上面的导入语句为例，配置成：\n\n\n\n会转换成下面的结果:\n\n\n\n除了 kebabCase 以外还有 camelCase，snakeCase，upperCase，lowerCase 可以使用。\n\n\n限制#\n\n不支持 @babel/plugin-transform-runtime 以及其他自定义的 Babel 插件。","routePath":"/builder/plugins/plugin-swc","lang":"zh","toc":[{"text":"适用场景","id":"适用场景","depth":2,"charIndex":220},{"text":"Rspack 场景","id":"rspack-场景","depth":3,"charIndex":287},{"text":"Babel 插件","id":"babel-插件","depth":3,"charIndex":432},{"text":"产物体积","id":"产物体积","depth":3,"charIndex":1062},{"text":"快速开始","id":"快速开始","depth":2,"charIndex":1245},{"text":"在 Modern.js 框架中使用","id":"在-modernjs-框架中使用","depth":3,"charIndex":1253},{"text":"通过 Node API 使用","id":"通过-node-api-使用","depth":3,"charIndex":1435},{"text":"安装插件","id":"安装插件","depth":4,"charIndex":1511},{"text":"注册插件","id":"注册插件","depth":4,"charIndex":1535},{"text":"配置","id":"配置","depth":2,"charIndex":1615},{"text":"presetReact","id":"presetreact","depth":3,"charIndex":1811},{"text":"presetEnv","id":"presetenv","depth":3,"charIndex":1977},{"text":"jsMinify","id":"jsminify","depth":3,"charIndex":2063},{"text":"cssMinify","id":"cssminify","depth":3,"charIndex":2224},{"text":"overrides","id":"overrides","depth":3,"charIndex":2318},{"text":"extensions","id":"extensions","depth":3,"charIndex":2439},{"text":"extensions.reactUtils","id":"extensionsreactutils","depth":4,"charIndex":2503},{"text":"extensions.lodash","id":"extensionslodash","depth":4,"charIndex":2890},{"text":"extensions.styledComponents","id":"extensionsstyledcomponents","depth":4,"charIndex":3004},{"text":"extensions.emotion","id":"extensionsemotion","depth":4,"charIndex":3093},{"text":"extensions.pluginImport","id":"extensionspluginimport","depth":4,"charIndex":3164},{"text":"限制","id":"限制","depth":2,"charIndex":3816}],"domain":"","frontmatter":{},"version":""},{"id":98,"title":"Vue 插件","content":"#\n\nVue 插件提供了对 Vue 3 应用构建的支持，插件内部集成了 vue-loader 和 @vue/babel-plugin-jsx。\n\n\n快速开始#\n\n\n安装插件#\n\n你可以通过如下的命令安装插件:\n\n\n注册插件#\n\n你可以通过 addPlugins 方法来注册 Vue 插件：\n\n\n\n安装完插件后，你可以直接在代码中引入 *.vue 文件，也可以使用 Vue 的 JSX 语法，无须添加其他配置。\n\n\n配置#\n\n如果你需要自定义 Vue 的编译行为，可以使用以下配置项。\n\n\nvueLoaderOptions#\n\n * 类型： VueLoaderOptions\n * 默认值：\n\n\n\n传递给 vue-loader 的选项，请查阅 vue-loader 文档 来了解具体用法。\n\n\n\n\nvueJsxOptions#\n\n * 类型：\n\n\n\n * 默认值： {}\n\n传递给 @vue/babel-plugin-jsx 的选项，请查阅 @vue/babel-plugin-jsx 文档 来了解具体用法。\n\n","routePath":"/builder/plugins/plugin-vue","lang":"zh","toc":[{"text":"快速开始","id":"快速开始","depth":2,"charIndex":73},{"text":"安装插件","id":"安装插件","depth":3,"charIndex":81},{"text":"注册插件","id":"注册插件","depth":3,"charIndex":106},{"text":"配置","id":"配置","depth":2,"charIndex":206},{"text":"vueLoaderOptions","id":"vueloaderoptions","depth":3,"charIndex":243},{"text":"vueJsxOptions","id":"vuejsxoptions","depth":3,"charIndex":347}],"domain":"","frontmatter":{},"version":""},{"id":99,"title":"Vue 2 插件","content":"#\n\nVue 2 插件提供了对 Vue 2 应用构建的支持，插件内部集成了 vue-loader 和 @vue/babel-preset-jsx。\n\n\n快速开始#\n\n\n安装插件#\n\n你可以通过如下的命令安装插件:\n\n\n注册插件#\n\n你可以通过 addPlugins 方法来注册 Vue 2 插件：\n\n\n\n安装完插件后，你可以直接在代码中引入 *.vue 文件，也可以使用 Vue 的 JSX 语法，无须添加其他配置。\n\n\n配置#\n\n如果你需要自定义 Vue 的编译行为，可以使用以下配置项。\n\n\nvueLoaderOptions#\n\n * 类型： VueLoaderOptions\n * 默认值：\n\n\n\n传递给 vue-loader 的选项，请查阅 vue-loader 文档 来了解具体用法。\n\n\n\nTIP\n\nVue 2 插件使用的是 vue-loader v15 版本，请注意区分 v15 版本与最新版本之间可能存在配置差异。\n\n\nvueJsxOptions#\n\n * 类型：\n\n\n\n * 默认值：\n\n\n\n传递给 @vue/babel-preset-jsx 的选项，请查阅 @vue/babel-preset-jsx 文档 来了解具体用法。\n\n","routePath":"/builder/plugins/plugin-vue2","lang":"zh","toc":[{"text":"快速开始","id":"快速开始","depth":2,"charIndex":75},{"text":"安装插件","id":"安装插件","depth":3,"charIndex":83},{"text":"注册插件","id":"注册插件","depth":3,"charIndex":108},{"text":"配置","id":"配置","depth":2,"charIndex":210},{"text":"vueLoaderOptions","id":"vueloaderoptions","depth":3,"charIndex":247},{"text":"vueJsxOptions","id":"vuejsxoptions","depth":3,"charIndex":417}],"domain":"","frontmatter":{},"version":""}]